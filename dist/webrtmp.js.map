{"version":3,"file":"webrtmp.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;;;;;UCtCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;;AAEA;;AAEA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B,UAAU;AACV,2BAA2B;AAC3B;;AAEA,8BAA8B,kBAAkB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAAe,GAAG,EAAC;;;ACrNnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB;AACA;AACA,EAAE,QAAK;;AAEP,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA,KAAK,QAAK;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB;AACA;AACA,EAAE,QAAK;;AAEP,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,EAAE,QAAK;AACP;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,EAAE,QAAK;;AAEP,iBAAiB,wBAAwB;AACzC;;AAEA;AACA,IAAI,QAAK;AACT;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAe,YAAY,EAAC;;;;ACrJ5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B;;AAEA,gCAAgC;AAChC;AACA;AACA;;AAEA;;AAEA;AACO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACO;;AAEP;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;;AAEO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACO;AACP;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACO;AACP;;AAEA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAAe,OAAO,EAAC;;;AC/HvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;AACgB;AACiB;AACV;AAChB;AACF;;AAEhC;AACA;;AAEA;AACA;AACA,sBAAsB,aAAY;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE,QAAK;AACP;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE,QAAK;;AAEP;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,KAAK,QAAK;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,QAAK;AACV;AACA;AACA;AACA,OAAO,QAAK;AACZ;AACA,QAAQ;AACR,OAAO,QAAK;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ,GAAG,QAAK;AACR;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,QAAK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,aAAa;AACjC;AACA,iBAAiB,SAAS,SAAS;AACnC;;AAEA;;AAEA,EAAE,QAAK;AACP;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK,QAAK;AACV,wBAAwB,eAAe,GAAG,qCAAqC;AAC/E;AACA;AACA,KAAK;AACL,IAAI,QAAK,sBAAsB,SAAS,4BAA4B,yBAAyB,YAAY,SAAS;AAClH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,MAAM,cAAc;AACpB;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;;AAEA;AACA,EAAE,QAAK;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA,2DAA2D;AAC3D;AACA;AACA;AACA,6CAA6C,6BAA6B;AAC1E;AACA,OAAO;AACP;AACA,4CAA4C,uBAAuB;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG,QAAK,+CAA+C,SAAS,KAAK,OAAO;AAC5E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA,yBAAyB;AACzB,MAAM,QAAK,qDAAqD,eAAe,KAAK,aAAa;AACjG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA,OAAO;AACP,MAAM,QAAK;AACX,yBAAyB,eAAe,GAAG,qCAAqC;AAChF;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,QAAK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA,EAAE,QAAK;AACP;;AAEA;AACA;AACA,EAAE,QAAK;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;A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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;AACkB;AAC+D;AACjE;AACS;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,GAAG,QAAK;AACR,GAAG;AACH;AACA;AACA,GAAG,QAAK;AACR,GAAG;AACH;AACA;AACA,GAAG,QAAK;AACR,GAAG;AACH;AACA,oDAAoD;AACpD;AACA,sBAAsB,aAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,IAAI,QAAK,sCAAsC,kBAAkB,YAAY,kBAAkB;AAC/F;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAK;AACP;AACA,GAAG,QAAK;AACR,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAK;AACP;AACA;AACA;AACA,EAAE,QAAK;AACP;AACA;AACA;AACA;AACA,EAAE,QAAK;AACP;AACA;AACA;AACA;AACA,EAAE,QAAK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8BAA8B;AAChE,kCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAa,CAAC,aAAa;AAChD;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA,kBAAkB,eAAe;AACjC,sBAAsB,kBAAkB;AACxC,IAAI,sBAAsB;AAC1B,IAAI,4BAA4B;AAChC;AACA;AACA,GAAG;AACH;AACA,4BAA4B,8BAA8B;AAC1D,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAK,WAAW,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAK,WAAW,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAK;AAC3B;AACA;AACA;;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGoC;AACH;AACG;;AAE7B;AACP,eAAe,OAAO;AACtB;;AAEA,gBAAgB,MAAG","sources":["webpack://webrtmpjs/webpack/universalModuleDefinition","webpack://webrtmpjs/./node_modules/worker-loader/dist/runtime/inline.js","webpack://webrtmpjs/webpack/bootstrap","webpack://webrtmpjs/webpack/runtime/compat get default export","webpack://webrtmpjs/webpack/runtime/define property getters","webpack://webrtmpjs/webpack/runtime/hasOwnProperty shorthand","webpack://webrtmpjs/webpack/runtime/make namespace object","webpack://webrtmpjs/./src/utils/logger.js","webpack://webrtmpjs/./src/utils/event_emitter.js","webpack://webrtmpjs/./src/formats/media-segment-info.js","webpack://webrtmpjs/./src/utils/exception.js","webpack://webrtmpjs/./src/utils/utils.js","webpack://webrtmpjs/./src/utils/browser.js","webpack://webrtmpjs/./src/utils/mse-controller.js","webpack://webrtmpjs/./src/wss/connection.worker.js","webpack://webrtmpjs/./src/wss/webrtmp.controller.js","webpack://webrtmpjs/./src/webrtmp.js","webpack://webrtmpjs/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"webrtmpjs\"] = factory();\n\telse\n\t\troot[\"webrtmpjs\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n * Copyright (C) 2016 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nclass Log {\n    static OFF = -1;\n    static TRACE = 0;\n    static DEBUG = 1;\n    static INFO = 2;\n    static WARN = 3;\n    static ERROR = 4;\n    static CRITICAL = 5;\n    static WITH_STACKTRACE = true;\n\n    static LEVEL = Log.INFO;\n\n    /**\n     * Object with [ClassName, Loglevel]\n     * @type {Object}\n     */\n    static loglevels = {};\n\n    /**\n     *\n     * @param {Number} level\n     * @param {String} tag\n     * @param txt\n     * @private\n     */\n    static _output = function output(level, tag, ...txt){\n        let tmpLevel = Log.LEVEL;\n\n        // Dirty fix because inline worker cant access static properties\n        try{\n            if(Log.loglevels[tag]) tmpLevel = Log.loglevels[tag];\n        }catch (e) {\n            return;\n        }\n\n\n        if(tmpLevel === Log.OFF) return;\n        if(tmpLevel > level) return;\n\n        const callstack = Log._getStackTrace();\n\n        // debug aufruf entfernen\n        callstack.shift();\n        callstack.shift();\n\n        let color = \"color: silver\";\n\n        switch(level) {\n            case Log.TRACE:\t// TRACE\n                color = \"background-color: gray\";\n                break;\n\n            case Log.DEBUG:\t// DEBUG\n                break;\n\n            case Log.INFO:\t// INFO\n                color = \"color: green\";\n                break;\n\n            case Log.WARN:\t// WARN\n                color = \"color: orange; background-color: #EAA80035\";\n                break;\n\n            case Log.ERROR:\t// ERROR\n                color = \"color: red; background-color: #FF000020\";\n                break;\n\n            case Log.CRITICAL:\t// CRITICAL\n                color = \"color: red\";\n                break;\n        }\n\n        Log._print(callstack, color, tag, ...txt);\n    };\n\n    /**\n     * Internal for console dump\n     * @param {String[]} callstack\n     * @param {String} color\n     * @param {String} tag\n     * @param txt\n     * @private\n     */\n    static _print(callstack, color, tag, ...txt){\n        if(Log.WITH_STACKTRACE){\n            if(Log.LEVEL === Log.ERROR){\n                console.group(\"%c[\" + tag + \"]\", color, ...txt);\n            } else {\n                console.groupCollapsed(\"%c[\" + tag + \"]\", color, ...txt);\n            }\n\n            for(let i = 0; i < callstack.length; i++) {\n                console.log(\"%c\" + callstack[i], color);\n            }\n\n            console.groupEnd();\n\n        } else {\n            console.log(\"%c[\" + tag + \"]\", color, ...txt)\n        }\n    }\n\n    /**\n     * Get Callstack\n     * @returns {String[]}\n     * @private\n     */\n    static _getStackTrace = function() {\n        let callstack = [];\n\n        try {\n            i.dont.exist+=0; //doesn't exist- that's the point\n\n        } catch(e) {\n            if (e.stack) { //Firefox\n                let lines = e.stack.split('\\n');\n\n                for (let i=0; i < lines.length; i++) {\n                    callstack.push(lines[i]);\n                }\n\n                //Ersten Eintrag entfernen\n                callstack.shift();\n                callstack.shift();\n            }\n        }\n\n        return(callstack);\n    };\n\n    /**\n     * Log Critical\n     * @param {String} tag\n     * @param msg\n     */\n    static c(tag, ...msg) {\n        Log._output(Log.CRITICAL, tag, ...msg);\n    }\n\n    /**\n     * Log Error\n     * @param {String} tag\n     * @param msg\n     */\n    static e(tag, ...msg) {\n        Log._output(Log.ERROR, tag, ...msg);\n    }\n\n    /**\n     * Log Info\n     * @param {String} tag\n     * @param msg\n     */\n    static i(tag, ...msg) {\n        Log._output(Log.INFO, tag, ...msg);\n    }\n\n    /**\n     * Log Warning\n     * @param {String} tag\n     * @param msg\n     */\n    static w(tag, ...msg) {\n        Log._output(Log.WARN, tag, ...msg);\n    }\n\n    /**\n     * Log Debug\n     * @param {String} tag\n     * @param msg\n     */\n    static d(tag, ...msg) {\n        Log._output(Log.DEBUG, tag, ...msg);\n    }\n\n    /**\n     * Log Debug\n     * @param {String} tag\n     * @param msg\n     */\n    static v(tag, ...msg) {\n        Log._output(Log.DEBUG, tag, ...msg);\n    }\n\n    /**\n     * Log Trace\n     * @param {String} tag\n     * @param msg\n     */\n    static t(tag, ...msg) {\n        Log._output(Log.TRACE, tag, ...msg);\n    }\n}\n\nexport default Log;\n","/*\n *\n * Copyright (C) 2023 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport Log from \"../utils/logger\";\n\n/**\n * A small class for Handling events\n */\nclass EventEmitter{\n\tListenerList = [];\n\tTAG = \"EventEmitter\";\n\twaiters = [];\n\n\tconstructor() {\n\t}\n\n\t/**\n\t * Add an event listener\n\t * @param {String} event - The Name of the event\n\t * @param {Function} listener - the callback when occurs\n\t * @param {boolean} modal - Overwrite existing listener for this event\n\t */\n\taddEventListener(event, listener, modal = false){\n\t\tLog.d(this.TAG, \"addEventListener: \" + event);\n\n\t\tfor(let i = 0; i < this.ListenerList.length;i++){\n\t\t\tlet entry = this.ListenerList[i];\n\t\t\tif(entry[0] === event) {\n\t\t\t\tif (modal || entry[1] === listener) {\n\t\t\t\t\tLog.w(this.TAG, \"Listener already registered, overriding\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.ListenerList.push([event, listener]);\n\t}\n\n\twaitForEvent(event, callback){\n\t\tthis.waiters.push([event, callback]);\n\t}\n\n\t/**\n\t * A synonym for addEventListener\n\t * @param {String} event\n\t * @param {Function} listener\n\t * @param {boolean} modal\n\t */\n\taddListener(event, listener, modal){\n\t\tthis.addEventListener(event, listener, modal);\n\t}\n\n\n\t/**\n\t * Remove an event listener\n\t * @param {String} event\n\t * @param {Function} listener\n\t */\n\tremoveEventListener(event, listener){\n\t\tLog.d(this.TAG, \"removeEventListener: \" + event);\n\n\t\tfor(let i = 0; i < this.ListenerList.length;i++){\n\t\t\tlet entry = this.ListenerList[i];\n\t\t\tif(entry[0] === event && entry[1] === listener){\n\t\t\t\tthis.ListenerList.splice(i,1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n    /**\n     * A synonym for removeEventListener\n     * @param {String} event\n     * @param {Function} listener\n     */\n\tremoveListener(event, listener){\n\t\tthis.removeEventListener(event, listener);\n\t}\n\n\t/**\n\t * Remove all listener\n     * @param {String|undefined} event - If provided, remove all listener for this event\n\t */\n\tremoveAllEventListener(event){\n\t\tLog.d(this.TAG, \"removeAllEventListener: \", event);\n\t\tif(event) {\n\t\t\tfor(let i = 0; i < this.ListenerList.length;i++) {\n\t\t\t\tlet entry = this.ListenerList[i];\n\t\t\t\tif(entry[0] === event){\n\t\t\t\t\tthis.ListenerList.splice(i,1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tthis.ListenerList = [];\n\t}\n\n    /**\n     * A synonym for removeAllEventListener\n     * @param event\n     */\n\tremoveAllListener(event){\n\t\tthis.removeAllEventListener(event);\n\t}\n\n\t/**\n\t *\n\t * @param {String} event\n\t * @param data\n\t */\n\temit(event, ...data){\n\t\tLog.t(this.TAG, \"emit EVENT: \" + event, ...data);\n\n\t\tfor(let i = 0; i < this.waiters.length;i++){\n\t\t\tlet entry = this.waiters[i];\n\n\t\t\tif(entry[0] === event){\n\t\t\t\tLog.d(this.TAG, \"hit waiting event: \" + event);\n\t\t\t\tentry[1].call(this, ...data);\n\t\t\t\tthis.waiters.splice(i,1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tfor(let i = 0; i < this.ListenerList.length;i++){\n\t\t\tlet entry = this.ListenerList[i];\n\t\t\tif(entry[0] === event){\n\t\t\t\tentry[1].call(this, ...data);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default EventEmitter;\n\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Represents an media sample (audio / video)\nexport class SampleInfo {\n\n\tconstructor(dts, pts, duration, originalDts, isSync) {\n\t\tthis.dts = dts;\n\t\tthis.pts = pts;\n\t\tthis.duration = duration;\n\t\tthis.originalDts = originalDts;\n\t\tthis.isSyncPoint = isSync;\n\t\tthis.fileposition = null;\n\t}\n\n}\n\n// Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\nexport class MediaSegmentInfo {\n\n\tconstructor() {\n\t\tthis.beginDts = 0;\n\t\tthis.endDts = 0;\n\t\tthis.beginPts = 0;\n\t\tthis.endPts = 0;\n\t\tthis.originalBeginDts = 0;\n\t\tthis.originalEndDts = 0;\n\t\tthis.syncPoints = [];     // SampleInfo[n], for video IDR frames only\n\t\tthis.firstSample = null;  // SampleInfo\n\t\tthis.lastSample = null;   // SampleInfo\n\t}\n\n\tappendSyncPoint(sampleInfo) {  // also called Random Access Point\n\t\tsampleInfo.isSyncPoint = true;\n\t\tthis.syncPoints.push(sampleInfo);\n\t}\n\n}\n\n// Ordered list for recording video IDR frames, sorted by originalDts\nexport class IDRSampleList {\n\n\tconstructor() {\n\t\tthis._list = [];\n\t}\n\n\tclear() {\n\t\tthis._list = [];\n\t}\n\n\tappendArray(syncPoints) {\n\t\tlet list = this._list;\n\n\t\tif (syncPoints.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n\t\t\tthis.clear();\n\t\t}\n\n\t\tArray.prototype.push.apply(list, syncPoints);\n\t}\n\n\tgetLastSyncPointBeforeDts(dts) {\n\t\tif (this._list.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet list = this._list;\n\t\tlet idx = 0;\n\t\tlet last = list.length - 1;\n\t\tlet mid = 0;\n\t\tlet lbound = 0;\n\t\tlet ubound = last;\n\n\t\tif (dts < list[0].dts) {\n\t\t\tidx = 0;\n\t\t\tlbound = ubound + 1;\n\t\t}\n\n\t\twhile (lbound <= ubound) {\n\t\t\tmid = lbound + Math.floor((ubound - lbound) / 2);\n\t\t\tif (mid === last || (dts >= list[mid].dts && dts < list[mid + 1].dts)) {\n\t\t\t\tidx = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (list[mid].dts < dts) {\n\t\t\t\tlbound = mid + 1;\n\t\t\t} else {\n\t\t\t\tubound = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn this._list[idx];\n\t}\n\n}\n\n// Data structure for recording information of media segments in single track.\nexport class MediaSegmentInfoList {\n\n\tconstructor(type) {\n\t\tthis._type = type;\n\t\tthis._list = [];\n\t\tthis._lastAppendLocation = -1;  // cached last insert location\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget length() {\n\t\treturn this._list.length;\n\t}\n\n\tisEmpty() {\n\t\treturn this._list.length === 0;\n\t}\n\n\tclear() {\n\t\tthis._list = [];\n\t\tthis._lastAppendLocation = -1;\n\t}\n\n\t_searchNearestSegmentBefore(originalBeginDts) {\n\t\tlet list = this._list;\n\t\tif (list.length === 0) {\n\t\t\treturn -2;\n\t\t}\n\t\tlet last = list.length - 1;\n\t\tlet mid = 0;\n\t\tlet lbound = 0;\n\t\tlet ubound = last;\n\n\t\tlet idx = 0;\n\n\t\tif (originalBeginDts < list[0].originalBeginDts) {\n\t\t\tidx = -1;\n\t\t\treturn idx;\n\t\t}\n\n\t\twhile (lbound <= ubound) {\n\t\t\tmid = lbound + Math.floor((ubound - lbound) / 2);\n\t\t\tif (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\n\t\t\t\t(originalBeginDts < list[mid + 1].originalBeginDts))) {\n\t\t\t\tidx = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (list[mid].originalBeginDts < originalBeginDts) {\n\t\t\t\tlbound = mid + 1;\n\t\t\t} else {\n\t\t\t\tubound = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\n\t_searchNearestSegmentAfter(originalBeginDts) {\n\t\treturn this._searchNearestSegmentBefore(originalBeginDts) + 1;\n\t}\n\n\tappend(mediaSegmentInfo) {\n\t\tlet list = this._list;\n\t\tlet msi = mediaSegmentInfo;\n\t\tlet lastAppendIdx = this._lastAppendLocation;\n\t\tlet insertIdx = 0;\n\n\t\tif (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\n\t\t\tmsi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\n\t\t\t((lastAppendIdx === list.length - 1) ||\n\t\t\t\t(lastAppendIdx < list.length - 1 &&\n\t\t\t\t\tmsi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\n\t\t\tinsertIdx = lastAppendIdx + 1;  // use cached location idx\n\t\t} else {\n\t\t\tif (list.length > 0) {\n\t\t\t\tinsertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n\t\t\t}\n\t\t}\n\n\t\tthis._lastAppendLocation = insertIdx;\n\t\tthis._list.splice(insertIdx, 0, msi);\n\t}\n\n\tgetLastSegmentBefore(originalBeginDts) {\n\t\tlet idx = this._searchNearestSegmentBefore(originalBeginDts);\n\t\tif (idx >= 0) {\n\t\t\treturn this._list[idx];\n\t\t} else {  // -1\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetLastSampleBefore(originalBeginDts) {\n\t\tlet segment = this.getLastSegmentBefore(originalBeginDts);\n\t\tif (segment != null) {\n\t\t\treturn segment.lastSample;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetLastSyncPointBefore(originalBeginDts) {\n\t\tlet segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n\t\tlet syncPoints = this._list[segmentIdx].syncPoints;\n\t\twhile (syncPoints.length === 0 && segmentIdx > 0) {\n\t\t\tsegmentIdx--;\n\t\t\tsyncPoints = this._list[segmentIdx].syncPoints;\n\t\t}\n\t\tif (syncPoints.length > 0) {\n\t\t\treturn syncPoints[syncPoints.length - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class RuntimeException {\n    constructor(message) {\n        this._message = message;\n    }\n\n    get name() {\n        return 'RuntimeException';\n    }\n\n    get message() {\n        return this._message;\n    }\n\n    toString() {\n        return this.name + ': ' + this.message;\n    }\n}\n\nexport class IllegalStateException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'IllegalStateException';\n    }\n}\n\nexport class InvalidArgumentException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'InvalidArgumentException';\n    }\n}\n\nexport class NotImplementedException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'NotImplementedException';\n    }\n}\n","\n/*\n *\n * Copyright (C) 2023 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * concat two Uint8Array\n * @param {Uint8Array} bufs\n * @returns {Uint8Array}\n */\n\nexport function _concatArrayBuffers(...bufs){\n    const result = new Uint8Array(bufs.reduce((totalSize, buf)=>totalSize+buf.byteLength,0));\n    bufs.reduce((offset, buf)=>{\n        result.set(buf,offset)\n        return offset+buf.byteLength\n    },0)\n\n    return result;\n}\n\n/**\n *\n * @param {String} str\n * @returns {*[]}\n * @private\n */\nexport function _stringToByteArray(str) {\n    const bytes = [];\n\n    for(let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        if(char > 0xFF) {\n            bytes.push(char >>> 8);\n        }\n\n        bytes.push(char & 0xFF);\n    }\n    return bytes;\n}\n\n/**\n * convert Float64 to 8 byteArray\n * @param {Number} num\n * @returns {*[]}\n * @private\n */\nexport function _numberToByteArray(num) {\n    const buffer = new ArrayBuffer(8);\n    new DataView(buffer).setFloat64(0, num, false);\n    return [].slice.call(new Uint8Array(buffer));\n}\n\n/**\n * convert 8 byte byteArray to Float64\n * @param {byte[]} ba\n * @returns {number}\n * @private\n */\nexport function _byteArrayToNumber(ba){\n    let buf = new ArrayBuffer(ba.length);\n    let view = new DataView(buf);\n\n    ba.forEach(function (b, i) {\n        view.setUint8(i, b);\n    });\n\n    return view.getFloat64(0);\n}\n\n/**\n * convert byteArray to string\n * @param {byte[]} ba\n * @returns {string}\n * @private\n */\nexport function _byteArrayToString(ba){\n    let ret = \"\";\n\n    for(let i = 0; i < ba.length; i++){\n        ret += String.fromCharCode(ba[i]);\n    }\n\n    return ret;\n}\n\nexport const defaultConfig = {\n    enableStashBuffer: true,\n    stashInitialSize: undefined,\n\n    isLive: true,\n\n    autoCleanupSourceBuffer: true,\n    autoCleanupMaxBackwardDuration: 3 * 60,\n    autoCleanupMinBackwardDuration: 2 * 60,\n\n    statisticsInfoReportInterval: 600,\n\n    fixAudioTimestampGap: true,\n\n    headers: undefined\n};\n\n\nexport const TransmuxingEvents = {\n    IO_ERROR: 'io_error',\n    DEMUX_ERROR: 'demux_error',\n    INIT_SEGMENT: 'init_segment',\n    MEDIA_SEGMENT: 'media_segment',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info',\n    RECOMMEND_SEEKPOINT: 'recommend_seekpoint'\n};\n\nexport const DemuxErrors = {\n    OK: 'OK',\n    FORMAT_ERROR: 'FormatError',\n    FORMAT_UNSUPPORTED: 'FormatUnsupported',\n    CODEC_UNSUPPORTED: 'CodecUnsupported'\n};\n\nexport const MSEEvents = {\n    ERROR: 'error',\n    SOURCE_OPEN: 'source_open',\n    UPDATE_END: 'update_end',\n    BUFFER_FULL: 'buffer_full'\n};\n\nexport const PlayerEvents = {\n    ERROR: 'error',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info'\n};\n\nexport const ErrorTypes = {\n    NETWORK_ERROR: 'NetworkError',\n    MEDIA_ERROR: 'MediaError',\n    OTHER_ERROR: 'OtherError'\n};\n\nexport const LoaderErrors = {\n    OK: 'OK',\n    EXCEPTION: 'Exception',\n    HTTP_STATUS_CODE_INVALID: 'HttpStatusCodeInvalid',\n    CONNECTING_TIMEOUT: 'ConnectingTimeout',\n    EARLY_EOF: 'EarlyEof',\n    UNRECOVERABLE_EARLY_EOF: 'UnrecoverableEarlyEof'\n};\n\nexport const ErrorDetails = {\n    NETWORK_EXCEPTION: LoaderErrors.EXCEPTION,\n    NETWORK_STATUS_CODE_INVALID: LoaderErrors.HTTP_STATUS_CODE_INVALID,\n    NETWORK_TIMEOUT: LoaderErrors.CONNECTING_TIMEOUT,\n    NETWORK_UNRECOVERABLE_EARLY_EOF: LoaderErrors.UNRECOVERABLE_EARLY_EOF,\n\n    MEDIA_MSE_ERROR: 'MediaMSEError',\n\n    MEDIA_FORMAT_ERROR: DemuxErrors.FORMAT_ERROR,\n    MEDIA_FORMAT_UNSUPPORTED: DemuxErrors.FORMAT_UNSUPPORTED,\n    MEDIA_CODEC_UNSUPPORTED: DemuxErrors.CODEC_UNSUPPORTED\n};\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet Browser = {};\n\nfunction detect() {\n\t// modified from jquery-browser-plugin\n\n\tlet ua = self.navigator.userAgent.toLowerCase();\n\n\tlet match = /(edge)\\/([\\w.]+)/.exec(ua) ||\n\t\t/(opr)[\\/]([\\w.]+)/.exec(ua) ||\n\t\t/(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(iemobile)[\\/]([\\w.]+)/.exec(ua) ||\n\t\t/(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(msie) ([\\w.]+)/.exec(ua) ||\n\t\tua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua) ||\n\t\tua.indexOf('compatible') < 0 && /(firefox)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t[];\n\n\tlet platform_match = /(ipad)/.exec(ua) ||\n\t\t/(ipod)/.exec(ua) ||\n\t\t/(windows phone)/.exec(ua) ||\n\t\t/(iphone)/.exec(ua) ||\n\t\t/(kindle)/.exec(ua) ||\n\t\t/(android)/.exec(ua) ||\n\t\t/(windows)/.exec(ua) ||\n\t\t/(mac)/.exec(ua) ||\n\t\t/(linux)/.exec(ua) ||\n\t\t/(cros)/.exec(ua) ||\n\t\t[];\n\n\tlet matched = {\n\t\tbrowser: match[5] || match[3] || match[1] || '',\n\t\tversion: match[2] || match[4] || '0',\n\t\tmajorVersion: match[4] || match[2] || '0',\n\t\tplatform: platform_match[0] || ''\n\t};\n\n\tlet browser = {};\n\tif (matched.browser) {\n\t\tbrowser[matched.browser] = true;\n\n\t\tlet versionArray = matched.majorVersion.split('.');\n\t\tbrowser.version = {\n\t\t\tmajor: parseInt(matched.majorVersion, 10),\n\t\t\tstring: matched.version\n\t\t};\n\t\tif (versionArray.length > 1) {\n\t\t\tbrowser.version.minor = parseInt(versionArray[1], 10);\n\t\t}\n\t\tif (versionArray.length > 2) {\n\t\t\tbrowser.version.build = parseInt(versionArray[2], 10);\n\t\t}\n\t}\n\n\tif (matched.platform) {\n\t\tbrowser[matched.platform] = true;\n\t}\n\n\tif (browser.chrome || browser.opr || browser.safari) {\n\t\tbrowser.webkit = true;\n\t}\n\n\t// MSIE. IE11 has 'rv' identifer\n\tif (browser.rv || browser.iemobile) {\n\t\tif (browser.rv) {\n\t\t\tdelete browser.rv;\n\t\t}\n\t\tlet msie = 'msie';\n\t\tmatched.browser = msie;\n\t\tbrowser[msie] = true;\n\t}\n\n\t// Microsoft Edge\n\tif (browser.edge) {\n\t\tdelete browser.edge;\n\t\tlet msedge = 'msedge';\n\t\tmatched.browser = msedge;\n\t\tbrowser[msedge] = true;\n\t}\n\n\t// Opera 15+\n\tif (browser.opr) {\n\t\tlet opera = 'opera';\n\t\tmatched.browser = opera;\n\t\tbrowser[opera] = true;\n\t}\n\n\t// Stock android browsers are marked as Safari\n\tif (browser.safari && browser.android) {\n\t\tlet android = 'android';\n\t\tmatched.browser = android;\n\t\tbrowser[android] = true;\n\t}\n\n\tbrowser.name = matched.browser;\n\tbrowser.platform = matched.platform;\n\n\tfor (let key in Browser) {\n\t\tif (Browser.hasOwnProperty(key)) {\n\t\t\tdelete Browser[key];\n\t\t}\n\t}\n\tObject.assign(Browser, browser);\n}\n\ndetect();\n\nexport default Browser;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from \"./logger\";\nimport EventEmitter from \"./event_emitter\";\nimport {IDRSampleList} from \"../formats/media-segment-info\";\nimport {IllegalStateException} from \"./exception\";\nimport {MSEEvents} from \"./utils\";\nimport Browser from \"./browser\";\n\nclass MSEController {\n\tTAG = 'MSEController';\n\n\tconstructor(config) {\n\t\tthis._config = config;\n\t\tthis._emitter = new EventEmitter();\n\n\t\tif (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n\t\t\t// For live stream, do auto cleanup by default\n\t\t\tthis._config.autoCleanupSourceBuffer = true;\n\t\t}\n\n\t\tthis.e = {\n\t\t\tonSourceOpen: this._onSourceOpen.bind(this),\n\t\t\tonSourceEnded: this._onSourceEnded.bind(this),\n\t\t\tonSourceClose: this._onSourceClose.bind(this),\n\t\t\tonSourceBufferError: this._onSourceBufferError.bind(this),\n\t\t\tonSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n\t\t};\n\n\t\tthis._mediaSource = null;\n\t\tthis._mediaSourceObjectURL = null;\n\t\tthis._mediaElement = null;\n\n\t\tthis._isBufferFull = false;\n\t\tthis._hasPendingEos = false;\n\n\t\tthis._requireSetMediaDuration = false;\n\t\tthis._pendingMediaDuration = 0;\n\n\t\tthis._pendingSourceBufferInit = [];\n\t\tthis._mimeTypes = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._sourceBuffers = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._lastInitSegments = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._pendingSegments = {\n\t\t\tvideo: [],\n\t\t\taudio: []\n\t\t};\n\t\tthis._pendingRemoveRanges = {\n\t\t\tvideo: [],\n\t\t\taudio: []\n\t\t};\n\t\tthis._idrList = new IDRSampleList();\n\t}\n\n\tdestroy() {\n\t\tif (this._mediaElement || this._mediaSource) {\n\t\t\tthis.detachMediaElement();\n\t\t}\n\t\tthis.e = null;\n\t\tthis._emitter.removeAllListener();\n\t\tthis._emitter = null;\n\t}\n\n\ton(event, listener) {\n\t\tthis._emitter.addListener(event, listener);\n\t}\n\n\toff(event, listener) {\n\t\tthis._emitter.removeListener(event, listener);\n\t}\n\n\tattachMediaElement(mediaElement) {\n\t\tLog.i(this.TAG, \"attach\");\n\t\tif (this._mediaSource) {\n\t\t\tthrow new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n\t\t}\n\t\tlet ms = this._mediaSource = new window.MediaSource();\n\t\tms.addEventListener('sourceopen', this.e.onSourceOpen);\n\t\tms.addEventListener('sourceended', this.e.onSourceEnded);\n\t\tms.addEventListener('sourceclose', this.e.onSourceClose);\n\n\t\tthis._mediaElement = mediaElement;\n\t\tthis._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n\t\tmediaElement.src = this._mediaSourceObjectURL;\n\t}\n\n\tdetachMediaElement() {\n\t\tLog.i(this.TAG, \"detach\");\n\n\t\tif (this._mediaSource) {\n\t\t\tlet ms = this._mediaSource;\n\n\t\t\tif (ms.readyState === 'open') {\n\t\t\t\ttry {\n\t\t\t\t\tms.endOfStream();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor (let type in this._sourceBuffers) {\n\t\t\t\t// pending segments should be discard\n\t\t\t\tlet ps = this._pendingSegments[type];\n\t\t\t\tps.splice(0, ps.length);\n\t\t\t\tthis._pendingSegments[type] = null;\n\t\t\t\tthis._pendingRemoveRanges[type] = null;\n\t\t\t\tthis._lastInitSegments[type] = null;\n\n\t\t\t\t// remove all sourcebuffers\n\t\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\t\tif (sb) {\n\t\t\t\t\tLog.i(this.TAG, \"try to remove sourcebuffer: \" + type);\n\t\t\t\t\tif (ms.readyState !== 'closed') {\n\t\t\t\t\t\t// ms edge can throw an error: Unexpected call to method or property access\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tLog.i(this.TAG, \"removing sourcebuffer: \" + type);\n\t\t\t\t\t\t\tms.removeSourceBuffer(sb);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsb.removeEventListener('error', this.e.onSourceBufferError);\n\t\t\t\t\t\tsb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n\t\t\t\t\t}\n\t\t\t\t\tthis._mimeTypes[type] = null;\n\t\t\t\t\tthis._sourceBuffers[type] = null;\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\t// proprerly remove sourcebuffers\n\t\t\t/*\n\t\t\tfor(let mimeType in this._sourceBuffers) {\n\t\t\t\tthis._mediaSource.removeSourceBuffer(this._sourceBuffers[mimeType]);\n\t\t\t}*/\n\n\t\t\tms.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t\tms.removeEventListener('sourceended', this.e.onSourceEnded);\n\t\t\tms.removeEventListener('sourceclose', this.e.onSourceClose);\n\t\t\tthis._pendingSourceBufferInit = [];\n\t\t\tthis._isBufferFull = false;\n\t\t\tthis._idrList.clear();\n\t\t\tthis._mediaSource = null;\n\n\t\t} else {\n\t\t\tLog.w(this.TAG, \"no mediasource attached\");\n\t\t}\n\n\t\tif (this._mediaElement) {\n\t\t\tthis._mediaElement.src = '';\n\t\t\tthis._mediaElement.removeAttribute('src');\n\t\t\tthis._mediaElement = null;\n\t\t}\n\n\t\tif (this._mediaSourceObjectURL) {\n\t\t\twindow.URL.revokeObjectURL(this._mediaSourceObjectURL);\n\t\t\tthis._mediaSourceObjectURL = null;\n\t\t}\n\t}\n\n\tappendInitSegment(initSegment, deferred) {\n\t\tLog.i(this.TAG, \"appendInitSegment\", initSegment);\n\t\tif (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n\t\t\t// sourcebuffer creation requires mediaSource.readyState === 'open'\n\t\t\t// so we defer the sourcebuffer creation, until sourceopen event triggered\n\t\t\tthis._pendingSourceBufferInit.push(initSegment);\n\t\t\t// make sure that this InitSegment is in the front of pending segments queue\n\t\t\tthis._pendingSegments[initSegment.type].push(initSegment);\n\t\t\treturn;\n\t\t}\n\n\t\tlet is = initSegment;\n\t\tlet mimeType = `${is.container}`;\n\t\tif (is.codec && is.codec.length > 0) {\n\t\t\tmimeType += `;codecs=${is.codec}`;\n\t\t}\n\n\t\tlet firstInitSegment = false;\n\n\t\tLog.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n\t\tthis._lastInitSegments[is.type] = is;\n\n\t\tif (mimeType !== this._mimeTypes[is.type]) {\n\t\t\tif (!this._mimeTypes[is.type]) {  // empty, first chance create sourcebuffer\n\t\t\t\tfirstInitSegment = true;\n\t\t\t\ttry {\n\t\t\t\t\tlet sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n\t\t\t\t\tsb.addEventListener('error', this.e.onSourceBufferError);\n\t\t\t\t\tsb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\tthis._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLog.v(this.TAG, `Notice: ${is.type} mimeType changed, origin: ${this._mimeTypes[is.type]}, target: ${mimeType}`);\n\t\t\t}\n\t\t\tthis._mimeTypes[is.type] = mimeType;\n\t\t}\n\n\t\tif (!deferred) {\n\t\t\t// deferred means this InitSegment has been pushed to pendingSegments queue\n\t\t\tthis._pendingSegments[is.type].push(is);\n\t\t}\n\t\tif (!firstInitSegment) {  // append immediately only if init segment in subsequence\n\t\t\tif (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n\t\t\t\tthis._doAppendSegments();\n\t\t\t}\n\t\t}\n\t\tif (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n\t\t\t// 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n\t\t\t// Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n\t\t\tthis._requireSetMediaDuration = true;\n\t\t\tthis._pendingMediaDuration = is.mediaDuration / 1000;  // in seconds\n\t\t\tthis._updateMediaSourceDuration();\n\t\t}\n\t}\n\n\tappendMediaSegment(mediaSegment) {\n\t\tLog.d(this.TAG, \"appendMediaSegment\", mediaSegment);\n\t\tlet ms = mediaSegment;\n\t\tthis._pendingSegments[ms.type].push(ms);\n\n\t\tif (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n\t\t\tthis._doCleanupSourceBuffer();\n\t\t}\n\n\t\tlet sb = this._sourceBuffers[ms.type];\n\t\tif (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n\t\t\tthis._doAppendSegments();\n\t\t}\n\t}\n\n\tendOfStream() {\n\t\tlet ms = this._mediaSource;\n\t\tlet sb = this._sourceBuffers;\n\t\tif (!ms || ms.readyState !== 'open') {\n\t\t\tif (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n\t\t\t\t// If MediaSource hasn't turned into open state, and there're pending segments\n\t\t\t\t// Mark pending endOfStream, defer call until all pending segments appended complete\n\t\t\t\tthis._hasPendingEos = true;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n\t\t\t// If any sourcebuffer is updating, defer endOfStream operation\n\t\t\t// See _onSourceBufferUpdateEnd()\n\t\t\tthis._hasPendingEos = true;\n\t\t} else {\n\t\t\tthis._hasPendingEos = false;\n\t\t\t// Notify media data loading complete\n\t\t\t// This is helpful for correcting total duration to match last media segment\n\t\t\t// Otherwise MediaElement's ended event may not be triggered\n\t\t\tms.endOfStream();\n\t\t}\n\t}\n\n\t_needCleanupSourceBuffer() {\n\t\tif (!this._config.autoCleanupSourceBuffer) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet currentTime = this._mediaElement.currentTime;\n\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (sb) {\n\t\t\t\tlet buffered = sb.buffered;\n\t\t\t\tif (buffered.length >= 1) {\n\t\t\t\t\tif (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_doCleanupSourceBuffer() {\n\t\tlet currentTime = this._mediaElement.currentTime;\n\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (sb) {\n\t\t\t\tlet buffered = sb.buffered;\n\t\t\t\tlet doRemove = false;\n\n\t\t\t\tfor (let i = 0; i < buffered.length; i++) {\n\t\t\t\t\tlet start = buffered.start(i);\n\t\t\t\t\tlet end = buffered.end(i);\n\n\t\t\t\t\tif (start <= currentTime && currentTime < end + 3) {  // padding 3 seconds\n\t\t\t\t\t\tif (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n\t\t\t\t\t\t\tdoRemove = true;\n\t\t\t\t\t\t\tlet removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n\t\t\t\t\t\t\tthis._pendingRemoveRanges[type].push({start: start, end: removeEnd});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (end < currentTime) {\n\t\t\t\t\t\tdoRemove = true;\n\t\t\t\t\t\tthis._pendingRemoveRanges[type].push({start: start, end: end});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (doRemove && !sb.updating) {\n\t\t\t\t\tthis._doRemoveRanges();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateMediaSourceDuration() {\n\t\tlet sb = this._sourceBuffers;\n\t\tif (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n\t\t\treturn;\n\t\t}\n\t\tif ((sb.video && sb.video.updating) || (sb.audio && sb.audio.updating)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet current = this._mediaSource.duration;\n\t\tlet target = this._pendingMediaDuration;\n\n\t\tif (target > 0 && (isNaN(current) || target > current)) {\n\t\t\tLog.v(this.TAG, `Update MediaSource duration from ${current} to ${target}`);\n\t\t\tthis._mediaSource.duration = target;\n\t\t}\n\n\t\tthis._requireSetMediaDuration = false;\n\t\tthis._pendingMediaDuration = 0;\n\t}\n\n\t_doRemoveRanges() {\n\t\tfor (let type in this._pendingRemoveRanges) {\n\t\t\tif (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tlet ranges = this._pendingRemoveRanges[type];\n\t\t\twhile (ranges.length && !sb.updating) {\n\t\t\t\tlet range = ranges.shift();\n\t\t\t\tsb.remove(range.start, range.end);\n\t\t\t}\n\t\t}\n\t}\n\n\t_doAppendSegments() {\n\t\tlet pendingSegments = this._pendingSegments;\n\n\t\tfor (let type in pendingSegments) {\n\t\t\tif (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pendingSegments[type].length > 0) {\n\t\t\t\tlet segment = pendingSegments[type].shift();\n\n\t\t\t\tif (segment.timestampOffset) {\n\t\t\t\t\t// For MPEG audio stream in MSE, if unbuffered-seeking occurred\n\t\t\t\t\t// We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n\t\t\t\t\tlet currentOffset = this._sourceBuffers[type].timestampOffset;\n\t\t\t\t\tlet targetOffset = segment.timestampOffset / 1000;  // in seconds\n\n\t\t\t\t\tlet delta = Math.abs(currentOffset - targetOffset);\n\t\t\t\t\tif (delta > 0.1) {  // If time delta > 100ms\n\t\t\t\t\t\tLog.v(this.TAG, `Update MPEG audio timestampOffset from ${currentOffset} to ${targetOffset}`);\n\t\t\t\t\t\tthis._sourceBuffers[type].timestampOffset = targetOffset;\n\t\t\t\t\t}\n\t\t\t\t\tdelete segment.timestampOffset;\n\t\t\t\t}\n\n\t\t\t\tif (!segment.data || segment.data.byteLength === 0) {\n\t\t\t\t\t// Ignore empty buffer\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tthis._sourceBuffers[type].appendBuffer(segment.data);\n\t\t\t\t\tthis._isBufferFull = false;\n\t\t\t\t\tif (type === 'video' && segment.hasOwnProperty('info')) {\n\t\t\t\t\t\tthis._idrList.appendArray(segment.info.syncPoints);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._pendingSegments[type].unshift(segment);\n\t\t\t\t\tif (error.code === 22) {  // QuotaExceededError\n\t\t\t\t\t\t/* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n\t\t\t\t\t\t * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n\t\t\t\t\t\t * SourceBuffer eviction policy may be changed in future version of FireFox.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Related issues:\n\t\t\t\t\t\t * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n\t\t\t\t\t\t * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n\t\t\t\t\t\t */\n\n\t\t\t\t\t\t// report buffer full, abort network IO\n\t\t\t\t\t\tif (!this._isBufferFull) {\n\t\t\t\t\t\t\tthis._emitter.emit(MSEEvents.BUFFER_FULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._isBufferFull = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\t\tthis._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSourceOpen() {\n\t\tLog.v(this.TAG, 'MediaSource onSourceOpen');\n\t\tthis._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t// deferred sourcebuffer creation / initialization\n\t\tif (this._pendingSourceBufferInit.length > 0) {\n\t\t\tlet pendings = this._pendingSourceBufferInit;\n\t\t\twhile (pendings.length) {\n\t\t\t\tlet segment = pendings.shift();\n\t\t\t\tthis.appendInitSegment(segment, true);\n\t\t\t}\n\t\t}\n\t\t// there may be some pending media segments, append them\n\t\tif (this._hasPendingSegments()) {\n\t\t\tthis._doAppendSegments();\n\t\t}\n\t\tthis._emitter.emit(MSEEvents.SOURCE_OPEN);\n\t}\n\n\t_onSourceEnded() {\n\t\t// fired on endOfStream\n\t\tLog.v(this.TAG, 'MediaSource onSourceEnded');\n\t}\n\n\t_onSourceClose() {\n\t\t// fired on detaching from media element\n\t\tLog.v(this.TAG, 'MediaSource onSourceClose');\n\t\tif (this._mediaSource && this.e != null) {\n\t\t\tthis._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t\tthis._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n\t\t\tthis._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n\t\t}\n\t}\n\n\t_hasPendingSegments() {\n\t\tlet ps = this._pendingSegments;\n\t\treturn ps.video.length > 0 || ps.audio.length > 0;\n\t}\n\n\t_hasPendingRemoveRanges() {\n\t\tlet prr = this._pendingRemoveRanges;\n\t\treturn prr.video.length > 0 || prr.audio.length > 0;\n\t}\n\n\t_onSourceBufferUpdateEnd() {\n\t\tif (this._requireSetMediaDuration) {\n\t\t\tthis._updateMediaSourceDuration();\n\t\t} else if (this._hasPendingRemoveRanges()) {\n\t\t\tthis._doRemoveRanges();\n\t\t} else if (this._hasPendingSegments()) {\n\t\t\tthis._doAppendSegments();\n\t\t} else if (this._hasPendingEos) {\n\t\t\tthis.endOfStream();\n\t\t}\n\t\tthis._emitter.emit(MSEEvents.UPDATE_END);\n\t}\n\n\t_onSourceBufferError(e) {\n\t\tLog.e(this.TAG, `SourceBuffer Error: ${e}`);\n\t\t// this error might not always be fatal, just ignore it\n\t}\n\n}\n\nexport default MSEController;\n","\nimport worker from \"!!../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"/******/ (() => { // webpackBootstrap\\n/******/ \\t\\\"use strict\\\";\\nvar __webpack_exports__ = {};\\n/*!***************************************************!*\\\\\\n  !*** ./src/wss/connection.worker.js + 25 modules ***!\\n  \\\\***************************************************/\\n\\n;// CONCATENATED MODULE: ./src/utils/logger.js\\n/*\\n * Copyright (C) 2016 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\nclass Log {\\n    static OFF = -1;\\n    static TRACE = 0;\\n    static DEBUG = 1;\\n    static INFO = 2;\\n    static WARN = 3;\\n    static ERROR = 4;\\n    static CRITICAL = 5;\\n    static WITH_STACKTRACE = true;\\n\\n    static LEVEL = Log.INFO;\\n\\n    /**\\n     * Object with [ClassName, Loglevel]\\n     * @type {Object}\\n     */\\n    static loglevels = {};\\n\\n    /**\\n     *\\n     * @param {Number} level\\n     * @param {String} tag\\n     * @param txt\\n     * @private\\n     */\\n    static _output = function output(level, tag, ...txt){\\n        let tmpLevel = Log.LEVEL;\\n\\n        // Dirty fix because inline worker cant access static properties\\n        try{\\n            if(Log.loglevels[tag]) tmpLevel = Log.loglevels[tag];\\n        }catch (e) {\\n            return;\\n        }\\n\\n\\n        if(tmpLevel === Log.OFF) return;\\n        if(tmpLevel > level) return;\\n\\n        const callstack = Log._getStackTrace();\\n\\n        // debug aufruf entfernen\\n        callstack.shift();\\n        callstack.shift();\\n\\n        let color = \\\"color: silver\\\";\\n\\n        switch(level) {\\n            case Log.TRACE:\\t// TRACE\\n                color = \\\"background-color: gray\\\";\\n                break;\\n\\n            case Log.DEBUG:\\t// DEBUG\\n                break;\\n\\n            case Log.INFO:\\t// INFO\\n                color = \\\"color: green\\\";\\n                break;\\n\\n            case Log.WARN:\\t// WARN\\n                color = \\\"color: orange; background-color: #EAA80035\\\";\\n                break;\\n\\n            case Log.ERROR:\\t// ERROR\\n                color = \\\"color: red; background-color: #FF000020\\\";\\n                break;\\n\\n            case Log.CRITICAL:\\t// CRITICAL\\n                color = \\\"color: red\\\";\\n                break;\\n        }\\n\\n        Log._print(callstack, color, tag, ...txt);\\n    };\\n\\n    /**\\n     * Internal for console dump\\n     * @param {String[]} callstack\\n     * @param {String} color\\n     * @param {String} tag\\n     * @param txt\\n     * @private\\n     */\\n    static _print(callstack, color, tag, ...txt){\\n        if(Log.WITH_STACKTRACE){\\n            if(Log.LEVEL === Log.ERROR){\\n                console.group(\\\"%c[\\\" + tag + \\\"]\\\", color, ...txt);\\n            } else {\\n                console.groupCollapsed(\\\"%c[\\\" + tag + \\\"]\\\", color, ...txt);\\n            }\\n\\n            for(let i = 0; i < callstack.length; i++) {\\n                console.log(\\\"%c\\\" + callstack[i], color);\\n            }\\n\\n            console.groupEnd();\\n\\n        } else {\\n            console.log(\\\"%c[\\\" + tag + \\\"]\\\", color, ...txt)\\n        }\\n    }\\n\\n    /**\\n     * Get Callstack\\n     * @returns {String[]}\\n     * @private\\n     */\\n    static _getStackTrace = function() {\\n        let callstack = [];\\n\\n        try {\\n            i.dont.exist+=0; //doesn't exist- that's the point\\n\\n        } catch(e) {\\n            if (e.stack) { //Firefox\\n                let lines = e.stack.split('\\\\n');\\n\\n                for (let i=0; i < lines.length; i++) {\\n                    callstack.push(lines[i]);\\n                }\\n\\n                //Ersten Eintrag entfernen\\n                callstack.shift();\\n                callstack.shift();\\n            }\\n        }\\n\\n        return(callstack);\\n    };\\n\\n    /**\\n     * Log Critical\\n     * @param {String} tag\\n     * @param msg\\n     */\\n    static c(tag, ...msg) {\\n        Log._output(Log.CRITICAL, tag, ...msg);\\n    }\\n\\n    /**\\n     * Log Error\\n     * @param {String} tag\\n     * @param msg\\n     */\\n    static e(tag, ...msg) {\\n        Log._output(Log.ERROR, tag, ...msg);\\n    }\\n\\n    /**\\n     * Log Info\\n     * @param {String} tag\\n     * @param msg\\n     */\\n    static i(tag, ...msg) {\\n        Log._output(Log.INFO, tag, ...msg);\\n    }\\n\\n    /**\\n     * Log Warning\\n     * @param {String} tag\\n     * @param msg\\n     */\\n    static w(tag, ...msg) {\\n        Log._output(Log.WARN, tag, ...msg);\\n    }\\n\\n    /**\\n     * Log Debug\\n     * @param {String} tag\\n     * @param msg\\n     */\\n    static d(tag, ...msg) {\\n        Log._output(Log.DEBUG, tag, ...msg);\\n    }\\n\\n    /**\\n     * Log Debug\\n     * @param {String} tag\\n     * @param msg\\n     */\\n    static v(tag, ...msg) {\\n        Log._output(Log.DEBUG, tag, ...msg);\\n    }\\n\\n    /**\\n     * Log Trace\\n     * @param {String} tag\\n     * @param msg\\n     */\\n    static t(tag, ...msg) {\\n        Log._output(Log.TRACE, tag, ...msg);\\n    }\\n}\\n\\n/* harmony default export */ const logger = (Log);\\n\\n;// CONCATENATED MODULE: ./src/wss/WSSConnectionManager.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\nclass WSSConnectionManager{\\n    TAG = \\\"WSSConnectionManager\\\";\\n    host;\\n    port;\\n    wss;\\n\\n    /**\\n     * Open WSS connection\\n     * @param {String} host\\n     * @param {Number} port\\n     * @param callback\\n     */\\n    open(host, port, callback){\\n        this.host = host;\\n        logger.v(this.TAG, \\\"connecting to: \\\" + host + \\\":\\\" + port);\\n        this.wss = new WebSocket(\\\"wss://\\\" + host + \\\":\\\" + port + \\\"/\\\");\\n\\n        this.wss.binaryType = \\\"arraybuffer\\\";\\n\\n        this.wss.onopen = (e)=>{\\n            logger.v(this.TAG, e);\\n            callback(true);\\n        }\\n\\n        this.wss.onclose = (e)=>{\\n            logger.w(this.TAG, e);\\n            postMessage([\\\"ConnectionLost\\\"]);\\n        }\\n\\n        this.wss.onerror = (e)=>{\\n            logger.e(this.TAG, e);\\n            callback(false);\\n        }\\n    }\\n\\n    /**\\n     * register a callback for messages\\n     * @param cb\\n     */\\n    registerMessageHandler(cb){\\n        this.wss.onmessage = cb;\\n    }\\n\\n    /**\\n     * returns the WebSocket\\n     * @returns {WebSocket}\\n     */\\n    getSocket(){\\n        return this.wss;\\n    }\\n\\n    getHost(){\\n        return this.host;\\n    }\\n\\n    /**\\n     * close Websocket\\n     */\\n    close(){\\n        this.wss.close();\\n    }\\n}\\n\\n/* harmony default export */ const wss_WSSConnectionManager = (WSSConnectionManager);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/RTMPHandshake.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n/**\\n * Class for handle the rtmp handshake\\n */\\nclass RTMPHandshake{\\n    TAG = \\\"RTMPHandshake\\\";\\n    state = 0;\\n    onHandshakeDone = null;\\n    c1;\\n    c2;\\n\\n    /**\\n     *\\n     * @param {WebSocket} socket\\n     */\\n    constructor(socket) {\\n        this.socket = socket;\\n\\n        this.socket.onmessage = (e)=>{\\n            logger.v(this.TAG, e.data);\\n            this.processServerInput(new Uint8Array(e.data));\\n        }\\n    }\\n\\n    /**\\n     * Do RTMP Handshake\\n     */\\n    do(){\\n        if(!this.onHandshakeDone) {\\n            logger.e(this.TAG, \\\"onHandshakeDone not defined\\\");\\n            return;\\n        }\\n\\n        logger.v(this.TAG, \\\"send C0\\\");\\n        this.socket.send(new Uint8Array([0x03]));\\n        this.state = 1;\\n\\n        logger.v(this.TAG, \\\"send C1\\\");\\n        this.socket.send(this._generateC1());\\n        this.state = 2;\\n    }\\n\\n    _generateC1(){\\n        const c1 = new Uint8Array(1536);\\n\\n        for(let i = 0; i < c1.length; i++) {\\n            c1[i] = Math.floor(Math.random() * 256);\\n        }\\n\\n        let time = Math.round(Date.now() / 1000);\\n\\n        c1[0] = (time >>> 24);\\n        c1[1] = (time >>> 16);\\n        c1[2] = (time >>> 8);\\n        c1[3] = (time);\\n\\n        c1[4] = 0;\\n        c1[5] = 0;\\n        c1[6] = 0;\\n        c1[7] = 0;\\n\\n        this.c1 = c1;\\n        return c1;\\n    }\\n\\n    _generateC2(s1){\\n        this.c2 = s1;\\n        return this.c2;\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} data\\n     * @private\\n     */\\n    _parseS0(data){\\n        logger.v(this.TAG, \\\"S0: \\\", data);\\n\\n        if(data[0] !== 0x03) {\\n            logger.e(this.TAG, \\\"S0 response not 0x03\\\");\\n\\n        } else {\\n            logger.v(this.TAG, \\\"1st Byte OK\\\");\\n        }\\n\\n        this.state = 3;\\n\\n        if(data.length > 1) {\\n            logger.v(this.TAG, \\\"S1 included\\\");\\n            this._parseS1(data.slice(1));\\n        }\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} data\\n     * @private\\n     */\\n    _parseS1(data){\\n        logger.v(this.TAG, \\\"parse S1: \\\", data);\\n        this.state = 4;\\n\\n        let s1 = data.slice(0, 1536);\\n\\n        logger.v(this.TAG, \\\"send C2\\\");\\n        this.socket.send(this._generateC2(s1));\\n\\n        this.state = 5;\\n\\n        if(data.length > 1536) {\\n            logger.v(this.TAG, \\\"S2 included: \\\" + data.length);\\n            this._parseS2(data.slice(1536));\\n        }\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} data\\n     * @private\\n     */\\n    _parseS2(data) {\\n        logger.v(this.TAG, \\\"parse S2: \\\", data);\\n\\n        if(!this._compare(this.c1, data)) {\\n            logger.e(this.TAG, \\\"C1 S1 not equal\\\");\\n            this.onHandshakeDone(false);\\n            return;\\n        }\\n\\n        this.state = 6;\\n\\n        logger.v(this.TAG, \\\"RTMP Connection established\\\");\\n\\n        this.onHandshakeDone(true);\\n    }\\n\\n    /**\\n     * compare to arrays\\n     * @param ar1\\n     * @param ar2\\n     * @returns {boolean}\\n     * @private\\n     */\\n    _compare(ar1, ar2){\\n        for(let i = 0; i < ar1.length; i++){\\n            if(ar1[i] !== ar2[i]) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    /**\\n     *\\n     * @param {Uint8Array} data\\n     */\\n    processServerInput(data){\\n        switch(this.state){\\n            case 2:\\t\\t//\\n                this._parseS0(data);\\n                break;\\n\\n            case 3:\\n                this._parseS1(data);\\n                break;\\n\\n            case 5:\\n                this._parseS2(data);\\n                break;\\n        }\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_RTMPHandshake = (RTMPHandshake);\\n\\n;// CONCATENATED MODULE: ./src/utils/utils.js\\n\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n/**\\n * concat two Uint8Array\\n * @param {Uint8Array} bufs\\n * @returns {Uint8Array}\\n */\\n\\nfunction _concatArrayBuffers(...bufs){\\n    const result = new Uint8Array(bufs.reduce((totalSize, buf)=>totalSize+buf.byteLength,0));\\n    bufs.reduce((offset, buf)=>{\\n        result.set(buf,offset)\\n        return offset+buf.byteLength\\n    },0)\\n\\n    return result;\\n}\\n\\n/**\\n *\\n * @param {String} str\\n * @returns {*[]}\\n * @private\\n */\\nfunction _stringToByteArray(str) {\\n    const bytes = [];\\n\\n    for(let i = 0; i < str.length; i++) {\\n        const char = str.charCodeAt(i);\\n        if(char > 0xFF) {\\n            bytes.push(char >>> 8);\\n        }\\n\\n        bytes.push(char & 0xFF);\\n    }\\n    return bytes;\\n}\\n\\n/**\\n * convert Float64 to 8 byteArray\\n * @param {Number} num\\n * @returns {*[]}\\n * @private\\n */\\nfunction _numberToByteArray(num) {\\n    const buffer = new ArrayBuffer(8);\\n    new DataView(buffer).setFloat64(0, num, false);\\n    return [].slice.call(new Uint8Array(buffer));\\n}\\n\\n/**\\n * convert 8 byte byteArray to Float64\\n * @param {byte[]} ba\\n * @returns {number}\\n * @private\\n */\\nfunction _byteArrayToNumber(ba){\\n    let buf = new ArrayBuffer(ba.length);\\n    let view = new DataView(buf);\\n\\n    ba.forEach(function (b, i) {\\n        view.setUint8(i, b);\\n    });\\n\\n    return view.getFloat64(0);\\n}\\n\\n/**\\n * convert byteArray to string\\n * @param {byte[]} ba\\n * @returns {string}\\n * @private\\n */\\nfunction _byteArrayToString(ba){\\n    let ret = \\\"\\\";\\n\\n    for(let i = 0; i < ba.length; i++){\\n        ret += String.fromCharCode(ba[i]);\\n    }\\n\\n    return ret;\\n}\\n\\nconst defaultConfig = {\\n    enableStashBuffer: true,\\n    stashInitialSize: undefined,\\n\\n    isLive: true,\\n\\n    autoCleanupSourceBuffer: true,\\n    autoCleanupMaxBackwardDuration: 3 * 60,\\n    autoCleanupMinBackwardDuration: 2 * 60,\\n\\n    statisticsInfoReportInterval: 600,\\n\\n    fixAudioTimestampGap: true,\\n\\n    headers: undefined\\n};\\n\\n\\nconst TransmuxingEvents = {\\n    IO_ERROR: 'io_error',\\n    DEMUX_ERROR: 'demux_error',\\n    INIT_SEGMENT: 'init_segment',\\n    MEDIA_SEGMENT: 'media_segment',\\n    LOADING_COMPLETE: 'loading_complete',\\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\\n    MEDIA_INFO: 'media_info',\\n    METADATA_ARRIVED: 'metadata_arrived',\\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\\n    STATISTICS_INFO: 'statistics_info',\\n    RECOMMEND_SEEKPOINT: 'recommend_seekpoint'\\n};\\n\\nconst DemuxErrors = {\\n    OK: 'OK',\\n    FORMAT_ERROR: 'FormatError',\\n    FORMAT_UNSUPPORTED: 'FormatUnsupported',\\n    CODEC_UNSUPPORTED: 'CodecUnsupported'\\n};\\n\\nconst MSEEvents = {\\n    ERROR: 'error',\\n    SOURCE_OPEN: 'source_open',\\n    UPDATE_END: 'update_end',\\n    BUFFER_FULL: 'buffer_full'\\n};\\n\\nconst PlayerEvents = {\\n    ERROR: 'error',\\n    LOADING_COMPLETE: 'loading_complete',\\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\\n    MEDIA_INFO: 'media_info',\\n    METADATA_ARRIVED: 'metadata_arrived',\\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\\n    STATISTICS_INFO: 'statistics_info'\\n};\\n\\nconst ErrorTypes = {\\n    NETWORK_ERROR: 'NetworkError',\\n    MEDIA_ERROR: 'MediaError',\\n    OTHER_ERROR: 'OtherError'\\n};\\n\\nconst LoaderErrors = {\\n    OK: 'OK',\\n    EXCEPTION: 'Exception',\\n    HTTP_STATUS_CODE_INVALID: 'HttpStatusCodeInvalid',\\n    CONNECTING_TIMEOUT: 'ConnectingTimeout',\\n    EARLY_EOF: 'EarlyEof',\\n    UNRECOVERABLE_EARLY_EOF: 'UnrecoverableEarlyEof'\\n};\\n\\nconst ErrorDetails = {\\n    NETWORK_EXCEPTION: LoaderErrors.EXCEPTION,\\n    NETWORK_STATUS_CODE_INVALID: LoaderErrors.HTTP_STATUS_CODE_INVALID,\\n    NETWORK_TIMEOUT: LoaderErrors.CONNECTING_TIMEOUT,\\n    NETWORK_UNRECOVERABLE_EARLY_EOF: LoaderErrors.UNRECOVERABLE_EARLY_EOF,\\n\\n    MEDIA_MSE_ERROR: 'MediaMSEError',\\n\\n    MEDIA_FORMAT_ERROR: DemuxErrors.FORMAT_ERROR,\\n    MEDIA_FORMAT_UNSUPPORTED: DemuxErrors.FORMAT_UNSUPPORTED,\\n    MEDIA_CODEC_UNSUPPORTED: DemuxErrors.CODEC_UNSUPPORTED\\n};\\n\\n;// CONCATENATED MODULE: ./src/rtmp/RTMPMessage.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n\\n/**\\n * Class which represent a RTMP Message\\n */\\nclass RTMPMessage{\\n\\tTAG = \\\"RTMPMessage\\\";\\n\\n    static MessageTypes = [\\\"dummy\\\", \\\"PCMSetChunkSize\\\", \\\"PCMAbortMessage\\\", \\\"PCMAcknolegement\\\", \\\"UserControlMessage\\\", \\\"WindowAcknowledgementSize\\\", \\\"PCMSetPeerBandwidth\\\",\\n        \\\"dummy\\\", \\\"AudioMessage\\\", \\\"VideoMessage\\\", \\\"dummy\\\", \\\"dummy\\\", \\\"dummy\\\", \\\"dummy\\\", \\\"dummy\\\", \\\"DataMessageAMF3\\\", \\\"Shared Object Message AMF3\\\", \\\"CommandMessageAMF3\\\",\\n        \\\"DataMessageAMF0\\\", \\\"SharedObjectMessageAMF0\\\", \\\"CommandMessageAMF0\\\", \\\"dummy\\\", \\\"Aggregate Message\\\"];\\n\\n    messageType;\\n\\tmessageLength = 0;\\n    length = 0;\\n\\ttimestamp = 0;\\n    extendedTimestamp = false;\\n\\tmessage_stream_id = 0;\\n\\tpayload = new Uint8Array(0);\\n\\n    /**\\n     *\\n     * @param {Uint8Array} payload\\n     */\\n\\tconstructor(payload) {\\n        if(payload) {\\n\\t\\t\\tthis.setMessageLength(payload.length);\\n            this.addPayload(payload);\\n        }\\n\\t}\\n\\n\\tclearPayload(){\\n\\t\\tthis.payload = new Uint8Array(0);\\n\\t}\\n\\n    /**\\n     *\\n     * @returns {Uint8Array}\\n     */\\n\\tgetBytes(){\\n\\t\\tthis.header = new Uint8Array(11);\\n\\t\\tthis.header[0] = this.messageType;\\n\\n\\t\\tthis.header[1] = (this.length >>> 16);\\n\\t\\tthis.header[2] = (this.length >>> 8);\\n\\t\\tthis.header[3] = (this.length);\\n\\n\\t\\tthis.header[4] = (this.timestamp >>> 24);\\n\\t\\tthis.header[5] = (this.timestamp >>> 16);\\n\\t\\tthis.header[6] = (this.timestamp >>> 8);\\n\\t\\tthis.header[7] = (this.timestamp);\\n\\n\\t\\tthis.header[8] = (this.message_stream_id >>> 16);\\n\\t\\tthis.header[9] = (this.message_stream_id >>> 8);\\n\\t\\tthis.header[10] = (this.message_stream_id);\\n\\n\\t\\treturn _concatArrayBuffers(this.header, this.payload);\\n\\t}\\n\\n\\t/**\\n\\t *\\n\\t * @param {Number} message_type\\n\\t */\\n    setMessageType(message_type){\\n        this.messageType = message_type;\\n        switch(message_type){\\n            case 1:\\t\\t// setBandwidth\\n            case 2:\\n            case 3:\\n            case 4:     // UserControlMSG\\n            case 5:\\n            case 6:\\n                this.message_stream_id = 0;\\n                break;\\n        }\\n    }\\n\\n\\tgetMessageType(){\\n\\t\\treturn this.messageType;\\n\\t}\\n\\n    getMessageStreamID(){\\n        return this.message_stream_id;\\n    }\\n\\n\\tsetMessageStreamID(messageStreamID) {\\n\\t\\tthis.message_stream_id = messageStreamID;\\n\\t}\\n\\n\\tgetPayloadlength(){\\n\\t\\treturn this.payload.length;\\n\\t}\\n\\n    getTimestamp(){\\n        return this.timestamp;\\n    }\\n\\n\\tsetMessageTimestamp(timestamp) {\\n\\t\\tlogger.v(this.TAG, \\\"TS: \\\" + timestamp);\\n\\t\\tthis.timestamp = timestamp;\\n\\t}\\n\\n    /**\\n     *\\n     * @param {boolean} yes\\n     */\\n    setExtendedTimestamp(yes){\\n\\t\\tlogger.w(this.TAG, \\\"setExtendedTimestamp\\\");\\n        this.extendedTimestamp = yes;\\n    }\\n\\n    getExtendedTimestamp(){\\n        return this.extendedTimestamp;\\n    }\\n\\n\\tsetTimestampDelta(timestamp_delta){\\n\\t\\tlogger.v(this.TAG, \\\"TS: \\\" + this.timestamp + \\\" Delta: \\\" + timestamp_delta);\\n\\t\\tthis.timestamp += timestamp_delta;\\n\\t}\\n\\n\\t/**\\n\\t *\\n\\t * @param {Uint8Array} data\\n\\t */\\n\\taddPayload(data){\\n\\t\\tif(data.length > this.bytesMissing()) {\\n\\t\\t\\tlogger.e(this.TAG, \\\"try to add too much data\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.payload = _concatArrayBuffers(this.payload, data);\\n\\t\\tthis.length = this.payload.length;\\n\\t\\tlogger.d(this.TAG, \\\"[ RTMPMessage ] payload size is now: \\\" + this.length);\\n\\t}\\n\\n\\tgetPayload(){\\n\\t\\treturn this.payload;\\n\\t}\\n\\n    setMessageLength(message_length) {\\n        this.messageLength = message_length;\\n    }\\n\\n\\tgetMessageLength(){\\n\\t\\treturn this.messageLength;\\n\\t}\\n\\n\\tisComplete(){\\n\\t\\tif(this.payload.length === this.messageLength) return true;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbytesMissing(){\\n\\t\\treturn this.messageLength - this.payload.length;\\n\\t}\\n}\\n\\n/* harmony default export */ const rtmp_RTMPMessage = (RTMPMessage);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/Chunk.js\\n\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n\\nclass Chunk{\\n    TAG = \\\"Chunk\\\";\\n    chunk_stream_id = 0;\\n\\n    length;\\n\\n    message_type;\\n    message_stream_id = 0;\\n\\n    timestamp;\\n    CHUNK_SIZE = 128;\\n    payload;\\n\\n    /**\\n     * @param {RTMPMessage} message\\n     */\\n    constructor(message) {  // RTMP Message\\n        this.payload = message.getPayload();\\n        this.length = this.payload.length;\\n        this.message_type = message.getMessageType();\\n        this.message_stream_id = message.getMessageStreamID();\\n    }\\n\\n    /**\\n     * get bytes of the current chunk\\n     * @returns {Uint8Array}\\n     */\\n    getBytes(){\\n        let p = new Uint8Array(this.payload);\\n\\n        let ret = new Uint8Array(0);\\n        let fmt = 0;\\n\\n        do {\\n            logger.d(this.TAG, \\\"create chunk: \\\" + p.length);\\n            ret = _concatArrayBuffers(ret, this._getHeaderBytes(fmt), p.slice(0,this.CHUNK_SIZE));\\n            p = p.slice(this.CHUNK_SIZE);\\n            fmt = 0x3;\\t// next chunk without header\\n\\n        } while(p.length > 0);\\n\\n        return ret;\\n    }\\n\\n    /**\\n     * get bytes from chunk header\\n     * @param {Number} fmt\\n     * @returns {Uint8Array}\\n     * @private\\n     */\\n    _getHeaderBytes(fmt){\\n        let basic_header;\\n        let header;\\n\\n        if(this.chunk_stream_id < 63) {\\n            basic_header = new Uint8Array(1);\\n            basic_header[0] = (fmt << 6) | this.chunk_stream_id;\\n\\n        } else if(this.chunk_stream_id < 65599) {\\n            basic_header = new Uint8Array(2);\\n            basic_header[0] = (fmt << 6);\\n            basic_header[1] = (this.chunk_stream_id -64);\\n\\n        } else {\\n            basic_header = new Uint8Array(3);\\n            basic_header[0] = (fmt << 6) | 63;\\n            basic_header[1] = ((this.chunk_stream_id -64) >>> 8);\\n            basic_header[2] = ((this.chunk_stream_id -64));\\n        }\\n\\n        switch(fmt){\\n            case 0x0:\\n                header = new Uint8Array(11);\\n                header[0] = (this.timestamp >>> 16);\\n                header[1] = (this.timestamp >>> 8);\\n                header[2] = (this.timestamp);\\n\\n                header[3] = (this.length >>> 16);\\n                header[4] = (this.length >>> 8);\\n                header[5] = (this.length);\\n\\n                header[6] = (this.message_type);\\n\\n                header[7] = (this.message_stream_id >>> 24);\\n                header[8] = (this.message_stream_id >>> 16);\\n                header[9] = (this.message_stream_id >>> 8);\\n                header[10] = (this.message_stream_id);\\n                break;\\n\\n            case 0x1:\\n                header = new Uint8Array(7);\\n                header[0] = (this.timestamp >>> 16);\\n                header[1] = (this.timestamp >>> 8);\\n                header[2] = (this.timestamp);\\n\\n                header[3] = (this.length >>> 16);\\n                header[4] = (this.length >>> 8);\\n                header[5] = (this.length);\\n\\n                header[6] = (this.message_type);\\n                break;\\n\\n\\n            case 0x2:\\n                header = new Uint8Array(3);\\n                header[0] = (this.timestamp >>> 16);\\n                header[1] = (this.timestamp >>> 8);\\n                header[2] = (this.timestamp);\\n                break;\\n\\n            case 0x3:\\n                header = new Uint8Array(0);\\n                break;\\n        }\\n\\n        return _concatArrayBuffers(basic_header, header);\\n    }\\n\\n    getPayload(){\\n        return this.payload;\\n    }\\n\\n    getMessageType(){\\n        return this.message_type;\\n    }\\n\\n    getMessageStreamID() {\\n        return this.message_stream_id;\\n    }\\n\\n    setChunkSize(size){\\n        this.CHUNK_SIZE = size;\\n    }\\n\\n    /**\\n     * Sets the Chunk StreamID\\n     * @param {Number} chunk_stream_id\\n     */\\n    setChunkStreamID(chunk_stream_id) {\\n        logger.d(this.TAG, \\\"setChunkStreamID:\\\" + chunk_stream_id);\\n        this.chunk_stream_id = chunk_stream_id;\\n    }\\n\\n    /**\\n     * Sets the Message StreamID of the Chunk\\n     * @param {Number} message_stream_id\\n     */\\n    setMessageStreamID(message_stream_id) {\\n        this.message_stream_id = message_stream_id;\\n    }\\n\\n    /**\\n     * Sets the Timestamp of the chunk\\n     * @param {Number} timestamp\\n     */\\n    setTimestamp(timestamp){\\n        this.timestamp = timestamp;\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_Chunk = (Chunk);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/UserControlMessage.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\nclass UserControlMessage{\\n    event_type;\\n    event_data1;\\n    event_data2;\\n\\n    static events = [\\\"StreamBegin\\\", \\\"StreamEOF\\\", \\\"StreamDry\\\", \\\"SetBuffer\\\", \\\"StreamIsRecorded\\\", \\\"dummy\\\", \\\"PingRequest\\\", \\\"PingResponse\\\"];\\n\\n    /**\\n     *\\n     * @returns {Uint8Array}\\n     */\\n    getBytes(){\\n        let ret;\\n\\n        if(this.event_data2) {\\n            ret = new Uint8Array(10);\\n            ret[0] = (this.event_type >>> 8);\\n            ret[1] = (this.event_type);\\n\\n            ret[2] = (this.event_data1 >>> 24);\\n            ret[3] = (this.event_data1 >>> 16);\\n            ret[4] = (this.event_data1 >>> 8);\\n            ret[5] = (this.event_data1);\\n\\n            ret[6] = (this.event_data2 >>> 24);\\n            ret[7] = (this.event_data2 >>> 16);\\n            ret[8] = (this.event_data2 >>> 8);\\n            ret[9] = (this.event_data2);\\n\\n        } else {\\n            ret = new Uint8Array(6);\\n            ret[0] = (this.event_type >>> 8);\\n            ret[1] = (this.event_type);\\n\\n            ret[2] = (this.event_data1 >>> 24);\\n            ret[3] = (this.event_data1 >>> 16);\\n            ret[4] = (this.event_data1 >>> 8);\\n            ret[5] = (this.event_data1);\\n        }\\n\\n        return ret;\\n    }\\n\\n    getEventMessage(){\\n        let o = {};\\n\\n        if(this.event_type === 3) {\\n            o[UserControlMessage.events[this.event_type]] = [this.event_data1, this.event_data2];\\n        } else {\\n            o[UserControlMessage.events[this.event_type]] = this.event_data1;\\n        }\\n\\n        return o;\\n    }\\n\\n    setType(event_type){\\n        this.event_type = event_type;\\n    }\\n\\n    setEventData(event_data){\\n        this.event_data1 = event_data;\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_UserControlMessage = (UserControlMessage);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/ProtocolControlMessage.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\nclass ProtocolControlMessage{\\n    TAG = \\\"ProtocolControlMessage\\\";\\n    pcm_type;\\n    data;\\n\\n    static pcm_types = [\\\"dummy\\\", \\\"SetChunkSize\\\", \\\"AbortMessage\\\", \\\"Acknowledgement\\\", \\\"UserControlMessage\\\", \\\"WindowAcknowledgementSize\\\", \\\"SetPeerBandwidth\\\"];\\n\\n    constructor(pcm_type, data) {\\n        switch(pcm_type){\\n        case 1:\\n        case 2:\\n        case 3:\\n        case 5:\\n            this.pcm_type = pcm_type;\\n            this.data = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\\n            break;\\n\\n        case 6:\\n            logger.w(this.TAG, \\\"Protocol Control Message Type: \\\" + pcm_type + \\\" use SetPeerBandwidthMessage\\\");\\n            break;\\n\\n        default:\\n            logger.e(this.TAG, \\\"Protocol Control Message Type: \\\" + pcm_type + \\\" not supported\\\");\\n            break;\\n        }\\n    }\\n\\n    setPayload(data){\\n        this.data = data;\\n    }\\n\\n    getEventMessage(){\\n        let o = {};\\n        o[ProtocolControlMessage.pcm_types[this.pcm_type]] = this.data;\\n        return o;\\n    }\\n\\n    getBytes(){\\n        let ret = [];\\n\\n        ret[0] = (this.data >>> 24);\\n        ret[1] = (this.data >>> 16);\\n        ret[2] = (this.data >>> 8);\\n        ret[3] = (this.data);\\n\\n        return new Uint8Array(ret);\\n    }\\n}\\n/* harmony default export */ const rtmp_ProtocolControlMessage = (ProtocolControlMessage);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/NetConnection.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n\\n\\n\\nclass NetConnection{\\n    TAG = \\\"NetConnection\\\";\\n    WindowAcknowledgementSize;\\n    MessageStreamID;\\n    CHUNK_SIZE = 128;\\n    BandWidth;\\n    socket;\\n\\n    /**\\n     *\\n     * @param {Number} message_stream_id\\n     * @param {RTMPMessageHandler} handler\\n     */\\n    constructor(message_stream_id, handler) {\\n        this.MessageStreamID = message_stream_id;\\n\\n        logger.d(this.TAG, handler);\\n\\n        this.handler = handler;\\n        this.socket = handler.socket;\\n    }\\n\\n    /**\\n     *\\n     * @param {RTMPMessage} message\\n     */\\n    parseMessage(message){      // RTMPMessage\\n        let data = message.getPayload();\\n\\n        switch(message.getMessageType()){\\n        case 1:         // PCM Set Chunk Size\\n            this.CHUNK_SIZE = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\\n            this.handler.setChunkSize(this.CHUNK_SIZE)\\n            break;\\n\\n        case 2:         // PCM Abort Message\\n        case 3:         // PCM Acknowledgement\\n        case 5:         // PCM Window Acknowledgement Size\\n            this.WindowAcknowledgementSize = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\\n            logger.i(this.TAG, \\\"WindowAcknowledgementSize: \\\" + this.WindowAcknowledgementSize);\\n            break;\\n\\n        case 6:         // PCM Set Peer Bandwidth\\n            this.BandWidth = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\\n            logger.i(this.TAG, \\\"SetPeerBandwidth: \\\" + this.BandWidth);\\n\\n            // send Window Ack Size\\n            let msg = new rtmp_ProtocolControlMessage(0x05, this.WindowAcknowledgementSize);\\n\\n            let m2 = new rtmp_RTMPMessage(msg.getBytes());\\n            m2.setMessageType(0x05)     // WinACKSize\\n\\n            const chunk = new rtmp_Chunk(m2);\\n            chunk.setChunkStreamID(2);  // Control Channel\\n\\n            logger.i(this.TAG, \\\"send WindowAcksize\\\");\\n            this.socket.send(chunk.getBytes());\\n\\n            break;\\n\\n        default:\\n            break;\\n        }\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_NetConnection = (NetConnection);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/ChunkParser.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n\\n\\n/**\\n * Class for parsing a Chunk\\n */\\nclass ChunkParser {\\n    TAG = \\\"ChunkParser\\\";\\n\\n    /**\\n     *\\n     * @type {number}\\n     */\\n\\tstatic CHUNK_SIZE = 128;\\n    _chunkstreams = [];\\n\\n    /**\\n     * @type {Uint8Array}\\n     */\\n    _buffer = new Uint8Array(0);\\n\\n    /**\\n     *\\n     * @param {RTMPMessageHandler} conn_worker\\n     */\\n\\tconstructor(conn_worker) {\\n        this.conn_worker = conn_worker;\\n    }\\n\\n    /**\\n     * Parse chunk data. Just simply add your UInt8Array, splitting and concating is automatically\\n     * @param {Uint8Array} newdata\\n     */\\n    parseChunk(newdata){\\n        let msg;\\n        let timestamp;\\n        let fmt;\\n\\n        this._buffer = _concatArrayBuffers(this._buffer, newdata);      // Neues Packet an Buffer anfügen\\n\\n        do {\\n            logger.d(this.TAG, \\\"buffer length: \\\" + this._buffer.length);\\n\\n            if(this._buffer.length < 100) logger.d(this.TAG, this._buffer);\\n\\n            /**\\n             *\\n             * @type {Uint8Array}\\n             */\\n            let data = this._buffer;\\n            let header_length = 0;\\n            let message_length = 0;\\n            let payload_length = 0;\\n\\n            // Message Header Type\\n            fmt = ((data[0] & 0xC0) >>> 6);  // upper 2 bit\\n\\n            // Basic Header ChunkID\\n            let csid = data[header_length++] & 0x3f;\\t// lower 6 bits\\n\\n            if(csid === 0) {\\t\\t\\t\\t\\t// csid is 14bit\\n                csid = data[header_length++] + 64;\\n\\n            } else if (csid === 1) {\\t\\t\\t// csid is 22bit\\n                csid = data[header_length++] * 256 + data[header_length++] + 64;\\n            }\\n\\n            logger.d(this.TAG, \\\"chunk type: \\\", fmt, \\\" StreamID: \\\" + csid);\\n\\n            let payload;\\n\\n            // Message\\n            switch(fmt) {\\n                case 0:\\t\\t// 11 byte\\n                timestamp = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\t// 3 byte timestamp\\n                message_length = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\t// 3 byte Message length\\n\\n                msg = new rtmp_RTMPMessage();\\n                msg.setMessageType(data[header_length++]);                // 1 byte msg type\\n                msg.setMessageStreamID((data[header_length++] << 24) | (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]));\\t// 4 byte Message stream id\\n                msg.setMessageLength(message_length);\\n\\n                if (timestamp === 0xFFFFFF) {\\t// extended Timestamp\\n                    timestamp = (data[header_length++] << 24) | (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\n                    msg.setExtendedTimestamp(true);\\n                }\\n\\n                msg.setMessageTimestamp(timestamp);\\n\\n                logger.d(this.TAG, \\\"message_length: \\\" + message_length);\\n\\n                this._chunkstreams[csid] = msg;\\n                break;\\n\\n            case 1:\\t\\t// 7 byte\\n                timestamp = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\t// 3 byte timestamp\\n                message_length = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\t// 3 byte Message length\\n\\n                msg = this._chunkstreams[csid];\\n                msg.setMessageType(data[header_length++]);\\n                msg.setMessageLength(message_length);\\n\\n                if (timestamp === 0xFFFFFF) {\\t// extended Timestamp\\n                    timestamp = (data[header_length++] << 24) | (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\n                    msg.setExtendedTimestamp(true);\\n                } else {\\n                    msg.setExtendedTimestamp(false);\\n                }\\n\\n                msg.setTimestampDelta(timestamp);\\n\\n                logger.d(this.TAG, \\\"message_length: \\\" + message_length);\\n\\n                this._chunkstreams[csid] = msg;\\n                break;\\n\\n            case 2:\\t\\t// 3 byte\\n                timestamp = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\t// 3 byte timestamp delta\\n\\n                msg = this._chunkstreams[csid];\\n\\n                if (timestamp === 0xFFFFFF) {\\t// extended Timestamp\\n                    timestamp = (data[header_length++] << 24) | (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\n                    msg.setExtendedTimestamp(true);\\n\\n                } else {\\n                    msg.setExtendedTimestamp(false);\\n                }\\n\\n                msg.setTimestampDelta(timestamp);\\n\\n                break;\\n\\n            case 3:\\t\\t// 0 byte\\n                msg = this._chunkstreams[csid];\\n\\n                // extended timestamp is present when setted in the chunk stream\\n                if(msg.getExtendedTimestamp()) {\\n                    timestamp = (data[header_length++] << 24) | (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\\n                    msg.setTimestampDelta(timestamp);\\n                }\\n\\n                break;\\n            }\\n\\n            if(!msg) {\\n                logger.e(this.TAG, \\\"No suitable RTMPMessage found\\\");\\n            }\\n\\n\\n\\n            payload_length = this._chunkstreams[csid].bytesMissing();\\n\\n            if(payload_length > this.CHUNK_SIZE) payload_length = this.CHUNK_SIZE;      // Max. CHUNK_SIZE erwarten\\n\\n            payload = data.slice(header_length, header_length +payload_length);\\n\\n            // sind genug bytes für das chunk da?\\n            if(payload.length < payload_length){\\n                logger.d(this.TAG, \\\"packet(\\\" + payload.length + \\\"/\\\" + payload_length + \\\") too small, wait for next\\\");\\n                return;\\n            }\\n\\n            this._chunkstreams[csid].addPayload(payload);\\n\\n            if(this._chunkstreams[csid].isComplete()) {     // Message complete\\n                logger.d(this.TAG, \\\"RTMP: \\\", msg.getMessageType(), rtmp_RTMPMessage.MessageTypes[msg.getMessageType()], msg.getPayloadlength(), msg.getMessageStreamID());\\n                this.conn_worker.onMessage(this._chunkstreams[csid]);\\n                this._chunkstreams[csid].clearPayload();\\n            }\\n\\n            let consumed = (header_length + payload_length);\\n\\n            if(consumed > this._buffer.length) {\\n                logger.w(this.TAG, \\\"mehr abschneiden als da\\\");\\n            }\\n\\n            this._buffer = this._buffer.slice(consumed);\\n            logger.d(this.TAG, \\\"consumed: \\\" + consumed + \\\" bytes, rest: \\\" + this._buffer.length);\\n\\n        } while(this._buffer.length > 11);   // minimum size\\n\\n        logger.d(this.TAG, \\\"parseChunk complete\\\");\\n    }\\n\\n\\n\\n    /**\\n     * Sets the chunk_size\\n     * @param {Number} size\\n     */\\n    setChunkSize(size){\\n        logger.d(this.TAG, \\\"SetChunkSize: \\\" + size);\\n        this.CHUNK_SIZE = size;\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_ChunkParser = (ChunkParser);\\n\\n;// CONCATENATED MODULE: ./src/utils/exception.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nclass RuntimeException {\\n    constructor(message) {\\n        this._message = message;\\n    }\\n\\n    get name() {\\n        return 'RuntimeException';\\n    }\\n\\n    get message() {\\n        return this._message;\\n    }\\n\\n    toString() {\\n        return this.name + ': ' + this.message;\\n    }\\n}\\n\\nclass IllegalStateException extends RuntimeException {\\n    constructor(message) {\\n        super(message);\\n    }\\n\\n    get name() {\\n        return 'IllegalStateException';\\n    }\\n}\\n\\nclass InvalidArgumentException extends RuntimeException {\\n    constructor(message) {\\n        super(message);\\n    }\\n\\n    get name() {\\n        return 'InvalidArgumentException';\\n    }\\n}\\n\\nclass NotImplementedException extends RuntimeException {\\n    constructor(message) {\\n        super(message);\\n    }\\n\\n    get name() {\\n        return 'NotImplementedException';\\n    }\\n}\\n\\n;// CONCATENATED MODULE: ./src/formats/media-info.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nclass MediaInfo {\\n\\n\\tconstructor() {\\n\\t\\tthis.mimeType = null;\\n\\t\\tthis.duration = null;\\n\\n\\t\\tthis.hasAudio = null;\\n\\t\\tthis.hasVideo = null;\\n\\t\\tthis.audioCodec = null;\\n\\t\\tthis.videoCodec = null;\\n\\t\\tthis.audioDataRate = null;\\n\\t\\tthis.videoDataRate = null;\\n\\n\\t\\tthis.audioSampleRate = null;\\n\\t\\tthis.audioChannelCount = null;\\n\\n\\t\\tthis.width = null;\\n\\t\\tthis.height = null;\\n\\t\\tthis.fps = null;\\n\\t\\tthis.profile = null;\\n\\t\\tthis.level = null;\\n\\t\\tthis.refFrames = null;\\n\\t\\tthis.chromaFormat = null;\\n\\t\\tthis.sarNum = null;\\n\\t\\tthis.sarDen = null;\\n\\n\\t\\tthis.metadata = null;\\n\\t\\tthis.segments = null;  // MediaInfo[]\\n\\t\\tthis.segmentCount = null;\\n\\t\\tthis.hasKeyframesIndex = null;\\n\\t\\tthis.keyframesIndex = null;\\n\\t}\\n\\n\\tisComplete() {\\n\\t\\tlet audioInfoComplete = (this.hasAudio === false) ||\\n\\t\\t\\t(this.hasAudio === true &&\\n\\t\\t\\t\\tthis.audioCodec != null &&\\n\\t\\t\\t\\tthis.audioSampleRate != null &&\\n\\t\\t\\t\\tthis.audioChannelCount != null);\\n\\n\\t\\tlet videoInfoComplete = (this.hasVideo === false) ||\\n\\t\\t\\t(this.hasVideo === true &&\\n\\t\\t\\t\\tthis.videoCodec != null &&\\n\\t\\t\\t\\tthis.width != null &&\\n\\t\\t\\t\\tthis.height != null &&\\n\\t\\t\\t\\tthis.fps != null &&\\n\\t\\t\\t\\tthis.profile != null &&\\n\\t\\t\\t\\tthis.level != null &&\\n\\t\\t\\t\\tthis.refFrames != null &&\\n\\t\\t\\t\\tthis.chromaFormat != null &&\\n\\t\\t\\t\\tthis.sarNum != null &&\\n\\t\\t\\t\\tthis.sarDen != null);\\n\\n\\t\\t// keyframesIndex may not be present\\n\\t\\treturn this.mimeType != null &&\\n\\t\\t\\tthis.duration != null &&\\n\\t\\t\\tthis.metadata != null &&\\n\\t\\t\\tthis.hasKeyframesIndex != null &&\\n\\t\\t\\taudioInfoComplete &&\\n\\t\\t\\tvideoInfoComplete;\\n\\t}\\n\\n\\tisSeekable() {\\n\\t\\treturn this.hasKeyframesIndex === true;\\n\\t}\\n\\n\\tgetNearestKeyframe(milliseconds) {\\n\\t\\tif (this.keyframesIndex == null) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tlet table = this.keyframesIndex;\\n\\t\\tlet keyframeIdx = this._search(table.times, milliseconds);\\n\\n\\t\\treturn {\\n\\t\\t\\tindex: keyframeIdx,\\n\\t\\t\\tmilliseconds: table.times[keyframeIdx],\\n\\t\\t\\tfileposition: table.filepositions[keyframeIdx]\\n\\t\\t};\\n\\t}\\n\\n\\t_search(list, value) {\\n\\t\\tlet idx = 0;\\n\\n\\t\\tlet last = list.length - 1;\\n\\t\\tlet mid = 0;\\n\\t\\tlet lbound = 0;\\n\\t\\tlet ubound = last;\\n\\n\\t\\tif (value < list[0]) {\\n\\t\\t\\tidx = 0;\\n\\t\\t\\tlbound = ubound + 1;  // skip search\\n\\t\\t}\\n\\n\\t\\twhile (lbound <= ubound) {\\n\\t\\t\\tmid = lbound + Math.floor((ubound - lbound) / 2);\\n\\t\\t\\tif (mid === last || (value >= list[mid] && value < list[mid + 1])) {\\n\\t\\t\\t\\tidx = mid;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else if (list[mid] < value) {\\n\\t\\t\\t\\tlbound = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tubound = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn idx;\\n\\t}\\n\\n}\\n\\n/* harmony default export */ const media_info = (MediaInfo);\\n\\n;// CONCATENATED MODULE: ./src/utils/utf8-conv.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * This file is derived from C++ project libWinTF8 (https://github.com/m13253/libWinTF8)\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nfunction checkContinuation(uint8array, start, checkLength) {\\n    let array = uint8array;\\n    if (start + checkLength < array.length) {\\n        while (checkLength--) {\\n            if ((array[++start] & 0xC0) !== 0x80)\\n                return false;\\n        }\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nfunction decodeUTF8(uint8array) {\\n    let out = [];\\n    let input = uint8array;\\n    let i = 0;\\n    let length = uint8array.length;\\n\\n    while (i < length) {\\n        if (input[i] < 0x80) {\\n            out.push(String.fromCharCode(input[i]));\\n            ++i;\\n            continue;\\n        } else if (input[i] < 0xC0) {\\n            // fallthrough\\n        } else if (input[i] < 0xE0) {\\n            if (checkContinuation(input, i, 1)) {\\n                let ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F);\\n                if (ucs4 >= 0x80) {\\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\\n                    i += 2;\\n                    continue;\\n                }\\n            }\\n        } else if (input[i] < 0xF0) {\\n            if (checkContinuation(input, i, 2)) {\\n                let ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\\n                if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\\n                    i += 3;\\n                    continue;\\n                }\\n            }\\n        } else if (input[i] < 0xF8) {\\n            if (checkContinuation(input, i, 3)) {\\n                let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12\\n                    | (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F);\\n                if (ucs4 > 0x10000 && ucs4 < 0x110000) {\\n                    ucs4 -= 0x10000;\\n                    out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800));\\n                    out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00));\\n                    i += 4;\\n                    continue;\\n                }\\n            }\\n        }\\n        out.push(String.fromCharCode(0xFFFD));\\n        ++i;\\n    }\\n\\n    return out.join('');\\n}\\n\\n;// CONCATENATED MODULE: ./src/flv/amf-parser.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n\\n\\n\\n\\n\\nlet le = (function () {\\n    let buf = new ArrayBuffer(2);\\n    (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\\n    return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\\n})();\\n\\nclass AMF {\\n    static TAG = \\\"AMF\\\";\\n\\n    /**\\n     *\\n     * @param {Uint8Array} array\\n     * @returns {{}}\\n     */\\n    static parseScriptData(array) {\\n        logger.d(this.TAG, array);\\n\\n        let data = {};\\n\\n        try {\\n            let name = AMF.parseValue(array);\\n            logger.d(this.TAG, name);\\n\\n            let value = AMF.parseValue(array.slice(name.size));\\n            logger.d(this.TAG, value);\\n\\n            data[name.data] = value.data;\\n\\n        } catch (e) {\\n            logger.w(this.TAG, e.toString());\\n        }\\n\\n        return data;\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} array\\n     * @returns {{data: {name: string, value: {}}, size: number, objectEnd: boolean}}\\n     */\\n    static parseObject(array) {\\n        if (array.length < 3) {\\n            throw new IllegalStateException('Data not enough when parse ScriptDataObject');\\n        }\\n        let name = AMF.parseString(array);\\n        let value = AMF.parseValue(array.slice(name.size, array.length - name.size));\\n        let isObjectEnd = value.objectEnd;\\n\\n        return {\\n            data: {\\n                name: name.data,\\n                value: value.data\\n            },\\n            size: name.size + value.size,\\n            objectEnd: isObjectEnd\\n        };\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} array\\n     * @returns {{data: {name: string, value: {}}, size: number, objectEnd: boolean}}\\n     */\\n    static parseVariable(array) {\\n        return AMF.parseObject(array);\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} array\\n     * @returns {{data: string, size: number}}\\n     */\\n    static parseString(array) {\\n        if (array.length < 2) {\\n            throw new IllegalStateException('Data not enough when parse String');\\n        }\\n        let v = new DataView(array.buffer);\\n        let length = v.getUint16(0, !le);\\n\\n        let str;\\n        if (length > 0) {\\n            str = decodeUTF8(new Uint8Array(array.slice(2, 2 + length)));\\n        } else {\\n            str = '';\\n        }\\n\\n        return {\\n            data: str,\\n            size: 2 + length\\n        };\\n    }\\n\\n    static parseLongString(array) {\\n        if (array.length() < 4) {\\n            throw new IllegalStateException('Data not enough when parse LongString');\\n        }\\n        let v = new DataView(array.buffer);\\n        let length = v.getUint32(0, !le);\\n\\n        let str;\\n        if (length > 0) {\\n            str = decodeUTF8(new Uint8Array(array.slice(4, 4 +length)));\\n        } else {\\n            str = '';\\n        }\\n\\n        return {\\n            data: str,\\n            size: 4 + length\\n        };\\n    }\\n\\n    static parseDate(array) {\\n        if (array.length() < 10) {\\n            throw new IllegalStateException('Data size invalid when parse Date');\\n        }\\n        let v = new DataView(array.buffer);\\n        let timestamp = v.getFloat64(0, !le);\\n        let localTimeOffset = v.getInt16(8, !le);\\n        timestamp += localTimeOffset * 60 * 1000;  // get UTC time\\n\\n        return {\\n            data: new Date(timestamp),\\n            size: 8 + 2\\n        };\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} array\\n     * @returns {{data: {}, size: number, objectEnd: boolean}}\\n     */\\n    static parseValue(array) {\\n        if (array.length < 1) {\\n            throw new IllegalStateException('Data not enough when parse Value');\\n        }\\n\\n        let v = new DataView(array.buffer);\\n\\n        let offset = 1;\\n        let type = v.getUint8(0);\\n        let value;\\n        let objectEnd = false;\\n\\n        try {\\n            switch (type) {\\n                case 0:  // Number(Double) type\\n                    value = v.getFloat64(1, !le);\\n                    offset += 8;\\n                    break;\\n                case 1: {  // Boolean type\\n                    let b = v.getUint8(1);\\n                    value = b ? true : false;\\n                    offset += 1;\\n                    break;\\n                }\\n                case 2: {  // String type\\n                    let amfstr = AMF.parseString(array.slice(1));\\n                    value = amfstr.data;\\n                    offset += amfstr.size;\\n                    break;\\n                }\\n                case 3: { // Object(s) type\\n                    value = {};\\n                    let terminal = 0;  // workaround for malformed Objects which has missing ScriptDataObjectEnd\\n                    if ((v.getUint32(array.length - 4, !le) & 0x00FFFFFF) === 9) {\\n                        terminal = 3;\\n                    }\\n                    while (offset < array.length - 4) {  // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\\n                        let amfobj = AMF.parseObject(array.slice(offset, offset + array.length - terminal));\\n                        if (amfobj.objectEnd)\\n                            break;\\n                        value[amfobj.data.name] = amfobj.data.value;\\n                        offset += amfobj.size;\\n                    }\\n                    if (offset <= array.length - 3) {\\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\\n                        if (marker === 9) {\\n                            offset += 3;\\n                        }\\n                    }\\n                    break;\\n                }\\n                case 8: { // ECMA array type (Mixed array)\\n                    value = {};\\n                    offset += 4;  // ECMAArrayLength(UI32)\\n                    let terminal = 0;  // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\\n                    if ((v.getUint32(array.length - 4, !le) & 0x00FFFFFF) === 9) {\\n                        terminal = 3;\\n                    }\\n                    while (offset < array.length - 8) {  // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\\n                        let amfvar = AMF.parseVariable(array.slice(offset, offset + array.length - terminal));\\n                        if (amfvar.objectEnd)\\n                            break;\\n                        value[amfvar.data.name] = amfvar.data.value;\\n                        offset += amfvar.size;\\n                    }\\n                    if (offset <= array.length - 3) {\\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\\n                        if (marker === 9) {\\n                            offset += 3;\\n                        }\\n                    }\\n                    break;\\n                }\\n                case 9:  // ScriptDataObjectEnd\\n                    value = undefined;\\n                    offset = 1;\\n                    objectEnd = true;\\n                    break;\\n                case 10: {  // Strict array type\\n                    // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\\n                    value = [];\\n                    let strictArrayLength = v.getUint32(1, !le);\\n                    offset += 4;\\n                    for (let i = 0; i < strictArrayLength; i++) {\\n                        let val = AMF.parseValue(array.slice(offset, array.length));\\n                        value.push(val.data);\\n                        offset += val.size;\\n                    }\\n                    break;\\n                }\\n                case 11: {  // Date type\\n                    let date = AMF.parseDate(array.slice(1));\\n                    value = date.data;\\n                    offset += date.size;\\n                    break;\\n                }\\n                case 12: {  // Long string type\\n                    let amfLongStr = AMF.parseString(array.slice(1));\\n                    value = amfLongStr.data;\\n                    offset += amfLongStr.size;\\n                    break;\\n                }\\n                default:\\n                    // ignore and skip\\n                    offset = array.length;\\n                    logger.w(this.TAG, 'Unsupported AMF value type ' + type);\\n            }\\n        } catch (e) {\\n            logger.e(this.TAG, e.toString());\\n        }\\n\\n        return {\\n            data: value,\\n            size: offset,\\n            objectEnd: objectEnd\\n        };\\n    }\\n}\\n\\n/* harmony default export */ const amf_parser = (AMF);\\n\\n;// CONCATENATED MODULE: ./src/flv/exp-golomb.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// Exponential-Golomb buffer decoder\\n\\n\\nclass ExpGolomb {\\n\\n    constructor(uint8array) {\\n        this.TAG = 'ExpGolomb';\\n\\n        this._buffer = uint8array;\\n        this._buffer_index = 0;\\n        this._total_bytes = uint8array.byteLength;\\n        this._total_bits = uint8array.byteLength * 8;\\n        this._current_word = 0;\\n        this._current_word_bits_left = 0;\\n    }\\n\\n    destroy() {\\n        this._buffer = null;\\n    }\\n\\n    _fillCurrentWord() {\\n        let buffer_bytes_left = this._total_bytes - this._buffer_index;\\n        if (buffer_bytes_left <= 0)\\n            throw new IllegalStateException('ExpGolomb: _fillCurrentWord() but no bytes available');\\n\\n        let bytes_read = Math.min(4, buffer_bytes_left);\\n        let word = new Uint8Array(4);\\n        word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));\\n        this._current_word = new DataView(word.buffer).getUint32(0, false);\\n\\n        this._buffer_index += bytes_read;\\n        this._current_word_bits_left = bytes_read * 8;\\n    }\\n\\n    readBits(bits) {\\n        if (bits > 32)\\n            throw new InvalidArgumentException('ExpGolomb: readBits() bits exceeded max 32bits!');\\n\\n        if (bits <= this._current_word_bits_left) {\\n            let result = this._current_word >>> (32 - bits);\\n            this._current_word <<= bits;\\n            this._current_word_bits_left -= bits;\\n            return result;\\n        }\\n\\n        let result = this._current_word_bits_left ? this._current_word : 0;\\n        result = result >>> (32 - this._current_word_bits_left);\\n        let bits_need_left = bits - this._current_word_bits_left;\\n\\n        this._fillCurrentWord();\\n        let bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);\\n\\n        let result2 = this._current_word >>> (32 - bits_read_next);\\n        this._current_word <<= bits_read_next;\\n        this._current_word_bits_left -= bits_read_next;\\n\\n        result = (result << bits_read_next) | result2;\\n        return result;\\n    }\\n\\n    readBool() {\\n        return this.readBits(1) === 1;\\n    }\\n\\n    readByte() {\\n        return this.readBits(8);\\n    }\\n\\n    _skipLeadingZero() {\\n        let zero_count;\\n        for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {\\n            if (0 !== (this._current_word & (0x80000000 >>> zero_count))) {\\n                this._current_word <<= zero_count;\\n                this._current_word_bits_left -= zero_count;\\n                return zero_count;\\n            }\\n        }\\n        this._fillCurrentWord();\\n        return zero_count + this._skipLeadingZero();\\n    }\\n\\n    readUEG() {  // unsigned exponential golomb\\n        let leading_zeros = this._skipLeadingZero();\\n        return this.readBits(leading_zeros + 1) - 1;\\n    }\\n\\n    readSEG() {  // signed exponential golomb\\n        let value = this.readUEG();\\n        if (value & 0x01) {\\n            return (value + 1) >>> 1;\\n        } else {\\n            return -1 * (value >>> 1);\\n        }\\n    }\\n\\n}\\n\\n/* harmony default export */ const exp_golomb = (ExpGolomb);\\n\\n;// CONCATENATED MODULE: ./src/flv/sps-parser.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n\\n\\n\\n\\nclass SPSParser {\\n    static _ebsp2rbsp(uint8array) {\\n        let src = uint8array;\\n        let src_length = src.byteLength;\\n        let dst = new Uint8Array(src_length);\\n        let dst_idx = 0;\\n\\n        for (let i = 0; i < src_length; i++) {\\n            if (i >= 2) {\\n                // Unescape: Skip 0x03 after 00 00\\n                if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\\n                    continue;\\n                }\\n            }\\n            dst[dst_idx] = src[i];\\n            dst_idx++;\\n        }\\n\\n        return new Uint8Array(dst.buffer, 0, dst_idx);\\n    }\\n\\n    static parseSPS(uint8array) {\\n        let rbsp = SPSParser._ebsp2rbsp(uint8array);\\n        let gb = new exp_golomb(rbsp);\\n\\n        gb.readByte();\\n        let profile_idc = gb.readByte();  // profile_idc\\n        gb.readByte();  // constraint_set_flags[5] + reserved_zero[3]\\n        let level_idc = gb.readByte();  // level_idc\\n        gb.readUEG();  // seq_parameter_set_id\\n\\n        let profile_string = SPSParser.getProfileString(profile_idc);\\n        let level_string = SPSParser.getLevelString(level_idc);\\n        let chroma_format_idc = 1;\\n        let chroma_format = 420;\\n        let chroma_format_table = [0, 420, 422, 444];\\n        let bit_depth = 8;\\n\\n        if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 ||\\n            profile_idc === 244 || profile_idc === 44 || profile_idc === 83 ||\\n            profile_idc === 86 || profile_idc === 118 || profile_idc === 128 ||\\n            profile_idc === 138 || profile_idc === 144) {\\n\\n            chroma_format_idc = gb.readUEG();\\n            if (chroma_format_idc === 3) {\\n                gb.readBits(1);  // separate_colour_plane_flag\\n            }\\n            if (chroma_format_idc <= 3) {\\n                chroma_format = chroma_format_table[chroma_format_idc];\\n            }\\n\\n            bit_depth = gb.readUEG() + 8;  // bit_depth_luma_minus8\\n            gb.readUEG();  // bit_depth_chroma_minus8\\n            gb.readBits(1);  // qpprime_y_zero_transform_bypass_flag\\n            if (gb.readBool()) {  // seq_scaling_matrix_present_flag\\n                let scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12;\\n                for (let i = 0; i < scaling_list_count; i++) {\\n                    if (gb.readBool()) {  // seq_scaling_list_present_flag\\n                        if (i < 6) {\\n                            SPSParser._skipScalingList(gb, 16);\\n                        } else {\\n                            SPSParser._skipScalingList(gb, 64);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        gb.readUEG();  // log2_max_frame_num_minus4\\n        let pic_order_cnt_type = gb.readUEG();\\n        if (pic_order_cnt_type === 0) {\\n            gb.readUEG();  // log2_max_pic_order_cnt_lsb_minus_4\\n        } else if (pic_order_cnt_type === 1) {\\n            gb.readBits(1);  // delta_pic_order_always_zero_flag\\n            gb.readSEG();  // offset_for_non_ref_pic\\n            gb.readSEG();  // offset_for_top_to_bottom_field\\n            let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\\n            for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\\n                gb.readSEG();  // offset_for_ref_frame\\n            }\\n        }\\n        let ref_frames = gb.readUEG();  // max_num_ref_frames\\n        gb.readBits(1);  // gaps_in_frame_num_value_allowed_flag\\n\\n        let pic_width_in_mbs_minus1 = gb.readUEG();\\n        let pic_height_in_map_units_minus1 = gb.readUEG();\\n\\n        let frame_mbs_only_flag = gb.readBits(1);\\n        if (frame_mbs_only_flag === 0) {\\n            gb.readBits(1);  // mb_adaptive_frame_field_flag\\n        }\\n        gb.readBits(1);  // direct_8x8_inference_flag\\n\\n        let frame_crop_left_offset = 0;\\n        let frame_crop_right_offset = 0;\\n        let frame_crop_top_offset = 0;\\n        let frame_crop_bottom_offset = 0;\\n\\n        let frame_cropping_flag = gb.readBool();\\n        if (frame_cropping_flag) {\\n            frame_crop_left_offset = gb.readUEG();\\n            frame_crop_right_offset = gb.readUEG();\\n            frame_crop_top_offset = gb.readUEG();\\n            frame_crop_bottom_offset = gb.readUEG();\\n        }\\n\\n        let sar_width = 1, sar_height = 1;\\n        let fps = 0, fps_fixed = true, fps_num = 0, fps_den = 0;\\n\\n        let vui_parameters_present_flag = gb.readBool();\\n        if (vui_parameters_present_flag) {\\n            if (gb.readBool()) {  // aspect_ratio_info_present_flag\\n                let aspect_ratio_idc = gb.readByte();\\n                let sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\\n                let sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33,  99, 3, 2, 1];\\n\\n                if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\\n                    sar_width = sar_w_table[aspect_ratio_idc - 1];\\n                    sar_height = sar_h_table[aspect_ratio_idc - 1];\\n                } else if (aspect_ratio_idc === 255) {\\n                    sar_width = gb.readByte() << 8 | gb.readByte();\\n                    sar_height = gb.readByte() << 8 | gb.readByte();\\n                }\\n            }\\n\\n            if (gb.readBool()) {  // overscan_info_present_flag\\n                gb.readBool();  // overscan_appropriate_flag\\n            }\\n            if (gb.readBool()) {  // video_signal_type_present_flag\\n                gb.readBits(4);  // video_format & video_full_range_flag\\n                if (gb.readBool()) {  // colour_description_present_flag\\n                    gb.readBits(24);  // colour_primaries & transfer_characteristics & matrix_coefficients\\n                }\\n            }\\n            if (gb.readBool()) {  // chroma_loc_info_present_flag\\n                gb.readUEG();  // chroma_sample_loc_type_top_field\\n                gb.readUEG();  // chroma_sample_loc_type_bottom_field\\n            }\\n            if (gb.readBool()) {  // timing_info_present_flag\\n                let num_units_in_tick = gb.readBits(32);\\n                let time_scale = gb.readBits(32);\\n                fps_fixed = gb.readBool();  // fixed_frame_rate_flag\\n\\n                fps_num = time_scale;\\n                fps_den = num_units_in_tick * 2;\\n                fps = fps_num / fps_den;\\n            }\\n        }\\n\\n        let sarScale = 1;\\n        if (sar_width !== 1 || sar_height !== 1) {\\n            sarScale = sar_width / sar_height;\\n        }\\n\\n        let crop_unit_x = 0, crop_unit_y = 0;\\n        if (chroma_format_idc === 0) {\\n            crop_unit_x = 1;\\n            crop_unit_y = 2 - frame_mbs_only_flag;\\n        } else {\\n            let sub_wc = (chroma_format_idc === 3) ? 1 : 2;\\n            let sub_hc = (chroma_format_idc === 1) ? 2 : 1;\\n            crop_unit_x = sub_wc;\\n            crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\\n        }\\n\\n        let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\\n        let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\\n\\n        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\\n        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\\n\\n        let present_width = Math.ceil(codec_width * sarScale);\\n\\n        gb.destroy();\\n        gb = null;\\n\\n        return {\\n            profile_string: profile_string,  // baseline, high, high10, ...\\n            level_string: level_string,  // 3, 3.1, 4, 4.1, 5, 5.1, ...\\n            bit_depth: bit_depth,  // 8bit, 10bit, ...\\n            ref_frames: ref_frames,\\n            chroma_format: chroma_format,  // 4:2:0, 4:2:2, ...\\n            chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\\n\\n            frame_rate: {\\n                fixed: fps_fixed,\\n                fps: fps,\\n                fps_den: fps_den,\\n                fps_num: fps_num\\n            },\\n\\n            sar_ratio: {\\n                width: sar_width,\\n                height: sar_height\\n            },\\n\\n            codec_size: {\\n                width: codec_width,\\n                height: codec_height\\n            },\\n\\n            present_size: {\\n                width: present_width,\\n                height: codec_height\\n            }\\n        };\\n    }\\n\\n    static _skipScalingList(gb, count) {\\n        let last_scale = 8, next_scale = 8;\\n        let delta_scale = 0;\\n        for (let i = 0; i < count; i++) {\\n            if (next_scale !== 0) {\\n                delta_scale = gb.readSEG();\\n                next_scale = (last_scale + delta_scale + 256) % 256;\\n            }\\n            last_scale = (next_scale === 0) ? last_scale : next_scale;\\n        }\\n    }\\n\\n    static getProfileString(profile_idc) {\\n        switch (profile_idc) {\\n            case 66:\\n                return 'Baseline';\\n            case 77:\\n                return 'Main';\\n            case 88:\\n                return 'Extended';\\n            case 100:\\n                return 'High';\\n            case 110:\\n                return 'High10';\\n            case 122:\\n                return 'High422';\\n            case 244:\\n                return 'High444';\\n            default:\\n                return 'Unknown';\\n        }\\n    }\\n\\n    static getLevelString(level_idc) {\\n        return (level_idc / 10).toFixed(1);\\n    }\\n\\n    static getChromaFormatString(chroma) {\\n        switch (chroma) {\\n            case 420:\\n                return '4:2:0';\\n            case 422:\\n                return '4:2:2';\\n            case 444:\\n                return '4:4:4';\\n            default:\\n                return 'Unknown';\\n        }\\n    }\\n\\n}\\n\\n/* harmony default export */ const sps_parser = (SPSParser);\\n\\n;// CONCATENATED MODULE: ./src/formats/mp4.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * This file is derived from dailymotion's hls.js library (hls.js/src/remux/mp4-generator.js)\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n//  MP4 boxes generator for ISO BMFF (ISO Base Media File Format, defined in ISO/IEC 14496-12)\\nclass MP4 {\\n    static init() {\\n        MP4.types = {\\n            avc1: [], avcC: [], btrt: [], dinf: [],\\n            dref: [], esds: [], ftyp: [], hdlr: [],\\n            mdat: [], mdhd: [], mdia: [], mfhd: [],\\n            minf: [], moof: [], moov: [], mp4a: [],\\n            mvex: [], mvhd: [], sdtp: [], stbl: [],\\n            stco: [], stsc: [], stsd: [], stsz: [],\\n            stts: [], tfdt: [], tfhd: [], traf: [],\\n            trak: [], trun: [], trex: [], tkhd: [],\\n            vmhd: [], smhd: [], '.mp3': []\\n        };\\n\\n        for (let name in MP4.types) {\\n            if (MP4.types.hasOwnProperty(name)) {\\n                MP4.types[name] = [\\n                    name.charCodeAt(0),\\n                    name.charCodeAt(1),\\n                    name.charCodeAt(2),\\n                    name.charCodeAt(3)\\n                ];\\n            }\\n        }\\n\\n        let constants = MP4.constants = {};\\n\\n        constants.FTYP = new Uint8Array([\\n            0x69, 0x73, 0x6F, 0x6D,  // major_brand: isom\\n            0x0,  0x0,  0x0,  0x1,   // minor_version: 0x01\\n            0x69, 0x73, 0x6F, 0x6D,  // isom\\n            0x61, 0x76, 0x63, 0x31   // avc1\\n        ]);\\n\\n        constants.STSD_PREFIX = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x01   // entry_count\\n        ]);\\n\\n        constants.STTS = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00   // entry_count\\n        ]);\\n\\n        constants.STSC = constants.STCO = constants.STTS;\\n\\n        constants.STSZ = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00,  // sample_size\\n            0x00, 0x00, 0x00, 0x00   // sample_count\\n        ]);\\n\\n        constants.HDLR_VIDEO = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00,  // pre_defined\\n            0x76, 0x69, 0x64, 0x65,  // handler_type: 'vide'\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 3 * 4 bytes\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x56, 0x69, 0x64, 0x65,\\n            0x6F, 0x48, 0x61, 0x6E,\\n            0x64, 0x6C, 0x65, 0x72, 0x00  // name: VideoHandler\\n        ]);\\n\\n        constants.HDLR_AUDIO = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00,  // pre_defined\\n            0x73, 0x6F, 0x75, 0x6E,  // handler_type: 'soun'\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 3 * 4 bytes\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x53, 0x6F, 0x75, 0x6E,\\n            0x64, 0x48, 0x61, 0x6E,\\n            0x64, 0x6C, 0x65, 0x72, 0x00  // name: SoundHandler\\n        ]);\\n\\n        constants.DREF = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x01,  // entry_count\\n            0x00, 0x00, 0x00, 0x0C,  // entry_size\\n            0x75, 0x72, 0x6C, 0x20,  // type 'url '\\n            0x00, 0x00, 0x00, 0x01   // version(0) + flags\\n        ]);\\n\\n        // Sound media header\\n        constants.SMHD = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00   // balance(2) + reserved(2)\\n        ]);\\n\\n        // video media header\\n        constants.VMHD = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x01,  // version(0) + flags\\n            0x00, 0x00,              // graphicsmode: 2 bytes\\n            0x00, 0x00, 0x00, 0x00,  // opcolor: 3 * 2 bytes\\n            0x00, 0x00\\n        ]);\\n    }\\n\\n    // Generate a box\\n    static box(type) {\\n        let size = 8;\\n        let result;\\n        let datas = Array.prototype.slice.call(arguments, 1);\\n        let arrayCount = datas.length;\\n\\n        for (let i = 0; i < arrayCount; i++) {\\n            size += datas[i].byteLength;\\n        }\\n\\n        result = new Uint8Array(size);\\n        result[0] = (size >>> 24) & 0xFF;  // size\\n        result[1] = (size >>> 16) & 0xFF;\\n        result[2] = (size >>>  8) & 0xFF;\\n        result[3] = (size) & 0xFF;\\n\\n        result.set(type, 4);  // type\\n\\n        let offset = 8;\\n        for (let i = 0; i < arrayCount; i++) {  // data body\\n            result.set(datas[i], offset);\\n            offset += datas[i].byteLength;\\n        }\\n\\n        return result;\\n    }\\n\\n    // emit ftyp & moov\\n    static generateInitSegment(meta) {\\n        let ftyp = MP4.box(MP4.types.ftyp, MP4.constants.FTYP);\\n        let moov = MP4.moov(meta);\\n\\n        let result = new Uint8Array(ftyp.byteLength + moov.byteLength);\\n        result.set(ftyp, 0);\\n        result.set(moov, ftyp.byteLength);\\n        return result;\\n    }\\n\\n    // Movie metadata box\\n    static moov(meta) {\\n        let mvhd = MP4.mvhd(meta.timescale, meta.duration);\\n        let trak = MP4.trak(meta);\\n        let mvex = MP4.mvex(meta);\\n        return MP4.box(MP4.types.moov, mvhd, trak, mvex);\\n    }\\n\\n    // Movie header box\\n    static mvhd(timescale, duration) {\\n        return MP4.box(MP4.types.mvhd, new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00,  // creation_time\\n            0x00, 0x00, 0x00, 0x00,  // modification_time\\n            (timescale >>> 24) & 0xFF,  // timescale: 4 bytes\\n            (timescale >>> 16) & 0xFF,\\n            (timescale >>>  8) & 0xFF,\\n            (timescale) & 0xFF,\\n            (duration >>> 24) & 0xFF,   // duration: 4 bytes\\n            (duration >>> 16) & 0xFF,\\n            (duration >>>  8) & 0xFF,\\n            (duration) & 0xFF,\\n            0x00, 0x01, 0x00, 0x00,  // Preferred rate: 1.0\\n            0x01, 0x00, 0x00, 0x00,  // PreferredVolume(1.0, 2bytes) + reserved(2bytes)\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 4 + 4 bytes\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x01, 0x00, 0x00,  // ----begin composition matrix----\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x01, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x40, 0x00, 0x00, 0x00,  // ----end composition matrix----\\n            0x00, 0x00, 0x00, 0x00,  // ----begin pre_defined 6 * 4 bytes----\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,  // ----end pre_defined 6 * 4 bytes----\\n            0xFF, 0xFF, 0xFF, 0xFF   // next_track_ID\\n        ]));\\n    }\\n\\n    // Track box\\n    static trak(meta) {\\n        return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));\\n    }\\n\\n    // Track header box\\n    static tkhd(meta) {\\n        let trackId = meta.id, duration = meta.duration;\\n        let width = meta.presentWidth, height = meta.presentHeight;\\n\\n        return MP4.box(MP4.types.tkhd, new Uint8Array([\\n            0x00, 0x00, 0x00, 0x07,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00,  // creation_time\\n            0x00, 0x00, 0x00, 0x00,  // modification_time\\n            (trackId >>> 24) & 0xFF,  // track_ID: 4 bytes\\n            (trackId >>> 16) & 0xFF,\\n            (trackId >>>  8) & 0xFF,\\n            (trackId) & 0xFF,\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 4 bytes\\n            (duration >>> 24) & 0xFF, // duration: 4 bytes\\n            (duration >>> 16) & 0xFF,\\n            (duration >>>  8) & 0xFF,\\n            (duration) & 0xFF,\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 2 * 4 bytes\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,  // layer(2bytes) + alternate_group(2bytes)\\n            0x00, 0x00, 0x00, 0x00,  // volume(2bytes) + reserved(2bytes)\\n            0x00, 0x01, 0x00, 0x00,  // ----begin composition matrix----\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x01, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x40, 0x00, 0x00, 0x00,  // ----end composition matrix----\\n            (width >>> 8) & 0xFF,    // width and height\\n            (width) & 0xFF,\\n            0x00, 0x00,\\n            (height >>> 8) & 0xFF,\\n            (height) & 0xFF,\\n            0x00, 0x00\\n        ]));\\n    }\\n\\n    // Media Box\\n    static mdia(meta) {\\n        return MP4.box(MP4.types.mdia, MP4.mdhd(meta), MP4.hdlr(meta), MP4.minf(meta));\\n    }\\n\\n    // Media header box\\n    static mdhd(meta) {\\n        let timescale = meta.timescale;\\n        let duration = meta.duration;\\n        return MP4.box(MP4.types.mdhd, new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            0x00, 0x00, 0x00, 0x00,  // creation_time\\n            0x00, 0x00, 0x00, 0x00,  // modification_time\\n            (timescale >>> 24) & 0xFF,  // timescale: 4 bytes\\n            (timescale >>> 16) & 0xFF,\\n            (timescale >>>  8) & 0xFF,\\n            (timescale) & 0xFF,\\n            (duration >>> 24) & 0xFF,   // duration: 4 bytes\\n            (duration >>> 16) & 0xFF,\\n            (duration >>>  8) & 0xFF,\\n            (duration) & 0xFF,\\n            0x55, 0xC4,             // language: und (undetermined)\\n            0x00, 0x00              // pre_defined = 0\\n        ]));\\n    }\\n\\n    // Media handler reference box\\n    static hdlr(meta) {\\n        let data;\\n        if (meta.type === 'audio') {\\n            data = MP4.constants.HDLR_AUDIO;\\n        } else {\\n            data = MP4.constants.HDLR_VIDEO;\\n        }\\n        return MP4.box(MP4.types.hdlr, data);\\n    }\\n\\n    // Media infomation box\\n    static minf(meta) {\\n        let xmhd;\\n        if (meta.type === 'audio') {\\n            xmhd = MP4.box(MP4.types.smhd, MP4.constants.SMHD);\\n        } else {\\n            xmhd = MP4.box(MP4.types.vmhd, MP4.constants.VMHD);\\n        }\\n        return MP4.box(MP4.types.minf, xmhd, MP4.dinf(), MP4.stbl(meta));\\n    }\\n\\n    // Data infomation box\\n    static dinf() {\\n        return MP4.box(MP4.types.dinf,\\n            MP4.box(MP4.types.dref, MP4.constants.DREF)\\n        );\\n    }\\n\\n    // Sample table box\\n    static stbl(meta) {\\n        return MP4.box(MP4.types.stbl,  // type: stbl\\n            MP4.stsd(meta),  // Sample Description Table\\n            MP4.box(MP4.types.stts, MP4.constants.STTS),  // Time-To-Sample\\n            MP4.box(MP4.types.stsc, MP4.constants.STSC),  // Sample-To-Chunk\\n            MP4.box(MP4.types.stsz, MP4.constants.STSZ),  // Sample size\\n            MP4.box(MP4.types.stco, MP4.constants.STCO)   // Chunk offset\\n        );\\n    }\\n\\n    // Sample description box\\n    static stsd(meta) {\\n        if (meta.type === 'audio') {\\n            if (meta.codec === 'mp3') {\\n                return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp3(meta));\\n            }\\n            // else: aac -> mp4a\\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp4a(meta));\\n        } else {\\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.avc1(meta));\\n        }\\n    }\\n\\n    static mp3(meta) {\\n        let channelCount = meta.channelCount;\\n        let sampleRate = meta.audioSampleRate;\\n\\n        let data = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\\n            0x00, 0x00, 0x00, 0x01,  // reserved(2) + data_reference_index(2)\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 2 * 4 bytes\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, channelCount,      // channelCount(2)\\n            0x00, 0x10,              // sampleSize(2)\\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\\n            (sampleRate >>> 8) & 0xFF,  // Audio sample rate\\n            (sampleRate) & 0xFF,\\n            0x00, 0x00\\n        ]);\\n\\n        return MP4.box(MP4.types['.mp3'], data);\\n    }\\n\\n    static mp4a(meta) {\\n        let channelCount = meta.channelCount;\\n        let sampleRate = meta.audioSampleRate;\\n\\n        let data = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\\n            0x00, 0x00, 0x00, 0x01,  // reserved(2) + data_reference_index(2)\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 2 * 4 bytes\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, channelCount,      // channelCount(2)\\n            0x00, 0x10,              // sampleSize(2)\\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\\n            (sampleRate >>> 8) & 0xFF,  // Audio sample rate\\n            (sampleRate) & 0xFF,\\n            0x00, 0x00\\n        ]);\\n\\n        return MP4.box(MP4.types.mp4a, data, MP4.esds(meta));\\n    }\\n\\n    static esds(meta) {\\n        let config = meta.config || [];\\n        let configSize = config.length;\\n        let data = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version 0 + flags\\n\\n            0x03,                    // descriptor_type\\n            0x17 + configSize,       // length3\\n            0x00, 0x01,              // es_id\\n            0x00,                    // stream_priority\\n\\n            0x04,                    // descriptor_type\\n            0x0F + configSize,       // length\\n            0x40,                    // codec: mpeg4_audio\\n            0x15,                    // stream_type: Audio\\n            0x00, 0x00, 0x00,        // buffer_size\\n            0x00, 0x00, 0x00, 0x00,  // maxBitrate\\n            0x00, 0x00, 0x00, 0x00,  // avgBitrate\\n\\n            0x05                     // descriptor_type\\n        ].concat([\\n            configSize\\n        ]).concat(\\n            config\\n        ).concat([\\n            0x06, 0x01, 0x02         // GASpecificConfig\\n        ]));\\n        return MP4.box(MP4.types.esds, data);\\n    }\\n\\n    static avc1(meta) {\\n        let avcc = meta.avcc;\\n        let width = meta.codecWidth, height = meta.codecHeight;\\n\\n        let data = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\\n            0x00, 0x00, 0x00, 0x01,  // reserved(2) + data_reference_index(2)\\n            0x00, 0x00, 0x00, 0x00,  // pre_defined(2) + reserved(2)\\n            0x00, 0x00, 0x00, 0x00,  // pre_defined: 3 * 4 bytes\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            (width >>> 8) & 0xFF,    // width: 2 bytes\\n            (width) & 0xFF,\\n            (height >>> 8) & 0xFF,   // height: 2 bytes\\n            (height) & 0xFF,\\n            0x00, 0x48, 0x00, 0x00,  // horizresolution: 4 bytes\\n            0x00, 0x48, 0x00, 0x00,  // vertresolution: 4 bytes\\n            0x00, 0x00, 0x00, 0x00,  // reserved: 4 bytes\\n            0x00, 0x01,              // frame_count\\n            0x0A,                    // strlen\\n            0x78, 0x71, 0x71, 0x2F,  // compressorname: 32 bytes\\n            0x66, 0x6C, 0x76, 0x2E,\\n            0x6A, 0x73, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00, 0x00,\\n            0x00, 0x00, 0x00,\\n            0x00, 0x18,              // depth\\n            0xFF, 0xFF               // pre_defined = -1\\n        ]);\\n        return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));\\n    }\\n\\n    // Movie Extends box\\n    static mvex(meta) {\\n        return MP4.box(MP4.types.mvex, MP4.trex(meta));\\n    }\\n\\n    // Track Extends box\\n    static trex(meta) {\\n        let trackId = meta.id;\\n        let data = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\\n            (trackId >>> 24) & 0xFF, // track_ID\\n            (trackId >>> 16) & 0xFF,\\n            (trackId >>>  8) & 0xFF,\\n            (trackId) & 0xFF,\\n            0x00, 0x00, 0x00, 0x01,  // default_sample_description_index\\n            0x00, 0x00, 0x00, 0x00,  // default_sample_duration\\n            0x00, 0x00, 0x00, 0x00,  // default_sample_size\\n            0x00, 0x01, 0x00, 0x01   // default_sample_flags\\n        ]);\\n        return MP4.box(MP4.types.trex, data);\\n    }\\n\\n    // Movie fragment box\\n    static moof(track, baseMediaDecodeTime) {\\n        return MP4.box(MP4.types.moof, MP4.mfhd(track.sequenceNumber), MP4.traf(track, baseMediaDecodeTime));\\n    }\\n\\n    static mfhd(sequenceNumber) {\\n        let data = new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,\\n            (sequenceNumber >>> 24) & 0xFF,  // sequence_number: int32\\n            (sequenceNumber >>> 16) & 0xFF,\\n            (sequenceNumber >>>  8) & 0xFF,\\n            (sequenceNumber) & 0xFF\\n        ]);\\n        return MP4.box(MP4.types.mfhd, data);\\n    }\\n\\n    // Track fragment box\\n    static traf(track, baseMediaDecodeTime) {\\n        let trackId = track.id;\\n\\n        // Track fragment header box\\n        let tfhd = MP4.box(MP4.types.tfhd, new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) & flags\\n            (trackId >>> 24) & 0xFF, // track_ID\\n            (trackId >>> 16) & 0xFF,\\n            (trackId >>>  8) & 0xFF,\\n            (trackId) & 0xFF\\n        ]));\\n        // Track Fragment Decode Time\\n        let tfdt = MP4.box(MP4.types.tfdt, new Uint8Array([\\n            0x00, 0x00, 0x00, 0x00,  // version(0) & flags\\n            (baseMediaDecodeTime >>> 24) & 0xFF,  // baseMediaDecodeTime: int32\\n            (baseMediaDecodeTime >>> 16) & 0xFF,\\n            (baseMediaDecodeTime >>>  8) & 0xFF,\\n            (baseMediaDecodeTime) & 0xFF\\n        ]));\\n        let sdtp = MP4.sdtp(track);\\n        let trun = MP4.trun(track, sdtp.byteLength + 16 + 16 + 8 + 16 + 8 + 8);\\n\\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun, sdtp);\\n    }\\n\\n    // Sample Dependency Type box\\n    static sdtp(track) {\\n        let samples = track.samples || [];\\n        let sampleCount = samples.length;\\n        let data = new Uint8Array(4 + sampleCount);\\n        // 0~4 bytes: version(0) & flags\\n        for (let i = 0; i < sampleCount; i++) {\\n            let flags = samples[i].flags;\\n            data[i + 4] = (flags.isLeading << 6)    // is_leading: 2 (bit)\\n                | (flags.dependsOn << 4)    // sample_depends_on\\n                | (flags.isDependedOn << 2) // sample_is_depended_on\\n                | (flags.hasRedundancy);    // sample_has_redundancy\\n        }\\n        return MP4.box(MP4.types.sdtp, data);\\n    }\\n\\n    // Track fragment run box\\n    static trun(track, offset) {\\n        let samples = track.samples || [];\\n        let sampleCount = samples.length;\\n        let dataSize = 12 + 16 * sampleCount;\\n        let data = new Uint8Array(dataSize);\\n        offset += 8 + dataSize;\\n\\n        data.set([\\n            0x00, 0x00, 0x0F, 0x01,      // version(0) & flags\\n            (sampleCount >>> 24) & 0xFF, // sample_count\\n            (sampleCount >>> 16) & 0xFF,\\n            (sampleCount >>>  8) & 0xFF,\\n            (sampleCount) & 0xFF,\\n            (offset >>> 24) & 0xFF,      // data_offset\\n            (offset >>> 16) & 0xFF,\\n            (offset >>>  8) & 0xFF,\\n            (offset) & 0xFF\\n        ], 0);\\n\\n        for (let i = 0; i < sampleCount; i++) {\\n            let duration = samples[i].duration;\\n            let size = samples[i].size;\\n            let flags = samples[i].flags;\\n            let cts = samples[i].cts;\\n            data.set([\\n                (duration >>> 24) & 0xFF,  // sample_duration\\n                (duration >>> 16) & 0xFF,\\n                (duration >>>  8) & 0xFF,\\n                (duration) & 0xFF,\\n                (size >>> 24) & 0xFF,      // sample_size\\n                (size >>> 16) & 0xFF,\\n                (size >>>  8) & 0xFF,\\n                (size) & 0xFF,\\n                (flags.isLeading << 2) | flags.dependsOn,  // sample_flags\\n                (flags.isDependedOn << 6) | (flags.hasRedundancy << 4) | flags.isNonSync,\\n                0x00, 0x00,                // sample_degradation_priority\\n                (cts >>> 24) & 0xFF,       // sample_composition_time_offset\\n                (cts >>> 16) & 0xFF,\\n                (cts >>>  8) & 0xFF,\\n                (cts) & 0xFF\\n            ], 12 + 16 * i);\\n        }\\n        return MP4.box(MP4.types.trun, data);\\n    }\\n\\n    static mdat(data) {\\n        return MP4.box(MP4.types.mdat, data);\\n    }\\n\\n}\\n\\nMP4.init();\\n\\n/* harmony default export */ const mp4 = (MP4);\\n\\n;// CONCATENATED MODULE: ./src/formats/media-segment-info.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// Represents an media sample (audio / video)\\nclass SampleInfo {\\n\\n\\tconstructor(dts, pts, duration, originalDts, isSync) {\\n\\t\\tthis.dts = dts;\\n\\t\\tthis.pts = pts;\\n\\t\\tthis.duration = duration;\\n\\t\\tthis.originalDts = originalDts;\\n\\t\\tthis.isSyncPoint = isSync;\\n\\t\\tthis.fileposition = null;\\n\\t}\\n\\n}\\n\\n// Media Segment concept is defined in Media Source Extensions spec.\\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\\nclass MediaSegmentInfo {\\n\\n\\tconstructor() {\\n\\t\\tthis.beginDts = 0;\\n\\t\\tthis.endDts = 0;\\n\\t\\tthis.beginPts = 0;\\n\\t\\tthis.endPts = 0;\\n\\t\\tthis.originalBeginDts = 0;\\n\\t\\tthis.originalEndDts = 0;\\n\\t\\tthis.syncPoints = [];     // SampleInfo[n], for video IDR frames only\\n\\t\\tthis.firstSample = null;  // SampleInfo\\n\\t\\tthis.lastSample = null;   // SampleInfo\\n\\t}\\n\\n\\tappendSyncPoint(sampleInfo) {  // also called Random Access Point\\n\\t\\tsampleInfo.isSyncPoint = true;\\n\\t\\tthis.syncPoints.push(sampleInfo);\\n\\t}\\n\\n}\\n\\n// Ordered list for recording video IDR frames, sorted by originalDts\\nclass IDRSampleList {\\n\\n\\tconstructor() {\\n\\t\\tthis._list = [];\\n\\t}\\n\\n\\tclear() {\\n\\t\\tthis._list = [];\\n\\t}\\n\\n\\tappendArray(syncPoints) {\\n\\t\\tlet list = this._list;\\n\\n\\t\\tif (syncPoints.length === 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\\n\\t\\t\\tthis.clear();\\n\\t\\t}\\n\\n\\t\\tArray.prototype.push.apply(list, syncPoints);\\n\\t}\\n\\n\\tgetLastSyncPointBeforeDts(dts) {\\n\\t\\tif (this._list.length === 0) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tlet list = this._list;\\n\\t\\tlet idx = 0;\\n\\t\\tlet last = list.length - 1;\\n\\t\\tlet mid = 0;\\n\\t\\tlet lbound = 0;\\n\\t\\tlet ubound = last;\\n\\n\\t\\tif (dts < list[0].dts) {\\n\\t\\t\\tidx = 0;\\n\\t\\t\\tlbound = ubound + 1;\\n\\t\\t}\\n\\n\\t\\twhile (lbound <= ubound) {\\n\\t\\t\\tmid = lbound + Math.floor((ubound - lbound) / 2);\\n\\t\\t\\tif (mid === last || (dts >= list[mid].dts && dts < list[mid + 1].dts)) {\\n\\t\\t\\t\\tidx = mid;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else if (list[mid].dts < dts) {\\n\\t\\t\\t\\tlbound = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tubound = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn this._list[idx];\\n\\t}\\n\\n}\\n\\n// Data structure for recording information of media segments in single track.\\nclass MediaSegmentInfoList {\\n\\n\\tconstructor(type) {\\n\\t\\tthis._type = type;\\n\\t\\tthis._list = [];\\n\\t\\tthis._lastAppendLocation = -1;  // cached last insert location\\n\\t}\\n\\n\\tget type() {\\n\\t\\treturn this._type;\\n\\t}\\n\\n\\tget length() {\\n\\t\\treturn this._list.length;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\treturn this._list.length === 0;\\n\\t}\\n\\n\\tclear() {\\n\\t\\tthis._list = [];\\n\\t\\tthis._lastAppendLocation = -1;\\n\\t}\\n\\n\\t_searchNearestSegmentBefore(originalBeginDts) {\\n\\t\\tlet list = this._list;\\n\\t\\tif (list.length === 0) {\\n\\t\\t\\treturn -2;\\n\\t\\t}\\n\\t\\tlet last = list.length - 1;\\n\\t\\tlet mid = 0;\\n\\t\\tlet lbound = 0;\\n\\t\\tlet ubound = last;\\n\\n\\t\\tlet idx = 0;\\n\\n\\t\\tif (originalBeginDts < list[0].originalBeginDts) {\\n\\t\\t\\tidx = -1;\\n\\t\\t\\treturn idx;\\n\\t\\t}\\n\\n\\t\\twhile (lbound <= ubound) {\\n\\t\\t\\tmid = lbound + Math.floor((ubound - lbound) / 2);\\n\\t\\t\\tif (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\\n\\t\\t\\t\\t(originalBeginDts < list[mid + 1].originalBeginDts))) {\\n\\t\\t\\t\\tidx = mid;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else if (list[mid].originalBeginDts < originalBeginDts) {\\n\\t\\t\\t\\tlbound = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tubound = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn idx;\\n\\t}\\n\\n\\t_searchNearestSegmentAfter(originalBeginDts) {\\n\\t\\treturn this._searchNearestSegmentBefore(originalBeginDts) + 1;\\n\\t}\\n\\n\\tappend(mediaSegmentInfo) {\\n\\t\\tlet list = this._list;\\n\\t\\tlet msi = mediaSegmentInfo;\\n\\t\\tlet lastAppendIdx = this._lastAppendLocation;\\n\\t\\tlet insertIdx = 0;\\n\\n\\t\\tif (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\\n\\t\\t\\tmsi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\\n\\t\\t\\t((lastAppendIdx === list.length - 1) ||\\n\\t\\t\\t\\t(lastAppendIdx < list.length - 1 &&\\n\\t\\t\\t\\t\\tmsi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\\n\\t\\t\\tinsertIdx = lastAppendIdx + 1;  // use cached location idx\\n\\t\\t} else {\\n\\t\\t\\tif (list.length > 0) {\\n\\t\\t\\t\\tinsertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis._lastAppendLocation = insertIdx;\\n\\t\\tthis._list.splice(insertIdx, 0, msi);\\n\\t}\\n\\n\\tgetLastSegmentBefore(originalBeginDts) {\\n\\t\\tlet idx = this._searchNearestSegmentBefore(originalBeginDts);\\n\\t\\tif (idx >= 0) {\\n\\t\\t\\treturn this._list[idx];\\n\\t\\t} else {  // -1\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\tgetLastSampleBefore(originalBeginDts) {\\n\\t\\tlet segment = this.getLastSegmentBefore(originalBeginDts);\\n\\t\\tif (segment != null) {\\n\\t\\t\\treturn segment.lastSample;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\tgetLastSyncPointBefore(originalBeginDts) {\\n\\t\\tlet segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\\n\\t\\tlet syncPoints = this._list[segmentIdx].syncPoints;\\n\\t\\twhile (syncPoints.length === 0 && segmentIdx > 0) {\\n\\t\\t\\tsegmentIdx--;\\n\\t\\t\\tsyncPoints = this._list[segmentIdx].syncPoints;\\n\\t\\t}\\n\\t\\tif (syncPoints.length > 0) {\\n\\t\\t\\treturn syncPoints[syncPoints.length - 1];\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n}\\n\\n;// CONCATENATED MODULE: ./src/formats/aac-silent.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * This file is modified from dailymotion's hls.js library (hls.js/src/helper/aac.js)\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nclass AAC {\\n\\tstatic getSilentFrame(codec, channelCount) {\\n\\t\\tif (codec === 'mp4a.40.2') {\\n\\t\\t\\t// handle LC-AAC\\n\\t\\t\\tif (channelCount === 1) {\\n\\t\\t\\t\\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\\n\\t\\t\\t} else if (channelCount === 2) {\\n\\t\\t\\t\\treturn new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\\n\\t\\t\\t} else if (channelCount === 3) {\\n\\t\\t\\t\\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\\n\\t\\t\\t} else if (channelCount === 4) {\\n\\t\\t\\t\\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\\n\\t\\t\\t} else if (channelCount === 5) {\\n\\t\\t\\t\\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\\n\\t\\t\\t} else if (channelCount === 6) {\\n\\t\\t\\t\\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// handle HE-AAC (mp4a.40.5 / mp4a.40.29)\\n\\t\\t\\tif (channelCount === 1) {\\n\\t\\t\\t\\t// ffmpeg -y -f lavfi -i \\\"aevalsrc=0:d=0.05\\\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \\\"0x%x,\\\" \\\"\\\\n\\\"' -v output.aac\\n\\t\\t\\t\\treturn new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\\n\\t\\t\\t} else if (channelCount === 2) {\\n\\t\\t\\t\\t// ffmpeg -y -f lavfi -i \\\"aevalsrc=0|0:d=0.05\\\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \\\"0x%x,\\\" \\\"\\\\n\\\"' -v output.aac\\n\\t\\t\\t\\treturn new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\\n\\t\\t\\t} else if (channelCount === 3) {\\n\\t\\t\\t\\t// ffmpeg -y -f lavfi -i \\\"aevalsrc=0|0|0:d=0.05\\\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \\\"0x%x,\\\" \\\"\\\\n\\\"' -v output.aac\\n\\t\\t\\t\\treturn new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t}\\n\\n}\\n\\n/* harmony default export */ const aac_silent = (AAC);\\n\\n;// CONCATENATED MODULE: ./src/utils/browser.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nlet Browser = {};\\n\\nfunction detect() {\\n\\t// modified from jquery-browser-plugin\\n\\n\\tlet ua = self.navigator.userAgent.toLowerCase();\\n\\n\\tlet match = /(edge)\\\\/([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(opr)[\\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(chrome)[ \\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(iemobile)[\\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(version)(applewebkit)[ \\\\/]([\\\\w.]+).*(safari)[ \\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(webkit)[ \\\\/]([\\\\w.]+).*(version)[ \\\\/]([\\\\w.]+).*(safari)[ \\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(webkit)[ \\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(opera)(?:.*version|)[ \\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t/(msie) ([\\\\w.]+)/.exec(ua) ||\\n\\t\\tua.indexOf('trident') >= 0 && /(rv)(?::| )([\\\\w.]+)/.exec(ua) ||\\n\\t\\tua.indexOf('compatible') < 0 && /(firefox)[ \\\\/]([\\\\w.]+)/.exec(ua) ||\\n\\t\\t[];\\n\\n\\tlet platform_match = /(ipad)/.exec(ua) ||\\n\\t\\t/(ipod)/.exec(ua) ||\\n\\t\\t/(windows phone)/.exec(ua) ||\\n\\t\\t/(iphone)/.exec(ua) ||\\n\\t\\t/(kindle)/.exec(ua) ||\\n\\t\\t/(android)/.exec(ua) ||\\n\\t\\t/(windows)/.exec(ua) ||\\n\\t\\t/(mac)/.exec(ua) ||\\n\\t\\t/(linux)/.exec(ua) ||\\n\\t\\t/(cros)/.exec(ua) ||\\n\\t\\t[];\\n\\n\\tlet matched = {\\n\\t\\tbrowser: match[5] || match[3] || match[1] || '',\\n\\t\\tversion: match[2] || match[4] || '0',\\n\\t\\tmajorVersion: match[4] || match[2] || '0',\\n\\t\\tplatform: platform_match[0] || ''\\n\\t};\\n\\n\\tlet browser = {};\\n\\tif (matched.browser) {\\n\\t\\tbrowser[matched.browser] = true;\\n\\n\\t\\tlet versionArray = matched.majorVersion.split('.');\\n\\t\\tbrowser.version = {\\n\\t\\t\\tmajor: parseInt(matched.majorVersion, 10),\\n\\t\\t\\tstring: matched.version\\n\\t\\t};\\n\\t\\tif (versionArray.length > 1) {\\n\\t\\t\\tbrowser.version.minor = parseInt(versionArray[1], 10);\\n\\t\\t}\\n\\t\\tif (versionArray.length > 2) {\\n\\t\\t\\tbrowser.version.build = parseInt(versionArray[2], 10);\\n\\t\\t}\\n\\t}\\n\\n\\tif (matched.platform) {\\n\\t\\tbrowser[matched.platform] = true;\\n\\t}\\n\\n\\tif (browser.chrome || browser.opr || browser.safari) {\\n\\t\\tbrowser.webkit = true;\\n\\t}\\n\\n\\t// MSIE. IE11 has 'rv' identifer\\n\\tif (browser.rv || browser.iemobile) {\\n\\t\\tif (browser.rv) {\\n\\t\\t\\tdelete browser.rv;\\n\\t\\t}\\n\\t\\tlet msie = 'msie';\\n\\t\\tmatched.browser = msie;\\n\\t\\tbrowser[msie] = true;\\n\\t}\\n\\n\\t// Microsoft Edge\\n\\tif (browser.edge) {\\n\\t\\tdelete browser.edge;\\n\\t\\tlet msedge = 'msedge';\\n\\t\\tmatched.browser = msedge;\\n\\t\\tbrowser[msedge] = true;\\n\\t}\\n\\n\\t// Opera 15+\\n\\tif (browser.opr) {\\n\\t\\tlet opera = 'opera';\\n\\t\\tmatched.browser = opera;\\n\\t\\tbrowser[opera] = true;\\n\\t}\\n\\n\\t// Stock android browsers are marked as Safari\\n\\tif (browser.safari && browser.android) {\\n\\t\\tlet android = 'android';\\n\\t\\tmatched.browser = android;\\n\\t\\tbrowser[android] = true;\\n\\t}\\n\\n\\tbrowser.name = matched.browser;\\n\\tbrowser.platform = matched.platform;\\n\\n\\tfor (let key in Browser) {\\n\\t\\tif (Browser.hasOwnProperty(key)) {\\n\\t\\t\\tdelete Browser[key];\\n\\t\\t}\\n\\t}\\n\\tObject.assign(Browser, browser);\\n}\\n\\ndetect();\\n\\n/* harmony default export */ const browser = (Browser);\\n\\n;// CONCATENATED MODULE: ./src/formats/mp4-remuxer.js\\n/*\\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\\n *\\n * @author zheng qian <xqq@xqq.im>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n\\n// Fragmented mp4 remuxer\\n\\n\\n\\n\\n\\n\\n\\nclass MP4Remuxer {\\n\\tTAG = 'MP4Remuxer'\\n\\n\\tconstructor(config) {\\n\\t\\tthis._config = config;\\n\\t\\tthis._isLive = (config.isLive === true);\\n\\n\\t\\tthis._dtsBase = -1;\\n\\t\\tthis._dtsBaseInited = false;\\n\\t\\tthis._audioDtsBase = Infinity;\\n\\t\\tthis._videoDtsBase = Infinity;\\n\\t\\tthis._audioNextDts = undefined;\\n\\t\\tthis._videoNextDts = undefined;\\n\\t\\tthis._audioStashedLastSample = null;\\n\\t\\tthis._videoStashedLastSample = null;\\n\\n\\t\\tthis._audioMeta = null;\\n\\t\\tthis._videoMeta = null;\\n\\n\\t\\tthis._audioSegmentInfoList = new MediaSegmentInfoList('audio');\\n\\t\\tthis._videoSegmentInfoList = new MediaSegmentInfoList('video');\\n\\n\\t\\tthis._onInitSegment = null;\\n\\t\\tthis._onMediaSegment = null;\\n\\n\\t\\t// Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\\n\\t\\t// see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\\n\\t\\tthis._forceFirstIDR = (browser.chrome &&\\n\\t\\t\\t(browser.version.major < 50 ||\\n\\t\\t\\t\\t(browser.version.major === 50 && browser.version.build < 2661))) ? true : false;\\n\\n\\t\\t// Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\\n\\t\\t// Make audio beginDts equals with video beginDts, in order to fix seek freeze\\n\\t\\tthis._fillSilentAfterSeek = (browser.msedge || browser.msie);\\n\\n\\t\\t// While only FireFox supports 'audio/mp4, codecs=\\\"mp3\\\"', use 'audio/mpeg' for chrome, safari, ...\\n\\t\\tthis._mp3UseMpegAudio = !browser.firefox;\\n\\n\\t\\tthis._fillAudioTimestampGap = this._config.fixAudioTimestampGap;\\n\\t}\\n\\n\\tdestroy() {\\n\\t\\tthis._dtsBase = -1;\\n\\t\\tthis._dtsBaseInited = false;\\n\\t\\tthis._audioMeta = null;\\n\\t\\tthis._videoMeta = null;\\n\\t\\tthis._audioSegmentInfoList.clear();\\n\\t\\tthis._audioSegmentInfoList = null;\\n\\t\\tthis._videoSegmentInfoList.clear();\\n\\t\\tthis._videoSegmentInfoList = null;\\n\\t\\tthis._onInitSegment = null;\\n\\t\\tthis._onMediaSegment = null;\\n\\t}\\n\\n\\tget onInitSegment() {\\n\\t\\treturn this._onInitSegment;\\n\\t}\\n\\n\\tset onInitSegment(callback) {\\n\\t\\tthis._onInitSegment = callback;\\n\\t}\\n\\n\\tget onMediaSegment() {\\n\\t\\treturn this._onMediaSegment;\\n\\t}\\n\\n\\tset onMediaSegment(callback) {\\n\\t\\tthis._onMediaSegment = callback;\\n\\t}\\n\\n\\tinsertDiscontinuity() {\\n\\t\\tthis._audioNextDts = this._videoNextDts = undefined;\\n\\t}\\n\\n\\tseek(originalDts) {\\n\\t\\tthis._audioStashedLastSample = null;\\n\\t\\tthis._videoStashedLastSample = null;\\n\\t\\tthis._videoSegmentInfoList.clear();\\n\\t\\tthis._audioSegmentInfoList.clear();\\n\\t}\\n\\n\\tremux(audioTrack, videoTrack) {\\n\\t\\tif (!this._onMediaSegment) {\\n\\t\\t\\tthrow new IllegalStateException('MP4Remuxer: onMediaSegment callback must be specificed!');\\n\\t\\t}\\n\\t\\tif (!this._dtsBaseInited) {\\n\\t\\t\\tthis._calculateDtsBase(audioTrack, videoTrack);\\n\\t\\t}\\n\\t\\tthis._remuxVideo(videoTrack);\\n\\t\\tthis._remuxAudio(audioTrack);\\n\\t}\\n\\n\\t_onTrackMetadataReceived(type, metadata) {\\n\\t\\tlogger.i(this.TAG, \\\"_onTrackMetadataReceived\\\");\\n\\t\\tlet metabox = null;\\n\\n\\t\\tlet container = 'mp4';\\n\\t\\tlet codec = metadata.codec;\\n\\n\\t\\tif (type === 'audio') {\\n\\t\\t\\tthis._audioMeta = metadata;\\n\\t\\t\\tif (metadata.codec === 'mp3' && this._mp3UseMpegAudio) {\\n\\t\\t\\t\\t// 'audio/mpeg' for MP3 audio track\\n\\t\\t\\t\\tcontainer = 'mpeg';\\n\\t\\t\\t\\tcodec = '';\\n\\t\\t\\t\\tmetabox = new Uint8Array(0);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// 'audio/mp4, codecs=\\\"codec\\\"'\\n\\t\\t\\t\\tmetabox = mp4.generateInitSegment(metadata);\\n\\t\\t\\t}\\n\\t\\t} else if (type === 'video') {\\n\\t\\t\\tthis._videoMeta = metadata;\\n\\t\\t\\tmetabox = mp4.generateInitSegment(metadata);\\n\\t\\t} else {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// dispatch metabox (Initialization Segment)\\n\\t\\tif (!this._onInitSegment) {\\n\\t\\t\\tthrow new IllegalStateException('MP4Remuxer: onInitSegment callback must be specified!');\\n\\t\\t}\\n\\t\\tthis._onInitSegment(type, {\\n\\t\\t\\ttype: type,\\n\\t\\t\\tdata: metabox.buffer,\\n\\t\\t\\tcodec: codec,\\n\\t\\t\\tcontainer: `${type}/${container}`,\\n\\t\\t\\tmediaDuration: metadata.duration  // in timescale 1000 (milliseconds)\\n\\t\\t});\\n\\t}\\n\\n\\t_calculateDtsBase(audioTrack, videoTrack) {\\n\\t\\tif (this._dtsBaseInited) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (audioTrack.samples && audioTrack.samples.length) {\\n\\t\\t\\tthis._audioDtsBase = audioTrack.samples[0].dts;\\n\\t\\t}\\n\\t\\tif (videoTrack.samples && videoTrack.samples.length) {\\n\\t\\t\\tthis._videoDtsBase = videoTrack.samples[0].dts;\\n\\t\\t}\\n\\n\\t\\tthis._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\\n\\t\\tthis._dtsBaseInited = true;\\n\\t}\\n\\n\\tflushStashedSamples() {\\n\\t\\tlet videoSample = this._videoStashedLastSample;\\n\\t\\tlet audioSample = this._audioStashedLastSample;\\n\\n\\t\\tlet videoTrack = {\\n\\t\\t\\ttype: 'video',\\n\\t\\t\\tid: 1,\\n\\t\\t\\tsequenceNumber: 0,\\n\\t\\t\\tsamples: [],\\n\\t\\t\\tlength: 0\\n\\t\\t};\\n\\n\\t\\tif (videoSample != null) {\\n\\t\\t\\tvideoTrack.samples.push(videoSample);\\n\\t\\t\\tvideoTrack.length = videoSample.length;\\n\\t\\t}\\n\\n\\t\\tlet audioTrack = {\\n\\t\\t\\ttype: 'audio',\\n\\t\\t\\tid: 2,\\n\\t\\t\\tsequenceNumber: 0,\\n\\t\\t\\tsamples: [],\\n\\t\\t\\tlength: 0\\n\\t\\t};\\n\\n\\t\\tif (audioSample != null) {\\n\\t\\t\\taudioTrack.samples.push(audioSample);\\n\\t\\t\\taudioTrack.length = audioSample.length;\\n\\t\\t}\\n\\n\\t\\tthis._videoStashedLastSample = null;\\n\\t\\tthis._audioStashedLastSample = null;\\n\\n\\t\\tthis._remuxVideo(videoTrack, true);\\n\\t\\tthis._remuxAudio(audioTrack, true);\\n\\t}\\n\\n\\t_remuxAudio(audioTrack, force) {\\n\\t\\tlogger.i(this.TAG, \\\"_remuxAudio\\\");\\n\\t\\tif (this._audioMeta == null) {\\n\\t\\t\\tlogger.w(this.TAG, \\\"no audioMeta\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tlet track = audioTrack;\\n\\t\\tlet samples = track.samples;\\n\\t\\tlet dtsCorrection = undefined;\\n\\t\\tlet firstDts = -1, lastDts = -1, lastPts = -1;\\n\\t\\tlet refSampleDuration = this._audioMeta.refSampleDuration;\\n\\n\\t\\tlet mpegRawTrack = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio;\\n\\t\\tlet firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === undefined;\\n\\n\\t\\tlet insertPrefixSilentFrame = false;\\n\\n\\t\\tif (!samples || samples.length === 0) {\\n\\t\\t\\tlogger.w(this.TAG, \\\"no samples\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (samples.length === 1 && !force) {\\n\\t\\t\\t// If [sample count in current batch] === 1 && (force != true)\\n\\t\\t\\t// Ignore and keep in demuxer's queue\\n\\t\\t\\tlogger.w(this.TAG, \\\"1 sample\\\");\\n\\t\\t\\treturn;\\n\\t\\t}  // else if (force === true) do remux\\n\\n\\t\\tlet offset = 0;\\n\\t\\tlet mdatbox = null;\\n\\t\\tlet mdatBytes = 0;\\n\\n\\t\\t// calculate initial mdat size\\n\\t\\tif (mpegRawTrack) {\\n\\t\\t\\t// for raw mpeg buffer\\n\\t\\t\\toffset = 0;\\n\\t\\t\\tmdatBytes = track.length;\\n\\t\\t} else {\\n\\t\\t\\t// for fmp4 mdat box\\n\\t\\t\\toffset = 8;  // size + type\\n\\t\\t\\tmdatBytes = 8 + track.length;\\n\\t\\t}\\n\\n\\n\\t\\tlet lastSample = null;\\n\\n\\t\\t// Pop the lastSample and waiting for stash\\n\\t\\tif (samples.length > 1) {\\n\\t\\t\\tlastSample = samples.pop();\\n\\t\\t\\tmdatBytes -= lastSample.length;\\n\\t\\t}\\n\\n\\t\\t// Insert [stashed lastSample in the previous batch] to the front\\n\\t\\tif (this._audioStashedLastSample != null) {\\n\\t\\t\\tlet sample = this._audioStashedLastSample;\\n\\t\\t\\tthis._audioStashedLastSample = null;\\n\\t\\t\\tsamples.unshift(sample);\\n\\t\\t\\tmdatBytes += sample.length;\\n\\t\\t}\\n\\n\\t\\t// Stash the lastSample of current batch, waiting for next batch\\n\\t\\tif (lastSample != null) {\\n\\t\\t\\tthis._audioStashedLastSample = lastSample;\\n\\t\\t}\\n\\n\\n\\t\\tlet firstSampleOriginalDts = samples[0].dts - this._dtsBase;\\n\\n\\t\\t// calculate dtsCorrection\\n\\t\\tif (this._audioNextDts) {\\n\\t\\t\\tdtsCorrection = firstSampleOriginalDts - this._audioNextDts;\\n\\t\\t} else {  // this._audioNextDts == undefined\\n\\t\\t\\tif (this._audioSegmentInfoList.isEmpty()) {\\n\\t\\t\\t\\tdtsCorrection = 0;\\n\\t\\t\\t\\tif (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\\n\\t\\t\\t\\t\\tif (this._audioMeta.originalCodec !== 'mp3') {\\n\\t\\t\\t\\t\\t\\tinsertPrefixSilentFrame = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet lastSample = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\\n\\t\\t\\t\\tif (lastSample != null) {\\n\\t\\t\\t\\t\\tlet distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\\n\\t\\t\\t\\t\\tif (distance <= 3) {\\n\\t\\t\\t\\t\\t\\tdistance = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlet expectedDts = lastSample.dts + lastSample.duration + distance;\\n\\t\\t\\t\\t\\tdtsCorrection = firstSampleOriginalDts - expectedDts;\\n\\t\\t\\t\\t} else { // lastSample == null, cannot found\\n\\t\\t\\t\\t\\tdtsCorrection = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (insertPrefixSilentFrame) {\\n\\t\\t\\t// align audio segment beginDts to match with current video segment's beginDts\\n\\t\\t\\tlet firstSampleDts = firstSampleOriginalDts - dtsCorrection;\\n\\t\\t\\tlet videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);\\n\\t\\t\\tif (videoSegment != null && videoSegment.beginDts < firstSampleDts) {\\n\\t\\t\\t\\tlet silentUnit = aac_silent.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\\n\\t\\t\\t\\tif (silentUnit) {\\n\\t\\t\\t\\t\\tlet dts = videoSegment.beginDts;\\n\\t\\t\\t\\t\\tlet silentFrameDuration = firstSampleDts - videoSegment.beginDts;\\n\\t\\t\\t\\t\\tlogger.v(this.TAG, `InsertPrefixSilentAudio: dts: ${dts}, duration: ${silentFrameDuration}`);\\n\\t\\t\\t\\t\\tsamples.unshift({ unit: silentUnit, dts: dts, pts: dts });\\n\\t\\t\\t\\t\\tmdatBytes += silentUnit.byteLength;\\n\\t\\t\\t\\t}  // silentUnit == null: Cannot generate, skip\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertPrefixSilentFrame = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet mp4Samples = [];\\n\\n\\t\\t// Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\\n\\t\\tfor (let i = 0; i < samples.length; i++) {\\n\\t\\t\\tlet sample = samples[i];\\n\\t\\t\\tlet unit = sample.unit;\\n\\t\\t\\tlet originalDts = sample.dts - this._dtsBase;\\n\\t\\t\\tlet dts = originalDts;\\n\\t\\t\\tlet needFillSilentFrames = false;\\n\\t\\t\\tlet silentFrames = null;\\n\\t\\t\\tlet sampleDuration = 0;\\n\\n\\t\\t\\tif (originalDts < -0.001) {\\n\\t\\t\\t\\tcontinue; //pass the first sample with the invalid dts\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (this._audioMeta.codec !== 'mp3') {\\n\\t\\t\\t\\t// for AAC codec, we need to keep dts increase based on refSampleDuration\\n\\t\\t\\t\\tlet curRefDts = originalDts;\\n\\t\\t\\t\\tconst maxAudioFramesDrift = 3;\\n\\t\\t\\t\\tif (this._audioNextDts) {\\n\\t\\t\\t\\t\\tcurRefDts = this._audioNextDts;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdtsCorrection = originalDts - curRefDts;\\n\\t\\t\\t\\tif (dtsCorrection <= -maxAudioFramesDrift * refSampleDuration) {\\n\\t\\t\\t\\t\\t// If we're overlapping by more than maxAudioFramesDrift number of frame, drop this sample\\n\\t\\t\\t\\t\\tlogger.w(this.TAG, `Dropping 1 audio frame (originalDts: ${originalDts} ms ,curRefDts: ${curRefDts} ms)  due to dtsCorrection: ${dtsCorrection} ms overlap.`);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (dtsCorrection >= maxAudioFramesDrift * refSampleDuration && this._fillAudioTimestampGap && !browser.safari) {\\n\\t\\t\\t\\t\\t// Silent frame generation, if large timestamp gap detected && config.fixAudioTimestampGap\\n\\t\\t\\t\\t\\tneedFillSilentFrames = true;\\n\\t\\t\\t\\t\\t// We need to insert silent frames to fill timestamp gap\\n\\t\\t\\t\\t\\tlet frameCount = Math.floor(dtsCorrection / refSampleDuration);\\n\\t\\t\\t\\t\\tlogger.w(this.TAG, 'Large audio timestamp gap detected, may cause AV sync to drift. ' +\\n\\t\\t\\t\\t\\t\\t'Silent frames will be generated to avoid unsync.\\\\n' +\\n\\t\\t\\t\\t\\t\\t`originalDts: ${originalDts} ms, curRefDts: ${curRefDts} ms, ` +\\n\\t\\t\\t\\t\\t\\t`dtsCorrection: ${Math.round(dtsCorrection)} ms, generate: ${frameCount} frames`);\\n\\n\\n\\t\\t\\t\\t\\tdts = Math.floor(curRefDts);\\n\\t\\t\\t\\t\\tsampleDuration = Math.floor(curRefDts + refSampleDuration) - dts;\\n\\n\\t\\t\\t\\t\\tlet silentUnit = aac_silent.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\\n\\t\\t\\t\\t\\tif (silentUnit == null) {\\n\\t\\t\\t\\t\\t\\tlogger.w(this.TAG, 'Unable to generate silent frame for ' +\\n\\t\\t\\t\\t\\t\\t\\t`${this._audioMeta.originalCodec} with ${this._audioMeta.channelCount} channels, repeat last frame`);\\n\\t\\t\\t\\t\\t\\t// Repeat last frame\\n\\t\\t\\t\\t\\t\\tsilentUnit = unit;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsilentFrames = [];\\n\\n\\t\\t\\t\\t\\tfor (let j = 0; j < frameCount; j++) {\\n\\t\\t\\t\\t\\t\\tcurRefDts = curRefDts + refSampleDuration;\\n\\t\\t\\t\\t\\t\\tlet intDts = Math.floor(curRefDts);  // change to integer\\n\\t\\t\\t\\t\\t\\tlet intDuration = Math.floor(curRefDts + refSampleDuration) - intDts;\\n\\t\\t\\t\\t\\t\\tlet frame = {\\n\\t\\t\\t\\t\\t\\t\\tdts: intDts,\\n\\t\\t\\t\\t\\t\\t\\tpts: intDts,\\n\\t\\t\\t\\t\\t\\t\\tcts: 0,\\n\\t\\t\\t\\t\\t\\t\\tunit: silentUnit,\\n\\t\\t\\t\\t\\t\\t\\tsize: silentUnit.byteLength,\\n\\t\\t\\t\\t\\t\\t\\tduration: intDuration,  // wait for next sample\\n\\t\\t\\t\\t\\t\\t\\toriginalDts: originalDts,\\n\\t\\t\\t\\t\\t\\t\\tflags: {\\n\\t\\t\\t\\t\\t\\t\\t\\tisLeading: 0,\\n\\t\\t\\t\\t\\t\\t\\t\\tdependsOn: 1,\\n\\t\\t\\t\\t\\t\\t\\t\\tisDependedOn: 0,\\n\\t\\t\\t\\t\\t\\t\\t\\thasRedundancy: 0\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tsilentFrames.push(frame);\\n\\t\\t\\t\\t\\t\\tmdatBytes += frame.size;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis._audioNextDts = curRefDts + refSampleDuration;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tdts = Math.floor(curRefDts);\\n\\t\\t\\t\\t\\tsampleDuration = Math.floor(curRefDts + refSampleDuration) - dts;\\n\\t\\t\\t\\t\\tthis._audioNextDts = curRefDts + refSampleDuration;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// keep the original dts calculate algorithm for mp3\\n\\t\\t\\t\\tdts = originalDts - dtsCorrection;\\n\\n\\n\\t\\t\\t\\tif (i !== samples.length - 1) {\\n\\t\\t\\t\\t\\tlet nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\\n\\t\\t\\t\\t\\tsampleDuration = nextDts - dts;\\n\\t\\t\\t\\t} else {  // the last sample\\n\\t\\t\\t\\t\\tif (lastSample != null) {  // use stashed sample's dts to calculate sample duration\\n\\t\\t\\t\\t\\t\\tlet nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\\n\\t\\t\\t\\t\\t\\tsampleDuration = nextDts - dts;\\n\\t\\t\\t\\t\\t} else if (mp4Samples.length >= 1) {  // use second last sample duration\\n\\t\\t\\t\\t\\t\\tsampleDuration = mp4Samples[mp4Samples.length - 1].duration;\\n\\t\\t\\t\\t\\t} else {  // the only one sample, use reference sample duration\\n\\t\\t\\t\\t\\t\\tsampleDuration = Math.floor(refSampleDuration);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis._audioNextDts = dts + sampleDuration;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (firstDts === -1) {\\n\\t\\t\\t\\tfirstDts = dts;\\n\\t\\t\\t}\\n\\t\\t\\tmp4Samples.push({\\n\\t\\t\\t\\tdts: dts,\\n\\t\\t\\t\\tpts: dts,\\n\\t\\t\\t\\tcts: 0,\\n\\t\\t\\t\\tunit: sample.unit,\\n\\t\\t\\t\\tsize: sample.unit.byteLength,\\n\\t\\t\\t\\tduration: sampleDuration,\\n\\t\\t\\t\\toriginalDts: originalDts,\\n\\t\\t\\t\\tflags: {\\n\\t\\t\\t\\t\\tisLeading: 0,\\n\\t\\t\\t\\t\\tdependsOn: 1,\\n\\t\\t\\t\\t\\tisDependedOn: 0,\\n\\t\\t\\t\\t\\thasRedundancy: 0\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (needFillSilentFrames) {\\n\\t\\t\\t\\t// Silent frames should be inserted after wrong-duration frame\\n\\t\\t\\t\\tmp4Samples.push.apply(mp4Samples, silentFrames);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (mp4Samples.length === 0) {\\n\\t\\t\\t//no samples need to remux\\n\\t\\t\\ttrack.samples = [];\\n\\t\\t\\ttrack.length = 0;\\n\\t\\t\\tlogger.w(this.TAG, \\\"no mp4Samples = 0\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// allocate mdatbox\\n\\t\\tif (mpegRawTrack) {\\n\\t\\t\\t// allocate for raw mpeg buffer\\n\\t\\t\\tmdatbox = new Uint8Array(mdatBytes);\\n\\t\\t} else {\\n\\t\\t\\t// allocate for fmp4 mdat box\\n\\t\\t\\tmdatbox = new Uint8Array(mdatBytes);\\n\\t\\t\\t// size field\\n\\t\\t\\tmdatbox[0] = (mdatBytes >>> 24) & 0xFF;\\n\\t\\t\\tmdatbox[1] = (mdatBytes >>> 16) & 0xFF;\\n\\t\\t\\tmdatbox[2] = (mdatBytes >>> 8) & 0xFF;\\n\\t\\t\\tmdatbox[3] = (mdatBytes) & 0xFF;\\n\\t\\t\\t// type field (fourCC)\\n\\t\\t\\tmdatbox.set(mp4.types.mdat, 4);\\n\\t\\t}\\n\\n\\t\\t// Write samples into mdatbox\\n\\t\\tfor (let i = 0; i < mp4Samples.length; i++) {\\n\\t\\t\\tlet unit = mp4Samples[i].unit;\\n\\t\\t\\tmdatbox.set(unit, offset);\\n\\t\\t\\toffset += unit.byteLength;\\n\\t\\t}\\n\\n\\t\\tlet latest = mp4Samples[mp4Samples.length - 1];\\n\\t\\tlastDts = latest.dts + latest.duration;\\n\\t\\t//this._audioNextDts = lastDts;\\n\\n\\t\\t// fill media segment info & add to info list\\n\\t\\tlet info = new MediaSegmentInfo();\\n\\t\\tinfo.beginDts = firstDts;\\n\\t\\tinfo.endDts = lastDts;\\n\\t\\tinfo.beginPts = firstDts;\\n\\t\\tinfo.endPts = lastDts;\\n\\t\\tinfo.originalBeginDts = mp4Samples[0].originalDts;\\n\\t\\tinfo.originalEndDts = latest.originalDts + latest.duration;\\n\\t\\tinfo.firstSample = new SampleInfo(mp4Samples[0].dts,\\n\\t\\t\\tmp4Samples[0].pts,\\n\\t\\t\\tmp4Samples[0].duration,\\n\\t\\t\\tmp4Samples[0].originalDts,\\n\\t\\t\\tfalse);\\n\\t\\tinfo.lastSample = new SampleInfo(latest.dts,\\n\\t\\t\\tlatest.pts,\\n\\t\\t\\tlatest.duration,\\n\\t\\t\\tlatest.originalDts,\\n\\t\\t\\tfalse);\\n\\t\\tif (!this._isLive) {\\n\\t\\t\\tthis._audioSegmentInfoList.append(info);\\n\\t\\t}\\n\\n\\t\\ttrack.samples = mp4Samples;\\n\\t\\ttrack.sequenceNumber++;\\n\\n\\t\\tlet moofbox;\\n\\n\\t\\tif (mpegRawTrack) {\\n\\t\\t\\t// Generate empty buffer, because useless for raw mpeg\\n\\t\\t\\tmoofbox = new Uint8Array(0);\\n\\t\\t} else {\\n\\t\\t\\t// Generate moof for fmp4 segment\\n\\t\\t\\tmoofbox = mp4.moof(track, firstDts);\\n\\t\\t}\\n\\n\\t\\ttrack.samples = [];\\n\\t\\ttrack.length = 0;\\n\\n\\t\\tlet segment = {\\n\\t\\t\\ttype: 'audio',\\n\\t\\t\\tdata: this._mergeBoxes(moofbox, mdatbox).buffer,\\n\\t\\t\\tsampleCount: mp4Samples.length,\\n\\t\\t\\tinfo: info\\n\\t\\t};\\n\\n\\t\\tif (mpegRawTrack && firstSegmentAfterSeek) {\\n\\t\\t\\t// For MPEG audio stream in MSE, if seeking occurred, before appending new buffer\\n\\t\\t\\t// We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\\n\\t\\t\\tsegment.timestampOffset = firstDts;\\n\\t\\t}\\n\\n\\t\\tlogger.i(this.TAG, \\\"send onMediaSegment audio\\\");\\n\\t\\tthis._onMediaSegment('audio', segment);\\n\\t}\\n\\n\\t_remuxVideo(videoTrack, force) {\\n\\t\\tlogger.i(this.TAG, \\\"_remuxVideo\\\");\\n\\t\\tif (this._videoMeta == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tlet track = videoTrack;\\n\\t\\tlet samples = track.samples;\\n\\t\\tlet dtsCorrection = undefined;\\n\\t\\tlet firstDts = -1, lastDts = -1;\\n\\t\\tlet firstPts = -1, lastPts = -1;\\n\\n\\t\\tif (!samples || samples.length === 0) {\\n\\t\\t\\tlogger.w(this.TAG, \\\"no samples\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (samples.length === 1 && !force) {\\n\\t\\t\\t// If [sample count in current batch] === 1 && (force != true)\\n\\t\\t\\t// Ignore and keep in demuxer's queue\\n\\t\\t\\tlogger.w(this.TAG, \\\"no sampes = 1\\\");\\n\\t\\t\\treturn;\\n\\t\\t}  // else if (force === true) do remux\\n\\n\\t\\tlet offset = 8;\\n\\t\\tlet mdatbox = null;\\n\\t\\tlet mdatBytes = 8 + videoTrack.length;\\n\\n\\n\\t\\tlet lastSample = null;\\n\\n\\t\\t// Pop the lastSample and waiting for stash\\n\\t\\tif (samples.length > 1) {\\n\\t\\t\\tlastSample = samples.pop();\\n\\t\\t\\tmdatBytes -= lastSample.length;\\n\\t\\t}\\n\\n\\t\\t// Insert [stashed lastSample in the previous batch] to the front\\n\\t\\tif (this._videoStashedLastSample != null) {\\n\\t\\t\\tlet sample = this._videoStashedLastSample;\\n\\t\\t\\tthis._videoStashedLastSample = null;\\n\\t\\t\\tsamples.unshift(sample);\\n\\t\\t\\tmdatBytes += sample.length;\\n\\t\\t}\\n\\n\\t\\t// Stash the lastSample of current batch, waiting for next batch\\n\\t\\tif (lastSample != null) {\\n\\t\\t\\tthis._videoStashedLastSample = lastSample;\\n\\t\\t}\\n\\n\\n\\t\\tlet firstSampleOriginalDts = samples[0].dts - this._dtsBase;\\n\\n\\t\\t// calculate dtsCorrection\\n\\t\\tif (this._videoNextDts) {\\n\\t\\t\\tdtsCorrection = firstSampleOriginalDts - this._videoNextDts;\\n\\t\\t} else {  // this._videoNextDts == undefined\\n\\t\\t\\tif (this._videoSegmentInfoList.isEmpty()) {\\n\\t\\t\\t\\tdtsCorrection = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet lastSample = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\\n\\t\\t\\t\\tif (lastSample != null) {\\n\\t\\t\\t\\t\\tlet distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\\n\\t\\t\\t\\t\\tif (distance <= 3) {\\n\\t\\t\\t\\t\\t\\tdistance = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlet expectedDts = lastSample.dts + lastSample.duration + distance;\\n\\t\\t\\t\\t\\tdtsCorrection = firstSampleOriginalDts - expectedDts;\\n\\t\\t\\t\\t} else { // lastSample == null, cannot found\\n\\t\\t\\t\\t\\tdtsCorrection = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet info = new MediaSegmentInfo();\\n\\t\\tlet mp4Samples = [];\\n\\n\\t\\t// Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\\n\\t\\tfor (let i = 0; i < samples.length; i++) {\\n\\t\\t\\tlet sample = samples[i];\\n\\t\\t\\tlet originalDts = sample.dts - this._dtsBase;\\n\\t\\t\\tlet isKeyframe = sample.isKeyframe;\\n\\t\\t\\tlet dts = originalDts - dtsCorrection;\\n\\t\\t\\tlet cts = sample.cts;\\n\\t\\t\\tlet pts = dts + cts;\\n\\n\\t\\t\\tif (firstDts === -1) {\\n\\t\\t\\t\\tfirstDts = dts;\\n\\t\\t\\t\\tfirstPts = pts;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet sampleDuration = 0;\\n\\n\\t\\t\\tif (i !== samples.length - 1) {\\n\\t\\t\\t\\tlet nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\\n\\t\\t\\t\\tsampleDuration = nextDts - dts;\\n\\t\\t\\t} else {  // the last sample\\n\\t\\t\\t\\tif (lastSample != null) {  // use stashed sample's dts to calculate sample duration\\n\\t\\t\\t\\t\\tlet nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\\n\\t\\t\\t\\t\\tsampleDuration = nextDts - dts;\\n\\t\\t\\t\\t} else if (mp4Samples.length >= 1) {  // use second last sample duration\\n\\t\\t\\t\\t\\tsampleDuration = mp4Samples[mp4Samples.length - 1].duration;\\n\\t\\t\\t\\t} else {  // the only one sample, use reference sample duration\\n\\t\\t\\t\\t\\tsampleDuration = Math.floor(this._videoMeta.refSampleDuration);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (isKeyframe) {\\n\\t\\t\\t\\tlet syncPoint = new SampleInfo(dts, pts, sampleDuration, sample.dts, true);\\n\\t\\t\\t\\tsyncPoint.fileposition = sample.fileposition;\\n\\t\\t\\t\\tinfo.appendSyncPoint(syncPoint);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmp4Samples.push({\\n\\t\\t\\t\\tdts: dts,\\n\\t\\t\\t\\tpts: pts,\\n\\t\\t\\t\\tcts: cts,\\n\\t\\t\\t\\tunits: sample.units,\\n\\t\\t\\t\\tsize: sample.length,\\n\\t\\t\\t\\tisKeyframe: isKeyframe,\\n\\t\\t\\t\\tduration: sampleDuration,\\n\\t\\t\\t\\toriginalDts: originalDts,\\n\\t\\t\\t\\tflags: {\\n\\t\\t\\t\\t\\tisLeading: 0,\\n\\t\\t\\t\\t\\tdependsOn: isKeyframe ? 2 : 1,\\n\\t\\t\\t\\t\\tisDependedOn: isKeyframe ? 1 : 0,\\n\\t\\t\\t\\t\\thasRedundancy: 0,\\n\\t\\t\\t\\t\\tisNonSync: isKeyframe ? 0 : 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t// allocate mdatbox\\n\\t\\tmdatbox = new Uint8Array(mdatBytes);\\n\\t\\tmdatbox[0] = (mdatBytes >>> 24) & 0xFF;\\n\\t\\tmdatbox[1] = (mdatBytes >>> 16) & 0xFF;\\n\\t\\tmdatbox[2] = (mdatBytes >>> 8) & 0xFF;\\n\\t\\tmdatbox[3] = (mdatBytes) & 0xFF;\\n\\t\\tmdatbox.set(mp4.types.mdat, 4);\\n\\n\\t\\t// Write samples into mdatbox\\n\\t\\tfor (let i = 0; i < mp4Samples.length; i++) {\\n\\t\\t\\tlet units = mp4Samples[i].units;\\n\\t\\t\\twhile (units.length) {\\n\\t\\t\\t\\tlet unit = units.shift();\\n\\t\\t\\t\\tlet data = unit.data;\\n\\t\\t\\t\\tmdatbox.set(data, offset);\\n\\t\\t\\t\\toffset += data.byteLength;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet latest = mp4Samples[mp4Samples.length - 1];\\n\\t\\tlastDts = latest.dts + latest.duration;\\n\\t\\tlastPts = latest.pts + latest.duration;\\n\\t\\tthis._videoNextDts = lastDts;\\n\\n\\t\\t// fill media segment info & add to info list\\n\\t\\tinfo.beginDts = firstDts;\\n\\t\\tinfo.endDts = lastDts;\\n\\t\\tinfo.beginPts = firstPts;\\n\\t\\tinfo.endPts = lastPts;\\n\\t\\tinfo.originalBeginDts = mp4Samples[0].originalDts;\\n\\t\\tinfo.originalEndDts = latest.originalDts + latest.duration;\\n\\t\\tinfo.firstSample = new SampleInfo(mp4Samples[0].dts,\\n\\t\\t\\tmp4Samples[0].pts,\\n\\t\\t\\tmp4Samples[0].duration,\\n\\t\\t\\tmp4Samples[0].originalDts,\\n\\t\\t\\tmp4Samples[0].isKeyframe);\\n\\t\\tinfo.lastSample = new SampleInfo(latest.dts,\\n\\t\\t\\tlatest.pts,\\n\\t\\t\\tlatest.duration,\\n\\t\\t\\tlatest.originalDts,\\n\\t\\t\\tlatest.isKeyframe);\\n\\t\\tif (!this._isLive) {\\n\\t\\t\\tthis._videoSegmentInfoList.append(info);\\n\\t\\t}\\n\\n\\t\\ttrack.samples = mp4Samples;\\n\\t\\ttrack.sequenceNumber++;\\n\\n\\t\\t// workaround for chrome < 50: force first sample as a random access point\\n\\t\\t// see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\\n\\t\\tif (this._forceFirstIDR) {\\n\\t\\t\\tlet flags = mp4Samples[0].flags;\\n\\t\\t\\tflags.dependsOn = 2;\\n\\t\\t\\tflags.isNonSync = 0;\\n\\t\\t}\\n\\n\\t\\tlet moofbox = mp4.moof(track, firstDts);\\n\\t\\ttrack.samples = [];\\n\\t\\ttrack.length = 0;\\n\\n\\t\\tlogger.i(this.TAG, \\\"send onMediaSegment video\\\");\\n\\t\\tthis._onMediaSegment('video', {\\n\\t\\t\\ttype: 'video',\\n\\t\\t\\tdata: this._mergeBoxes(moofbox, mdatbox).buffer,\\n\\t\\t\\tsampleCount: mp4Samples.length,\\n\\t\\t\\tinfo: info\\n\\t\\t});\\n\\t}\\n\\n\\t_mergeBoxes(moof, mdat) {\\n\\t\\tlet result = new Uint8Array(moof.byteLength + mdat.byteLength);\\n\\t\\tresult.set(moof, 0);\\n\\t\\tresult.set(mdat, moof.byteLength);\\n\\t\\treturn result;\\n\\t}\\n\\n}\\n\\n/* harmony default export */ const mp4_remuxer = (MP4Remuxer);\\n\\n;// CONCATENATED MODULE: ./src/utils/event_emitter.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n/**\\n * A small class for Handling events\\n */\\nclass EventEmitter{\\n\\tListenerList = [];\\n\\tTAG = \\\"EventEmitter\\\";\\n\\twaiters = [];\\n\\n\\tconstructor() {\\n\\t}\\n\\n\\t/**\\n\\t * Add an event listener\\n\\t * @param {String} event - The Name of the event\\n\\t * @param {Function} listener - the callback when occurs\\n\\t * @param {boolean} modal - Overwrite existing listener for this event\\n\\t */\\n\\taddEventListener(event, listener, modal = false){\\n\\t\\tlogger.d(this.TAG, \\\"addEventListener: \\\" + event);\\n\\n\\t\\tfor(let i = 0; i < this.ListenerList.length;i++){\\n\\t\\t\\tlet entry = this.ListenerList[i];\\n\\t\\t\\tif(entry[0] === event) {\\n\\t\\t\\t\\tif (modal || entry[1] === listener) {\\n\\t\\t\\t\\t\\tlogger.w(this.TAG, \\\"Listener already registered, overriding\\\");\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.ListenerList.push([event, listener]);\\n\\t}\\n\\n\\twaitForEvent(event, callback){\\n\\t\\tthis.waiters.push([event, callback]);\\n\\t}\\n\\n\\t/**\\n\\t * A synonym for addEventListener\\n\\t * @param {String} event\\n\\t * @param {Function} listener\\n\\t * @param {boolean} modal\\n\\t */\\n\\taddListener(event, listener, modal){\\n\\t\\tthis.addEventListener(event, listener, modal);\\n\\t}\\n\\n\\n\\t/**\\n\\t * Remove an event listener\\n\\t * @param {String} event\\n\\t * @param {Function} listener\\n\\t */\\n\\tremoveEventListener(event, listener){\\n\\t\\tlogger.d(this.TAG, \\\"removeEventListener: \\\" + event);\\n\\n\\t\\tfor(let i = 0; i < this.ListenerList.length;i++){\\n\\t\\t\\tlet entry = this.ListenerList[i];\\n\\t\\t\\tif(entry[0] === event && entry[1] === listener){\\n\\t\\t\\t\\tthis.ListenerList.splice(i,1);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * A synonym for removeEventListener\\n     * @param {String} event\\n     * @param {Function} listener\\n     */\\n\\tremoveListener(event, listener){\\n\\t\\tthis.removeEventListener(event, listener);\\n\\t}\\n\\n\\t/**\\n\\t * Remove all listener\\n     * @param {String|undefined} event - If provided, remove all listener for this event\\n\\t */\\n\\tremoveAllEventListener(event){\\n\\t\\tlogger.d(this.TAG, \\\"removeAllEventListener: \\\", event);\\n\\t\\tif(event) {\\n\\t\\t\\tfor(let i = 0; i < this.ListenerList.length;i++) {\\n\\t\\t\\t\\tlet entry = this.ListenerList[i];\\n\\t\\t\\t\\tif(entry[0] === event){\\n\\t\\t\\t\\t\\tthis.ListenerList.splice(i,1);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else\\n\\t\\t\\tthis.ListenerList = [];\\n\\t}\\n\\n    /**\\n     * A synonym for removeAllEventListener\\n     * @param event\\n     */\\n\\tremoveAllListener(event){\\n\\t\\tthis.removeAllEventListener(event);\\n\\t}\\n\\n\\t/**\\n\\t *\\n\\t * @param {String} event\\n\\t * @param data\\n\\t */\\n\\temit(event, ...data){\\n\\t\\tlogger.t(this.TAG, \\\"emit EVENT: \\\" + event, ...data);\\n\\n\\t\\tfor(let i = 0; i < this.waiters.length;i++){\\n\\t\\t\\tlet entry = this.waiters[i];\\n\\n\\t\\t\\tif(entry[0] === event){\\n\\t\\t\\t\\tlogger.d(this.TAG, \\\"hit waiting event: \\\" + event);\\n\\t\\t\\t\\tentry[1].call(this, ...data);\\n\\t\\t\\t\\tthis.waiters.splice(i,1);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor(let i = 0; i < this.ListenerList.length;i++){\\n\\t\\t\\tlet entry = this.ListenerList[i];\\n\\t\\t\\tif(entry[0] === event){\\n\\t\\t\\t\\tentry[1].call(this, ...data);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n/* harmony default export */ const event_emitter = (EventEmitter);\\n\\n\\n;// CONCATENATED MODULE: ./src/rtmp/RTMPMediaMessageHandler.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * This was heavily inspired by bilibi FLVPlayer (flv.js/src/demux/flv-demuxer.js)\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * class for handling media type messages\\n */\\nclass RTMPMediaMessageHandler{\\n    TAG = \\\"RTMPMediaMessageHandler\\\";\\n\\n    constructor(config) {\\n        this._config = config;\\n\\n        this._onError = null;\\n        this._onMediaInfo = null;\\n        this._onMetaDataArrived = null;\\n        this._onScriptDataArrived = null;\\n        this._onDataAvailable = null;\\n        this._onTrackMetadata = null;\\n\\n        this._dispatch = false;\\n\\n        this._hasAudio = true;\\n        this._hasVideo = true;\\n\\n        this._hasAudioFlagOverrided = false;\\n        this._hasVideoFlagOverrided = false;\\n\\n        this._audioInitialMetadataDispatched = false;\\n        this._videoInitialMetadataDispatched = false;\\n\\n        this._mediaInfo = new media_info();\\n        this._mediaInfo.hasAudio = this._hasAudio;\\n        this._mediaInfo.hasVideo = this._hasVideo;\\n        this._metadata = null;\\n        this._audioMetadata = null;\\n        this._videoMetadata = null;\\n\\n        this._naluLengthSize = 4;\\n        this._timestampBase = 0;  // int32, in milliseconds\\n        this._timescale = 1000;\\n        this._duration = 0;  // int32, in milliseconds\\n        this._durationOverrided = false;\\n        this._referenceFrameRate = {\\n            fixed: true,\\n            fps: 23.976,\\n            fps_num: 23976,\\n            fps_den: 1000\\n        };\\n\\n        this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\\n\\n        this._mpegSamplingRates = [\\n            96000, 88200, 64000, 48000, 44100, 32000,\\n            24000, 22050, 16000, 12000, 11025, 8000, 7350\\n        ];\\n\\n        this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\\n        this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\\n        this._mpegAudioV25SampleRateTable = [11025, 12000, 8000,  0];\\n\\n        this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\\n        this._mpegAudioL2BitRateTable = [0, 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\\n        this._mpegAudioL3BitRateTable = [0, 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, -1];\\n\\n        this._videoTrack = {type: 'video', id: 1, sequenceNumber: 0, samples: [], length: 0};\\n        this._audioTrack = {type: 'audio', id: 2, sequenceNumber: 0, samples: [], length: 0};\\n\\n        this._littleEndian = (function () {\\n            let buf = new ArrayBuffer(2);\\n            (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\\n            return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\\n        })();\\n\\n\\n        this.bytePos = 0;\\n\\n        this._config = defaultConfig;\\n\\n       // this._emitter = new EventEmitter();\\n        this._remuxer = new mp4_remuxer(this._config);\\n        this._remuxer.onInitSegment = (type, initSegment) =>{\\n            postMessage([TransmuxingEvents.INIT_SEGMENT, type, initSegment]);\\n        }\\n\\n\\n        this._remuxer.onMediaSegment = (type, mediaSegment) => {\\n            logger.d(this.TAG, \\\"_onRemuxerMediaSegmentArrival\\\");\\n            postMessage([TransmuxingEvents.MEDIA_SEGMENT, type, mediaSegment]);\\n        }\\n\\n        this._onDataAvailable = (audioTrack, videoTrack) =>{\\n            logger.d(this.TAG, \\\"_onDataAvailable\\\");\\n            this._remuxer.remux(audioTrack, videoTrack);\\n        }\\n\\n        this._onTrackMetadata = (type, metadata)=>{\\n            logger.d(this.TAG, \\\"_onTrackMetadata\\\");\\n            this._remuxer._onTrackMetadataReceived(type, metadata);\\n        }\\n    }\\n\\n\\n\\n\\n    destroy() {\\n        if (this._remuxer) {\\n            this._remuxer.destroy();\\n            this._remuxer = null;\\n        }\\n\\n        this._mediaInfo = null;\\n        this._metadata = null;\\n        this._audioMetadata = null;\\n        this._videoMetadata = null;\\n        this._videoTrack = null;\\n        this._audioTrack = null;\\n\\n        this._onError = null;\\n        this._onMediaInfo = null;\\n        this._onMetaDataArrived = null;\\n        this._onScriptDataArrived = null;\\n        this._onTrackMetadata = null;\\n        this._onDataAvailable = null;\\n    }\\n\\n    get onMediaInfo() {\\n        return this._onMediaInfo;\\n    }\\n\\n    set onMediaInfo(callback) {\\n        this._onMediaInfo = callback;\\n    }\\n\\n    get onMetaDataArrived() {\\n        return this._onMetaDataArrived;\\n    }\\n\\n    set onMetaDataArrived(callback) {\\n        this._onMetaDataArrived = callback;\\n    }\\n\\n    get onScriptDataArrived() {\\n        return this._onScriptDataArrived;\\n    }\\n\\n    set onScriptDataArrived(callback) {\\n        this._onScriptDataArrived = callback;\\n    }\\n\\n    // prototype: function(type: number, info: string): void\\n    get onError() {\\n        return this._onError;\\n    }\\n\\n    set onError(callback) {\\n        this._onError = callback;\\n    }\\n    /*\\n    get onDataAvailable() {\\n        return this._onDataAvailable;\\n    }\\n\\n    set onDataAvailable(callback) {\\n        this._onDataAvailable = callback;\\n    }\\n\\n    get timestampBase() {\\n        return this._timestampBase;\\n    }\\n\\n    set timestampBase(base) {\\n        this._timestampBase = base;\\n    }\\n\\n    get overridedDuration() {\\n        return this._duration;\\n    }\\n\\n    // Force-override media duration. Must be in milliseconds, int32\\n    set overridedDuration(duration) {\\n        this._durationOverrided = true;\\n        this._duration = duration;\\n        this._mediaInfo.duration = duration;\\n    }\\n\\n    // Force-override audio track present flag, boolean\\n    set overridedHasAudio(hasAudio) {\\n        this._hasAudioFlagOverrided = true;\\n        this._hasAudio = hasAudio;\\n        this._mediaInfo.hasAudio = hasAudio;\\n    }\\n\\n    // Force-override video track present flag, boolean\\n    set overridedHasVideo(hasVideo) {\\n        this._hasVideoFlagOverrided = true;\\n        this._hasVideo = hasVideo;\\n        this._mediaInfo.hasVideo = hasVideo;\\n    }\\n\\n    resetMediaInfo() {\\n        this._mediaInfo = new MediaInfo();\\n    }*/\\n\\n    _isInitialMetadataDispatched() {\\n        if (this._hasAudio && this._hasVideo) {  // both audio & video\\n            return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\\n        }\\n        if (this._hasAudio && !this._hasVideo) {  // audio only\\n            return this._audioInitialMetadataDispatched;\\n        }\\n        if (!this._hasAudio && this._hasVideo) {  // video only\\n            return this._videoInitialMetadataDispatched;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     *\\n     * @param {RTMPMessage} msg\\n     */\\n    handleMediaMessage(msg) {\\n        logger.d(this.TAG, \\\"handleMediaMessage\\\", msg.getMessageType());\\n        if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\\n            throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\\n        }\\n\\n        this._dispatch = true;\\n\\n        let tagType = msg.getMessageType();\\n        let timestamp = msg.getTimestamp();\\n        let streamId = msg.getMessageStreamID()\\n        if (streamId !== 0) {\\n            logger.w(this.TAG, 'Meet tag which has StreamID != 0!');\\n        }\\n\\n        logger.d(this.TAG, msg);\\n\\n        switch (tagType) {\\n            case 8:  // Audio\\n                this._parseAudioData(msg.getPayload(), timestamp);\\n                break;\\n            case 9:  // Video\\n                this._parseVideoData(msg.getPayload(), timestamp, this.bytePos);\\n                break;\\n            case 18:  // ScriptDataObject\\n                this._parseScriptData(msg.getPayload());\\n                break;\\n        }\\n\\n        this.bytePos += msg.getMessageLength() + 11 +1;\\n\\n        // dispatch parsed frames to consumer (typically, the remuxer)\\n        if (this._isInitialMetadataDispatched()) {\\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\\n                logger.i(this.TAG, \\\"sedn2\\\");\\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\\n            }\\n        }\\n\\n        return;\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} payload\\n     * @private\\n     */\\n    _parseScriptData(payload) {\\n        let scriptData = amf_parser.parseScriptData(payload);\\n\\n        if (scriptData.hasOwnProperty('onMetaData')) {\\n            if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\\n                logger.w(this.TAG, 'Invalid onMetaData structure!');\\n                return;\\n            }\\n            if (this._metadata) {\\n                logger.w(this.TAG, 'Found another onMetaData tag!');\\n            }\\n            this._metadata = scriptData;\\n            let onMetaData = this._metadata.onMetaData;\\n\\n            if (this._onMetaDataArrived) {\\n                this._onMetaDataArrived(Object.assign({}, onMetaData));\\n            }\\n\\n            if (typeof onMetaData.hasAudio === 'boolean') {  // hasAudio\\n                if (this._hasAudioFlagOverrided === false) {\\n                    this._hasAudio = onMetaData.hasAudio;\\n                    this._mediaInfo.hasAudio = this._hasAudio;\\n                }\\n            }\\n            if (typeof onMetaData.hasVideo === 'boolean') {  // hasVideo\\n                if (this._hasVideoFlagOverrided === false) {\\n                    this._hasVideo = onMetaData.hasVideo;\\n                    this._mediaInfo.hasVideo = this._hasVideo;\\n                }\\n            }\\n            if (typeof onMetaData.audiodatarate === 'number') {  // audiodatarate\\n                this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\\n            }\\n            if (typeof onMetaData.videodatarate === 'number') {  // videodatarate\\n                this._mediaInfo.videoDataRate = onMetaData.videodatarate;\\n            }\\n            if (typeof onMetaData.width === 'number') {  // width\\n                this._mediaInfo.width = onMetaData.width;\\n            }\\n            if (typeof onMetaData.height === 'number') {  // height\\n                this._mediaInfo.height = onMetaData.height;\\n            }\\n            if (typeof onMetaData.duration === 'number') {  // duration\\n                if (!this._durationOverrided) {\\n                    let duration = Math.floor(onMetaData.duration * this._timescale);\\n                    this._duration = duration;\\n                    this._mediaInfo.duration = duration;\\n                }\\n            } else {\\n                this._mediaInfo.duration = 0;\\n            }\\n            if (typeof onMetaData.framerate === 'number') {  // framerate\\n                let fps_num = Math.floor(onMetaData.framerate * 1000);\\n                if (fps_num > 0) {\\n                    let fps = fps_num / 1000;\\n                    this._referenceFrameRate.fixed = true;\\n                    this._referenceFrameRate.fps = fps;\\n                    this._referenceFrameRate.fps_num = fps_num;\\n                    this._referenceFrameRate.fps_den = 1000;\\n                    this._mediaInfo.fps = fps;\\n                }\\n            }\\n            if (typeof onMetaData.keyframes === 'object') {  // keyframes\\n                this._mediaInfo.hasKeyframesIndex = true;\\n                let keyframes = onMetaData.keyframes;\\n                this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\\n                onMetaData.keyframes = null;  // keyframes has been extracted, remove it\\n            } else {\\n                this._mediaInfo.hasKeyframesIndex = false;\\n            }\\n            this._dispatch = false;\\n            this._mediaInfo.metadata = onMetaData;\\n            logger.v(this.TAG, 'Parsed onMetaData');\\n            if (this._mediaInfo.isComplete()) {\\n                this._onMediaInfo(this._mediaInfo);\\n            }\\n        }\\n\\n        if (Object.keys(scriptData).length > 0) {\\n            if (this._onScriptDataArrived) {\\n                this._onScriptDataArrived(Object.assign({}, scriptData));\\n            }\\n        }\\n    }\\n\\n    _parseKeyframesIndex(keyframes) {\\n        let times = [];\\n        let filepositions = [];\\n\\n        // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\\n        for (let i = 1; i < keyframes.times.length; i++) {\\n            let time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\\n            times.push(time);\\n            filepositions.push(keyframes.filepositions[i]);\\n        }\\n\\n        return {\\n            times: times,\\n            filepositions: filepositions\\n        };\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} payload\\n     * @param tagTimestamp\\n     * @private\\n     */\\n    _parseAudioData(payload, tagTimestamp) {\\n        logger.d(this.TAG, \\\"_parseAudioData\\\", tagTimestamp);\\n        if (payload.length <= 1) {\\n            logger.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\\n            return;\\n        }\\n\\n        if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\\n            // If hasAudio: false indicated explicitly in MediaDataSource,\\n            // Ignore all the audio packets\\n            return;\\n        }\\n\\n        let le = this._littleEndian;\\n        let v = new DataView(payload.buffer);\\n\\n        let soundSpec = v.getUint8(0);\\n\\n        let soundFormat = soundSpec >>> 4;\\n        if (soundFormat !== 2 && soundFormat !== 10) {  // MP3 or AAC\\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\\n            return;\\n        }\\n\\n        let soundRate = 0;\\n        let soundRateIndex = (soundSpec & 12) >>> 2;\\n        if (soundRateIndex >= 0 && soundRateIndex <= 4) {\\n            soundRate = this._flvSoundRateTable[soundRateIndex];\\n        } else {\\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\\n            return;\\n        }\\n\\n        let soundSize = (soundSpec & 2) >>> 1;  // unused\\n        let soundType = (soundSpec & 1);\\n\\n\\n        let meta = this._audioMetadata;\\n        let track = this._audioTrack;\\n\\n        if (!meta) {\\n            if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\\n                this._hasAudio = true;\\n                this._mediaInfo.hasAudio = true;\\n            }\\n\\n            // initial metadata\\n            meta = this._audioMetadata = {};\\n            meta.type = 'audio';\\n            meta.id = track.id;\\n            meta.timescale = this._timescale;\\n            meta.duration = this._duration;\\n            meta.audioSampleRate = soundRate;\\n            meta.channelCount = (soundType === 0 ? 1 : 2);\\n        }\\n\\n        if (soundFormat === 10) {  // AAC\\n            let aacData = this._parseAACAudioData(payload.slice(1));\\n            if (aacData == undefined) {\\n                return;\\n            }\\n\\n            if (aacData.packetType === 0) {  // AAC sequence header (AudioSpecificConfig)\\n                if (meta.config) {\\n                    logger.w(this.TAG, 'Found another AudioSpecificConfig!');\\n                }\\n                let misc = aacData.data;\\n                meta.audioSampleRate = misc.samplingRate;\\n                meta.channelCount = misc.channelCount;\\n                meta.codec = misc.codec;\\n                meta.originalCodec = misc.originalCodec;\\n                meta.config = misc.config;\\n                // The decode result of an aac sample is 1024 PCM samples\\n                meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\\n                logger.v(this.TAG, 'Parsed AudioSpecificConfig');\\n\\n                if (this._isInitialMetadataDispatched()) {\\n                    // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\\n                    if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\\n                        this._onDataAvailable(this._audioTrack, this._videoTrack);\\n                    }\\n                } else {\\n                    this._audioInitialMetadataDispatched = true;\\n                }\\n                // then notify new metadata\\n                this._dispatch = false;\\n                logger.i(this.TAG, \\\"ON!\\\");\\n                this._onTrackMetadata('audio', meta);\\n\\n                let mi = this._mediaInfo;\\n                mi.audioCodec = meta.originalCodec;\\n                mi.audioSampleRate = meta.audioSampleRate;\\n                mi.audioChannelCount = meta.channelCount;\\n                if (mi.hasVideo) {\\n                    if (mi.videoCodec != null) {\\n                        mi.mimeType = 'video/x-flv; codecs=\\\"' + mi.videoCodec + ',' + mi.audioCodec + '\\\"';\\n                    }\\n                } else {\\n                    mi.mimeType = 'video/x-flv; codecs=\\\"' + mi.audioCodec + '\\\"';\\n                }\\n                if (mi.isComplete()) {\\n                    this._onMediaInfo(mi);\\n                }\\n            } else if (aacData.packetType === 1) {  // AAC raw frame data\\n                let dts = this._timestampBase + tagTimestamp;\\n                let aacSample = {unit: aacData.data, length: aacData.data.byteLength, dts: dts, pts: dts};\\n                track.samples.push(aacSample);\\n                track.length += aacData.data.length;\\n            } else {\\n                logger.e(this.TAG, `Flv: Unsupported AAC data type ${aacData.packetType}`);\\n            }\\n        } else if (soundFormat === 2) {  // MP3\\n            if (!meta.codec) {\\n                // We need metadata for mp3 audio track, extract info from frame header\\n                let misc = this._parseMP3AudioData(payload.slice(1), true);\\n                if (misc == undefined) {\\n                    return;\\n                }\\n                meta.audioSampleRate = misc.samplingRate;\\n                meta.channelCount = misc.channelCount;\\n                meta.codec = misc.codec;\\n                meta.originalCodec = misc.originalCodec;\\n                // The decode result of an mp3 sample is 1152 PCM samples\\n                meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\\n                logger.v(this.TAG, 'Parsed MPEG Audio Frame Header');\\n\\n                this._audioInitialMetadataDispatched = true;\\n                this._onTrackMetadata('audio', meta);\\n\\n                let mi = this._mediaInfo;\\n                mi.audioCodec = meta.codec;\\n                mi.audioSampleRate = meta.audioSampleRate;\\n                mi.audioChannelCount = meta.channelCount;\\n                mi.audioDataRate = misc.bitRate;\\n                if (mi.hasVideo) {\\n                    if (mi.videoCodec != null) {\\n                        mi.mimeType = 'video/x-flv; codecs=\\\"' + mi.videoCodec + ',' + mi.audioCodec + '\\\"';\\n                    }\\n                } else {\\n                    mi.mimeType = 'video/x-flv; codecs=\\\"' + mi.audioCodec + '\\\"';\\n                }\\n                if (mi.isComplete()) {\\n                    this._onMediaInfo(mi);\\n                }\\n            }\\n\\n            // This packet is always a valid audio packet, extract it\\n            let data = this._parseMP3AudioData(payload.slice(1), false);\\n            if (data == undefined) {\\n                return;\\n            }\\n            let dts = this._timestampBase + tagTimestamp;\\n            let mp3Sample = {unit: data, length: data.byteLength, dts: dts, pts: dts};\\n            track.samples.push(mp3Sample);\\n            track.length += data.length;\\n        }\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} payload\\n     * @returns {{}}\\n     * @private\\n     */\\n    _parseAACAudioData(payload) {\\n        if (payload.length <= 1) {\\n            logger.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\\n            return;\\n        }\\n\\n        let result = {};\\n\\n        result.packetType = payload[0];\\n\\n        if (payload[0] === 0) {\\n            result.data = this._parseAACAudioSpecificConfig(payload.slice(1));\\n        } else {\\n            result.data = payload.subarray(1);\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} array\\n     * @returns {{channelCount: number, codec: string, originalCodec: string, samplingRate: *, config: any[]}}\\n     * @private\\n     */\\n    _parseAACAudioSpecificConfig(array) {\\n        let config = null;\\n\\n        /* Audio Object Type:\\n           0: Null\\n           1: AAC Main\\n           2: AAC LC\\n           3: AAC SSR (Scalable Sample Rate)\\n           4: AAC LTP (Long Term Prediction)\\n           5: HE-AAC / SBR (Spectral Band Replication)\\n           6: AAC Scalable\\n        */\\n\\n        let audioObjectType = 0;\\n        let originalAudioObjectType = 0;\\n        let audioExtensionObjectType = null;\\n        let samplingIndex = 0;\\n        let extensionSamplingIndex = null;\\n\\n        // 5 bits\\n        audioObjectType = originalAudioObjectType = array[0] >>> 3;\\n        // 4 bits\\n        samplingIndex = ((array[0] & 0x07) << 1) | (array[1] >>> 7);\\n        if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\\n            return;\\n        }\\n\\n        let samplingFrequence = this._mpegSamplingRates[samplingIndex];\\n\\n        // 4 bits\\n        let channelConfig = (array[1] & 0x78) >>> 3;\\n        if (channelConfig < 0 || channelConfig >= 8) {\\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\\n            return;\\n        }\\n\\n        if (audioObjectType === 5) {  // HE-AAC?\\n            // 4 bits\\n            extensionSamplingIndex = ((array[1] & 0x07) << 1) | (array[2] >>> 7);\\n            // 5 bits\\n            audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\\n        }\\n\\n        // workarounds for various browsers\\n        let userAgent = self.navigator.userAgent.toLowerCase();\\n\\n        if (userAgent.indexOf('firefox') !== -1) {\\n            // firefox: use SBR (HE-AAC) if freq less than 24kHz\\n            if (samplingIndex >= 6) {\\n                audioObjectType = 5;\\n                config = new Array(4);\\n                extensionSamplingIndex = samplingIndex - 3;\\n            } else {  // use LC-AAC\\n                audioObjectType = 2;\\n                config = new Array(2);\\n                extensionSamplingIndex = samplingIndex;\\n            }\\n        } else if (userAgent.indexOf('android') !== -1) {\\n            // android: always use LC-AAC\\n            audioObjectType = 2;\\n            config = new Array(2);\\n            extensionSamplingIndex = samplingIndex;\\n        } else {\\n            // for other browsers, e.g. chrome...\\n            // Always use HE-AAC to make it easier to switch aac codec profile\\n            audioObjectType = 5;\\n            extensionSamplingIndex = samplingIndex;\\n            config = new Array(4);\\n\\n            if (samplingIndex >= 6) {\\n                extensionSamplingIndex = samplingIndex - 3;\\n            } else if (channelConfig === 1) {  // Mono channel\\n                audioObjectType = 2;\\n                config = new Array(2);\\n                extensionSamplingIndex = samplingIndex;\\n            }\\n        }\\n\\n        config[0]  = audioObjectType << 3;\\n        config[0] |= (samplingIndex & 0x0F) >>> 1;\\n        config[1]  = (samplingIndex & 0x0F) << 7;\\n        config[1] |= (channelConfig & 0x0F) << 3;\\n        if (audioObjectType === 5) {\\n            config[1] |= ((extensionSamplingIndex & 0x0F) >>> 1);\\n            config[2]  = (extensionSamplingIndex & 0x01) << 7;\\n            // extended audio object type: force to 2 (LC-AAC)\\n            config[2] |= (2 << 2);\\n            config[3]  = 0;\\n        }\\n\\n        return {\\n            config: config,\\n            samplingRate: samplingFrequence,\\n            channelCount: channelConfig,\\n            codec: 'mp4a.40.' + audioObjectType,\\n            originalCodec: 'mp4a.40.' + originalAudioObjectType\\n        };\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} array\\n     * @param requestHeader\\n     * @returns {*}\\n     * @private\\n     */\\n    _parseMP3AudioData(array, requestHeader) {\\n        if (array.length < 4) {\\n            logger.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\\n            return;\\n        }\\n\\n        let result = null;\\n\\n        if (requestHeader) {\\n            if (array[0] !== 0xFF) {\\n                return;\\n            }\\n            let ver = (array[1] >>> 3) & 0x03;\\n            let layer = (array[1] & 0x06) >> 1;\\n\\n            let bitrate_index = (array[2] & 0xF0) >>> 4;\\n            let sampling_freq_index = (array[2] & 0x0C) >>> 2;\\n\\n            let channel_mode = (array[3] >>> 6) & 0x03;\\n            let channel_count = channel_mode !== 3 ? 2 : 1;\\n\\n            let sample_rate = 0;\\n            let bit_rate = 0;\\n            let object_type = 34;  // Layer-3, listed in MPEG-4 Audio Object Types\\n\\n            let codec = 'mp3';\\n\\n            switch (ver) {\\n                case 0:  // MPEG 2.5\\n                    sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\\n                    break;\\n                case 2:  // MPEG 2\\n                    sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\\n                    break;\\n                case 3:  // MPEG 1\\n                    sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\\n                    break;\\n            }\\n\\n            switch (layer) {\\n                case 1:  // Layer 3\\n                    object_type = 34;\\n                    if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\\n                        bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\\n                    }\\n                    break;\\n                case 2:  // Layer 2\\n                    object_type = 33;\\n                    if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\\n                        bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\\n                    }\\n                    break;\\n                case 3:  // Layer 1\\n                    object_type = 32;\\n                    if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\\n                        bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\\n                    }\\n                    break;\\n            }\\n\\n            result = {\\n                bitRate: bit_rate,\\n                samplingRate: sample_rate,\\n                channelCount: channel_count,\\n                codec: codec,\\n                originalCodec: codec\\n            };\\n        } else {\\n            result = array;\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} payload\\n     * @param tagTimestamp\\n     * @param tagPosition\\n     * @private\\n     */\\n    _parseVideoData(payload, tagTimestamp, tagPosition) {\\n        if (payload.length <= 1) {\\n            logger.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\\n            return;\\n        }\\n\\n        if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\\n            // If hasVideo: false indicated explicitly in MediaDataSource,\\n            // Ignore all the video packets\\n            return;\\n        }\\n\\n        let spec = payload[0];\\n\\n        let frameType = (spec & 240) >>> 4;\\n        let codecId = spec & 15;\\n\\n        if (codecId !== 7) {\\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, `Flv: Unsupported codec in video frame: ${codecId}`);\\n            return;\\n        }\\n\\n        this._parseAVCVideoPacket(payload.slice(1), tagTimestamp, tagPosition, frameType);\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} payload\\n     * @param tagTimestamp\\n     * @param tagPosition\\n     * @param frameType\\n     * @private\\n     */\\n    _parseAVCVideoPacket(payload, tagTimestamp, tagPosition, frameType) {\\n        if (payload.length < 4) {\\n            logger.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\\n            return;\\n        }\\n\\n        let le = this._littleEndian;\\n        let v = new DataView(payload.buffer);\\n\\n        let packetType = v.getUint8(0);\\n        let cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\\n        let cts = (cts_unsigned << 8) >> 8;  // convert to 24-bit signed int\\n\\n        if (packetType === 0) {  // AVCDecoderConfigurationRecord\\n            this._parseAVCDecoderConfigurationRecord(payload.slice(4));\\n        } else if (packetType === 1) {  // One or more Nalus\\n            this._parseAVCVideoData(payload.slice(4), tagTimestamp, tagPosition, frameType, cts);\\n        } else if (packetType === 2) {\\n            // empty, AVC end of sequence\\n        } else {\\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid video packet type ${packetType}`);\\n            return;\\n        }\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} payload\\n     * @private\\n     */\\n    _parseAVCDecoderConfigurationRecord(payload) {\\n        if (payload.length < 7) {\\n            logger.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\\n            return;\\n        }\\n\\n        let meta = this._videoMetadata;\\n        let track = this._videoTrack;\\n        let le = this._littleEndian;\\n        let v = new DataView(payload.buffer);\\n\\n        if (!meta) {\\n            if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\\n                this._hasVideo = true;\\n                this._mediaInfo.hasVideo = true;\\n            }\\n\\n            meta = this._videoMetadata = {};\\n            meta.type = 'video';\\n            meta.id = track.id;\\n            meta.timescale = this._timescale;\\n            meta.duration = this._duration;\\n\\n        } else {\\n            if (typeof meta.avcc !== 'undefined') {\\n                logger.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\\n            }\\n        }\\n\\n        let version = v.getUint8(0);  // configurationVersion\\n        let avcProfile = v.getUint8(1);  // avcProfileIndication\\n        let profileCompatibility = v.getUint8(2);  // profile_compatibility\\n        let avcLevel = v.getUint8(3);  // AVCLevelIndication\\n\\n        if (version !== 1 || avcProfile === 0) {\\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\\n            return;\\n        }\\n\\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1;  // lengthSizeMinusOne\\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {  // holy shit!!!\\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`);\\n            return;\\n        }\\n\\n        let spsCount = v.getUint8(5) & 31;  // numOfSequenceParameterSets\\n        if (spsCount === 0) {\\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\\n            return;\\n        } else if (spsCount > 1) {\\n            logger.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: SPS Count = ${spsCount}`);\\n        }\\n\\n        let offset = 6;\\n\\n        for (let i = 0; i < spsCount; i++) {\\n            let len = v.getUint16(offset, !le);  // sequenceParameterSetLength\\n            offset += 2;\\n\\n            if (len === 0) {\\n                continue;\\n            }\\n\\n            // Notice: Nalu without startcode header (00 00 00 01)\\n            let sps = new Uint8Array(payload.slice(offset, offset + len));\\n            offset += len;\\n\\n            let config = sps_parser.parseSPS(sps);\\n            if (i !== 0) {\\n                // ignore other sps's config\\n                continue;\\n            }\\n\\n            meta.codecWidth = config.codec_size.width;\\n            meta.codecHeight = config.codec_size.height;\\n            meta.presentWidth = config.present_size.width;\\n            meta.presentHeight = config.present_size.height;\\n\\n            meta.profile = config.profile_string;\\n            meta.level = config.level_string;\\n            meta.bitDepth = config.bit_depth;\\n            meta.chromaFormat = config.chroma_format;\\n            meta.sarRatio = config.sar_ratio;\\n            meta.frameRate = config.frame_rate;\\n\\n            if (config.frame_rate.fixed === false ||\\n                config.frame_rate.fps_num === 0 ||\\n                config.frame_rate.fps_den === 0) {\\n                meta.frameRate = this._referenceFrameRate;\\n            }\\n\\n            let fps_den = meta.frameRate.fps_den;\\n            let fps_num = meta.frameRate.fps_num;\\n            meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\\n\\n            let codecArray = sps.subarray(1, 4);\\n            let codecString = 'avc1.';\\n            for (let j = 0; j < 3; j++) {\\n                let h = codecArray[j].toString(16);\\n                if (h.length < 2) {\\n                    h = '0' + h;\\n                }\\n                codecString += h;\\n            }\\n            meta.codec = codecString;\\n\\n            let mi = this._mediaInfo;\\n            mi.width = meta.codecWidth;\\n            mi.height = meta.codecHeight;\\n            mi.fps = meta.frameRate.fps;\\n            mi.profile = meta.profile;\\n            mi.level = meta.level;\\n            mi.refFrames = config.ref_frames;\\n            mi.chromaFormat = config.chroma_format_string;\\n            mi.sarNum = meta.sarRatio.width;\\n            mi.sarDen = meta.sarRatio.height;\\n            mi.videoCodec = codecString;\\n\\n            if (mi.hasAudio) {\\n                if (mi.audioCodec != null) {\\n                    mi.mimeType = 'video/x-flv; codecs=\\\"' + mi.videoCodec + ',' + mi.audioCodec + '\\\"';\\n                }\\n            } else {\\n                mi.mimeType = 'video/x-flv; codecs=\\\"' + mi.videoCodec + '\\\"';\\n            }\\n            if (mi.isComplete()) {\\n                this._onMediaInfo(mi);\\n            }\\n        }\\n\\n        let ppsCount = v.getUint8(offset);  // numOfPictureParameterSets\\n        if (ppsCount === 0) {\\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\\n            return;\\n        } else if (ppsCount > 1) {\\n            logger.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: PPS Count = ${ppsCount}`);\\n        }\\n\\n        offset++;\\n\\n        for (let i = 0; i < ppsCount; i++) {\\n            let len = v.getUint16(offset, !le);  // pictureParameterSetLength\\n            offset += 2;\\n\\n            if (len === 0) {\\n                continue;\\n            }\\n\\n            // pps is useless for extracting video information\\n            offset += len;\\n        }\\n\\n        meta.avcc = new Uint8Array(payload.length);\\n        meta.avcc.set(new Uint8Array(payload), 0);\\n        logger.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\\n\\n        if (this._isInitialMetadataDispatched()) {\\n            // flush parsed frames\\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\\n            }\\n        } else {\\n            this._videoInitialMetadataDispatched = true;\\n        }\\n        // notify new metadata\\n        this._dispatch = false;\\n        this._onTrackMetadata('video', meta);\\n    }\\n\\n    _parseAVCVideoData(payload, tagTimestamp, tagPosition, frameType, cts) {\\n        logger.v(this.TAG, tagTimestamp, tagPosition, this._timestampBase);\\n\\n        let le = this._littleEndian;\\n        let v = new DataView(payload.buffer);\\n\\n        let units = [], length = 0;\\n\\n        let dataSize = payload.length;\\n\\n        let offset = 0;\\n        const lengthSize = this._naluLengthSize;\\n        let dts = this._timestampBase + tagTimestamp;\\n        let keyframe = (frameType === 1);  // from FLV Frame Type constants\\n\\n        while (offset < dataSize) {\\n            if (offset + 4 >= dataSize) {\\n                logger.w(this.TAG, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\\n                break;  // data not enough for next Nalu\\n            }\\n            // Nalu with length-header (AVC1)\\n            let naluSize = v.getUint32(offset, !le);  // Big-Endian read\\n            if (lengthSize === 3) {\\n                naluSize >>>= 8;\\n            }\\n            if (naluSize > dataSize - lengthSize) {\\n                logger.w(this.TAG, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\\n                return;\\n            }\\n\\n            let unitType = v.getUint8(offset + lengthSize) & 0x1F;\\n\\n            if (unitType === 5) {  // IDR\\n                keyframe = true;\\n            }\\n\\n            let data = new Uint8Array(payload.slice(offset, offset + lengthSize + naluSize));\\n            let unit = {type: unitType, data: data};\\n            units.push(unit);\\n            length += data.byteLength;\\n\\n            offset += lengthSize + naluSize;\\n        }\\n\\n        if (units.length) {\\n            let track = this._videoTrack;\\n            let avcSample = {\\n                units: units,\\n                length: length,\\n                isKeyframe: keyframe,\\n                dts: dts,\\n                cts: cts,\\n                pts: (dts + cts)\\n            };\\n            if (keyframe) {\\n                avcSample.fileposition = tagPosition;\\n            }\\n            track.samples.push(avcSample);\\n            track.length += length;\\n        }\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_RTMPMediaMessageHandler = (RTMPMediaMessageHandler);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/AMF0Object.js\\n\\n\\n\\nclass AMF0Object {\\n\\tTAG = \\\"AMF0Object\\\";\\n\\n\\tdata;\\n\\n    params;\\n\\n\\t/**\\n\\t *\\n\\t * @param {Object} params\\n\\t */\\n\\tconstructor(params) {\\n\\t\\tif(params) {\\n            this.params = params;\\n\\t\\t\\tlogger.d(this.TAG, \\\"cmd: \\\" + this.params[0]);\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     *\\n     * @param {Uint8Array} data\\n     * @returns {*[]}\\n     */\\n\\tparseAMF0(data) {\\n\\t\\tthis.data = Array.from(data);\\n\\t\\tlet obj = [];\\n\\n\\t\\twhile (this.data.length > 0) {\\n\\t\\t\\tconst var_type = this.data.shift();\\n\\n\\t\\t\\tswitch(var_type) {\\n\\t\\t\\tcase 0x00: // Number\\n\\t\\t\\t\\tobj.push(_byteArrayToNumber(this.data.slice(0, 8)));\\n\\t\\t\\t\\tthis.data = this.data.slice(8);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 0x01: // boolean\\n\\t\\t\\t\\tif (this.data.shift() === 0) {\\n\\t\\t\\t\\t\\tobj.push(false);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tobj.push(true);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 0x02: // String\\n\\t\\t\\t\\tlet len = (this.data[0] << 8) | (this.data[1]);\\n\\t\\t\\t\\tthis.data = this.data.slice(2);\\n\\n\\t\\t\\t\\tobj.push(_byteArrayToString(this.data.slice(0, len)));\\n\\t\\t\\t\\tthis.data = this.data.slice(len);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 0x03: // AMF encoded object\\n\\t\\t\\t\\tobj.push(this._parseAMF0Object());\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 0x05: // NUll\\n                obj.push(null);\\n\\t\\t\\t\\tbreak;\\n\\n            default:\\n                logger.w(this.TAG, \\\"var_type: \\\" + var_type + \\\" not yet implemented\\\");\\n                break;\\n\\t\\t\\t}\\n\\t\\t}\\n        this.params = obj;\\n\\t\\treturn obj;\\n\\t}\\n\\n\\t_parseAMF0Object() {\\n\\t\\tlet o2 = {};\\n\\n\\t\\twhile (this.data.length > 0) {\\n\\t\\t\\tlet keylen = (this.data[0] << 8) | (this.data[1]); this.data = this.data.slice(2);\\n\\n\\t\\t\\t// Object end marker\\n\\t\\t\\tif (keylen === 0 && this.data[0] === 9) {\\n\\t\\t\\t\\tthis.data = this.data.slice(1);\\n\\t\\t\\t\\treturn o2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet keyName = _byteArrayToString(this.data.slice(0, keylen)); this.data = this.data.slice(keylen);\\n\\n\\t\\t\\tconst var_type = this.data.shift();\\n\\n\\t\\t\\tswitch(var_type) {\\n            case 0x00: // Number\\n                o2[keyName] = _byteArrayToNumber(this.data.slice(0, 8));\\n                this.data = this.data.slice(8);\\n                break;\\n\\n            case 0x01: // boolean\\n                if (this.data.shift() === 0) {\\n                    o2[keyName] = false;\\n                } else {\\n                    o2[keyName] = true;\\n                }\\n\\n                break;\\n\\n            case 0x02: // String\\n                let len = (this.data[0] << 8) | (this.data[1]);\\n                this.data = this.data.slice(2);\\n\\n                o2[keyName] = _byteArrayToString(this.data.slice(0, len));\\n                this.data = this.data.slice(len);\\n                break;\\n\\n            case 0x05:\\n                o2[keyName] = null;\\n                break;\\n\\n            default:\\n\\t\\t\\t\\tlogger.w(this.TAG, \\\"var_type: \\\" + var_type + \\\" not yet implemented\\\");\\n                break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn o2;\\n\\t}\\n\\n    /**\\n     *\\n     * @returns {Uint8Array}\\n     */\\n\\tgetBytes() {\\n\\t\\tlet bytes = [];\\n\\n        for(let i = 0; i < this.params.length; i++) {\\n            const param = this.params[i];\\n\\n            switch(typeof param){\\n            case \\\"string\\\":\\n                // Command\\n                bytes.push(0x02); // String\\n                bytes.push(param.length >>> 8);\\n                bytes.push(param.length);\\n                bytes = bytes.concat(_stringToByteArray(param));\\n                break;\\n\\n            case \\\"number\\\":\\n                // TransactionID\\n                bytes.push(0x00); // Number\\n                bytes = bytes.concat(_numberToByteArray(param));\\n                break;\\n\\n            case \\\"object\\\":\\n                // Command Object\\n                bytes.push(0x03); // Object\\n\\n                for (let key in param) {\\n                    let value = param[key];\\n                    let keylength = key.length;\\n\\n                    bytes.push(keylength >>> 8);\\n                    bytes.push(keylength);\\n                    bytes = bytes.concat(_stringToByteArray(key));\\n\\n                    switch(typeof value) {\\n                    case \\\"object\\\":\\n                        if (value == null) {\\n                            bytes.push(0x05); // Null\\n                        }\\n\\n                        break;\\n\\n                    case \\\"string\\\":\\n                        const length = value.length;\\n                        bytes.push(0x02);\\n                        bytes.push(length >>> 8);\\n                        bytes.push(length);\\n                        bytes = bytes.concat(_stringToByteArray(value))\\n                        break;\\n\\n                    case \\\"number\\\":\\n                        bytes.push(0x00);\\n                        bytes = bytes.concat(_numberToByteArray(value))\\n                        break;\\n\\n                    case \\\"boolean\\\":\\n                        bytes.push(0x01);\\n                        if (value) bytes.push(0x01);\\n                        else bytes.push(0x00);\\n                        break;\\n\\n                    default:\\n\\t\\t\\t\\t\\t\\tlogger.w(this.TAG, typeof value, \\\" not yet implementd\\\");\\n                        break;\\n                    }\\n                }\\n\\n                bytes.push(0x00); // End Marker\\n                bytes.push(0x00);\\n                bytes.push(0x09);\\n                break;\\n\\n            case \\\"boolean\\\":\\n                bytes.push(0x01);\\n                if(param) bytes.push(0x01);\\n                else bytes.push(0x00);\\n                break;\\n\\n            default:\\n\\t\\t\\t\\tlogger.w(this.TAG, typeof param, \\\" not yet implementd\\\");\\n                break;\\n            }\\n        }\\n\\n\\t\\treturn new Uint8Array(bytes);\\n\\t}\\n\\n    getCommand(){\\n        return this.params[0];\\n    }\\n\\n    getTransactionId(){\\n        return this.params[1];\\n    }\\n\\n    getCommandObject(){\\n        return this.params[2];\\n    }\\n\\n    getAdditionalInfo(){\\n        return this.params[3];\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_AMF0Object = (AMF0Object);\\n\\n;// CONCATENATED MODULE: ./src/rtmp/RTMPMessageHandler.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Class for handling rtmp messages\\n */\\nclass RTMPMessageHandler {\\n    TAG = \\\"RTMPMessageHandler\\\";\\n\\n    paused = false;\\n    netconnections = {};\\n    chunk_stream_id = 2;\\n    trackedCommand = \\\"\\\";\\n    socket;\\n    current_stream_id;\\n\\n    /**\\n     *\\n     * @param {WebSocket} socket\\n     */\\n    constructor(socket) {\\n        this.socket = socket;\\n        this.chunk_parser = new rtmp_ChunkParser(this);\\n        this.media_handler = new rtmp_RTMPMediaMessageHandler();\\n\\n        this.media_handler.onError = (type, info)=>{\\n            logger.d(this.TAG, type, info);\\n            postMessage([\\\"onError\\\", type, info]);\\n        }\\n\\n        this.media_handler.onMediaInfo = (mediainfo)=>{\\n            logger.d(this.TAG, mediainfo);\\n            postMessage([\\\"onMediaInfo\\\", mediainfo]);\\n        }\\n\\n        this.media_handler.onMetaDataArrived = (metadata)=>{\\n            postMessage([\\\"onMetaDataArrived\\\", metadata]);\\n        }\\n\\n        this.media_handler.onScriptDataArrived= (data)=>{\\n            postMessage([\\\"onScriptDataArrived\\\", data]);\\n        }\\n\\n        this.media_handler.onScriptDataArrived= (data)=>{\\n            postMessage([\\\"onMetaDataArrived\\\", data]);\\n        }\\n\\n        this.media_handler.onScriptDataArrived= (data)=>{\\n            postMessage([\\\"onMetaDataArrived\\\", data]);\\n        }\\n    }\\n\\n    destroy(){\\n        this.media_handler.destroy();\\n        this.media_handler = null;\\n        this.chunk_parser = null\\n    }\\n\\n    /**\\n     *\\n     * @param {Uint8Array} data\\n     */\\n    parseChunk(data){\\n        logger.d(this.TAG, \\\"parseChunk: \\\" + data.length);\\n        this.chunk_parser.parseChunk(data);\\n    }\\n\\n    /**\\n     *\\n     * @param {RTMPMessage} msg\\n     */\\n    onMessage(msg){\\n        logger.d(this.TAG, \\\" onMessage: \\\" + msg.getMessageType() + \\\" StreamID:\\\" + msg.getMessageStreamID());\\n\\n        switch(msg.getMessageType()){\\n        case 1:         // PCM Set Chunk Size\\n        case 2:         // PCM Abort Message\\n        case 3:         // PCM Acknowledgement\\n        case 5:         // PCM Window Acknowledgement Size\\n        case 6:         // PCM Set Peer Bandwidth\\n            this.netconnections[msg.getMessageStreamID()].parseMessage(msg);\\n            break;\\n\\n        case 4:          // User Control Messages\\n            this._handleUserControlMessage(msg);\\n            break;\\n\\n        case 8:         // Audio Message\\n            logger.d(this.TAG, \\\"AUDIOFRAME: \\\", msg);\\n            this.media_handler.handleMediaMessage(msg);\\n            break;\\n\\n        case 9:         // Video Message\\n            logger.d(this.TAG, \\\"VIDEOFRAME: \\\", msg);\\n            this.media_handler.handleMediaMessage(msg);\\n            break;\\n\\n        case 18:        // Data Message AMF0\\n            logger.d(this.TAG, \\\"DATAFRAME: \\\", msg);\\n            this.media_handler.handleMediaMessage(msg);\\n            break;\\n\\n        case 19:        // Shared Object Message AMF0\\n            logger.d(this.TAG, \\\"SharedObjectMessage\\\", msg);\\n            break;\\n\\n        case 20:        // Command Message AMF0\\n            const command = new rtmp_AMF0Object();\\n            let cmd = command.parseAMF0(msg.getPayload());\\n\\n            logger.d(this.TAG, \\\"AMF0\\\", cmd);\\n\\n            switch(cmd[0]) {\\n            case \\\"_error\\\":\\n                logger.e(this.TAG, cmd);\\n                break;\\n\\n            case \\\"_result\\\":\\n                switch(this.trackedCommand){\\n                case \\\"connect\\\":\\n                    logger.d(this.TAG,\\\"got _result: \\\" + cmd[3].code);\\n                    if(cmd[3].code === \\\"NetConnection.Connect.Success\\\") {\\n                        postMessage([cmd[3].code]);\\n                        this.createStream(null);\\n                    }\\n                    break;\\n\\n                case \\\"createStream\\\":\\n                    logger.d(this.TAG,\\\"got _result: \\\" + cmd[3]);\\n                    if(cmd[3]) {\\n                        this.current_stream_id = cmd[4];\\n                        postMessage([\\\"RTMPStreamCreated\\\", cmd[3], cmd[4]]);\\n                    }\\n                    break;\\n\\n                case \\\"play\\\":\\n                    break;\\n\\n                case \\\"pause\\\":\\n                    break;\\n\\n                default:\\n                    logger.w(\\\"tracked command:\\\" + this.trackedCommand);\\n                    break;\\n                }\\n\\n                break;\\n\\n            case \\\"onStatus\\\":\\n                logger.d(this.TAG,\\\"onStatus: \\\" + cmd[3].code);\\n                postMessage([cmd[3].code]);\\n                break;\\n\\n            default:\\n                logger.w(this.TAG,\\\"CommandMessage \\\" + cmd[0] + \\\" not yet implemented\\\");\\n                break;\\n            }\\n\\n            break;\\n\\n        case 22:        // Aggregate Message\\n            break;\\n\\n        case 15:        // Data Message AMF3\\n        case 16:        // Shared Object Message AMF3\\n        case 17:        // Command Message AMF3\\n            logger.e(this.TAG,\\\"AMF3 is not yet implemented\\\");\\n            break;\\n\\n        default:\\n            logger.d(this.TAG,\\\"[MessageType: \\\" + rtmp_RTMPMessage.MessageTypes[msg.getMessageType()] + \\\"(\\\" + msg.getMessageType() + \\\")\\\");\\n            break;\\n\\n        }\\n    }\\n\\n    /**\\n     *\\n     * @param {Object} connectionParams\\n     */\\n    connect(connectionParams){\\n        const command = new rtmp_AMF0Object([\\n            \\\"connect\\\", 1, connectionParams\\n        ]);\\n\\n        this._sendCommand(3, command);\\n    }\\n\\n    /**\\n     *\\n     * @param {Object} options\\n     */\\n    createStream(options){\\n        const command = new rtmp_AMF0Object([\\n            \\\"createStream\\\", 1, options\\n        ]);\\n\\n        this._sendCommand(3, command);\\n    }\\n\\n    deleteStream(stream_id){\\n        const command = new rtmp_AMF0Object([\\n            \\\"deleteStream\\\", 1, null, stream_id\\n        ]);\\n\\n        this._sendCommand(3, command);\\n    }\\n\\n    /**\\n     *\\n     * @param {String} streamName\\n     */\\n    play(streamName){\\n        const command = new rtmp_AMF0Object([\\n            \\\"play\\\", 1, null, streamName\\n        ]);\\n\\n        this._sendCommand(3, command);\\n    }\\n\\n    stop(){\\n        this.deleteStream(this.current_stream_id);\\n    }\\n\\n    /**\\n     *\\n     * @param {boolean} enable\\n     */\\n    pause(enable){\\n        if(this.paused !== enable) {\\n            this.paused = enable;\\n\\n            const command = new rtmp_AMF0Object([\\n                \\\"pause\\\", 0, null, enable,0\\n            ]);\\n\\n            this._sendCommand(3, command);\\n        }\\n    }\\n\\n    receiveVideo(enable){\\n        const command = new rtmp_AMF0Object([\\n            \\\"receiveVideo\\\", 0, null, enable\\n        ]);\\n\\n        this._sendCommand(3, command);\\n    }\\n\\n    receiveAudio(enable){\\n        const command = new rtmp_AMF0Object([\\n            \\\"receiveAudio\\\", 0, null, enable\\n        ]);\\n\\n        this._sendCommand(3, command);\\n    }\\n\\n    /**\\n     *\\n     * @param {Number} csid\\n     * @param {AMF0Object} command\\n     * @private\\n     */\\n    _sendCommand(csid, command){\\n        logger.d(this.TAG, \\\"sendCommand:\\\", command);\\n\\n        this.trackedCommand = command.getCommand();\\n\\n        let msg = new rtmp_RTMPMessage(command.getBytes());\\n        msg.setMessageType(0x14);\\t\\t// AMF0 Command\\n        msg.setMessageStreamID(0);\\n\\n        const chunk = new rtmp_Chunk(msg);\\n        chunk.setChunkStreamID(csid);\\n\\n        let buf = chunk.getBytes();\\n\\n        this.netconnections[0] = new rtmp_NetConnection(0, this);\\n\\n        this.socket.send(buf);\\n    }\\n\\n    /**\\n     *\\n     * @param {Number} size\\n     */\\n    setChunkSize(size){\\n        this.chunk_parser.setChunkSize(size);\\n    }\\n\\n    _getNextMessageStreamID(){\\n        return this.netconnections.length;\\n    }\\n\\n    _getNextChunkStreamID(){\\n        return ++this.chunk_stream_id;      // increase chunk stream id\\n    }\\n\\n    /**\\n     *\\n     * @param {RTMPMessage} msg\\n     * @private\\n     */\\n    _handleUserControlMessage(msg) {\\n        let data = msg.getPayload()\\n\\n        this.event_type = (data[0] <<8) | data[1];\\n        data = data.slice(2);\\n\\n        switch (this.event_type){\\n            case 0x00:      // StreamBegin\\n            case 0x01:      // Stream EOF\\n            case 0x02:      // StreamDry\\n            case 0x04:      // StreamIsRecorded\\n                this.event_data1 = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\\n                break;\\n\\n\\n            case 0x03:      // SetBuffer\\n                this.event_data1 = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\\n                this.event_data2 = (data[4] << 24) | (data[5] << 16) | (data[6] << 8) | (data[7]);\\n                break;\\n\\n            case 0x06:      // PingRequest\\n            case 0x07:      // PingResponse\\n                this.event_data1 = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\\n                break;\\n        }\\n\\n        // Handle Ping internal\\n        if(this.event_type === 0x06) {  // Ping Request\\n            postMessage([\\\"UserControlMessage\\\", [\\\"ping\\\", this.event_data1]]);\\n\\n            const msg = new rtmp_UserControlMessage();\\n            msg.setType(0x07);          // Ping Response\\n            msg.setEventData(this.event_data1);\\n\\n\\n            let m2 = new rtmp_RTMPMessage(msg.getBytes());\\n            m2.setMessageType(0x04)     // UserControlMessage\\n\\n            const chunk = new rtmp_Chunk(m2);\\n            chunk.setChunkStreamID(2);  // Control Channel\\n\\n            logger.i(this.TAG,\\\"send Pong\\\");\\n            this.socket.send(chunk.getBytes());\\n        }\\n    }\\n}\\n\\n/* harmony default export */ const rtmp_RTMPMessageHandler = (RTMPMessageHandler);\\n\\n\\n;// CONCATENATED MODULE: ./src/wss/connection.worker.js\\n/*\\n *\\n * Copyright (C) 2023 itNOX. All Rights Reserved.\\n *\\n * @author Michael Balen <mb@itnox.de>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\\n */\\n\\n\\n\\n\\n\\n\\nconst TAG = \\\"WebRTMP Worker\\\";\\n\\nlet port;\\nlet host;\\nlet message_handler;\\nlogger.LEVEL = logger.DEBUG;\\n\\nconst wss_manager = new wss_WSSConnectionManager();\\n\\nself.addEventListener('message', function(e) {\\n\\tlet data = e.data;\\n\\n\\tlogger.d(TAG, \\\"CMD: \\\" + data.cmd);\\n\\n\\tswitch(data.cmd) {\\n\\t\\tcase \\\"open\\\":    // connect WebSocket\\n\\t\\t\\thost = data.host;\\n\\t\\t\\tport = data.port;\\n\\n\\t\\t\\twss_manager.open(host, port, (success)=>{\\n\\t\\t\\t\\tlogger.v(TAG, \\\"open: \\\" + host + \\\":\\\" +port);\\n\\t\\t\\t\\tif(success){\\n\\t\\t\\t\\t\\tlogger.v(TAG, \\\"WSSConnected\\\");\\n\\t\\t\\t\\t\\tpostMessage([\\\"WSSConnected\\\"]);\\n\\n\\t\\t\\t\\t\\tconst handshake = new rtmp_RTMPHandshake(wss_manager.getSocket());\\n\\n\\t\\t\\t\\t\\thandshake.onHandshakeDone = (success)=>{\\n\\t\\t\\t\\t\\t\\tif(success){\\n\\t\\t\\t\\t\\t\\t\\tmessage_handler = new rtmp_RTMPMessageHandler(wss_manager.getSocket());\\n\\n\\t\\t\\t\\t\\t\\t\\tlogger.d(TAG, \\\"connect to RTMPManager\\\");\\n\\n\\t\\t\\t\\t\\t\\t\\twss_manager.registerMessageHandler((e)=> {\\n\\t\\t\\t\\t\\t\\t\\t\\tmessage_handler.parseChunk(new Uint8Array(e.data));\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t\\t\\tpostMessage([\\\"RTMPHandshakeDone\\\"]);\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tlogger.e(TAG, \\\"Handshake failed\\\");\\n\\t\\t\\t\\t\\t\\t\\tpostMessage([\\\"RTMPHandshakeFailed\\\"]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\thandshake.do();\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlogger.v(this.TAG, \\\"WSSConnectFailed\\\");\\n\\t\\t\\t\\t\\tpostMessage([\\\"WSSConnectFailed\\\"]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\tbreak;\\n\\n\\t\\tcase \\\"connect\\\":             // RTMP Connect Application\\n            if(!message_handler) {\\n                logger.e(this.TAG, \\\"RTMP not connected\\\");\\n                break;\\n            }\\n\\t\\t\\tmessage_handler.connect(makeDefaultConnectionParams(data.appName));\\n\\t\\t\\tbreak;\\n\\n\\t\\tcase \\\"play\\\":\\n            if(!message_handler) {\\n                logger.e(this.TAG, \\\"RTMP not connected\\\");\\n                break;\\n            }\\n\\t\\t\\tmessage_handler.play(data.streamName);\\n\\t\\t\\tbreak;\\n\\n\\t\\tcase \\\"stop\\\":\\n            if(!message_handler) {\\n                logger.e(this.TAG, \\\"RTMP not connected\\\");\\n                break;\\n            }\\n\\t\\t\\tmessage_handler.stop();\\n\\t\\t\\tbreak;\\n\\n        case \\\"pause\\\":\\n            if(!message_handler) {\\n                logger.e(this.TAG, \\\"RTMP not connected\\\");\\n                break;\\n            }\\n\\t\\t\\tmessage_handler.pause(data.enable);\\n            break;\\n\\n        case \\\"disconnect\\\":\\n            if(message_handler) {\\n\\t\\t\\t\\tmessage_handler.destroy();\\n            }\\n\\t\\t\\twss_manager.close();\\n\\t\\t\\tbreak;\\n\\n\\t\\tcase \\\"loglevels\\\":\\n\\t\\t\\tlogger.d(TAG, \\\"setting loglevels\\\", data.loglevels);\\n\\t\\t\\tlogger.loglevels = data.loglevels;\\n            break;\\n\\n\\t\\tdefault:\\n\\t\\t\\tlogger.w(TAG, \\\"Unknown CMD: \\\" + data.cmd);\\n\\t\\t\\tbreak;\\n\\t}\\n\\n}, false);\\n\\nfunction makeDefaultConnectionParams(application){\\n\\treturn {\\n\\t\\t\\\"app\\\": application,\\n\\t\\t\\\"flashVer\\\": \\\"WebRTMP 0,0,1\\\",\\n\\t\\t\\\"tcUrl\\\": \\\"rtmp://\\\" + host + \\\":1935/\\\" + application,\\n\\t\\t\\\"fpad\\\": false,\\n\\t\\t\\\"capabilities\\\": 15,\\n\\t\\t\\\"audioCodecs\\\": 0x0400,\\t// AAC\\n\\t\\t\\\"videoCodecs\\\": 0x0080,\\t// H264\\n\\t\\t\\\"videoFunction\\\": 0\\t\\t// Seek false\\n\\t};\\n}\\n\\npostMessage([\\\"Started\\\"]);\\n\\n\\n/******/ })()\\n;\\n\", \"Worker\", undefined, undefined);\n}\n","/*\n *\n * Copyright (C) 2023 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport EventEmitter from \"../utils/event_emitter\";\nimport Log from \"../utils/logger\";\nimport Worker from \"./connection.worker.js\";\n\n\n/**\n * Class which handles the Websocket\n */\nclass WebRTMP_Controller {\n\tTAG = \"WebRTMP_Controller\";\n\thost = document.location.host;\n\tport = 9001;\n\tWSSReconnect = false;\n\tisConnected = false;\n\n\tWebRTMPWorker = new Worker();\n\n\tconstructor() {\n\t\tLog.loglevels = {\n            \"RTMPMessage\": Log.ERROR,\n            \"RTMPMessageHandler\": Log.WARN,\n            \"RTMPMediaMessageHandler\": Log.ERROR,\n            \"ChunkParser\": Log.WARN,\n            \"RTMPHandshake\": Log.ERROR,\n            \"Chunk\": Log.OFF,\n            \"MP4Remuxer\": Log.ERROR,\n            \"Transmuxer\": Log.WARN,\n            \"EventEmitter\": Log.DEBUG,\n            \"MSEController\": Log.INFO,\n            \"WebRTMP\": Log.DEBUG,\n            \"WebRTMP_Controller\": Log.WARN,\n            \"WebRTMP Worker\": Log.WARN,\n            \"AMF\": Log.WARN,\n            \"WSSConnectionManager\": Log.DEBUG\n        };\n\n\t\tthis._emitter = new EventEmitter();\n\n\t\tthis.WebRTMPWorker.addEventListener(\"message\", (evt)=>{\n\t\t\tthis.WorkerListener(evt);\n\t\t});\n\t}\n\n\t/**\n\t * Opens a WSS Connection\n\t * @param {String|null} host\n\t * @param {Number|null} port\n\t */\n\topen(host, port){\n\t\treturn new Promise((resolve, reject)=>{\n\t\t\tif(this.isConnected) return reject(\"Already Connected. Please disconnect first\");\n\t\t\tthis._emitter.waitForEvent(\"RTMPHandshakeDone\", resolve);\n\t\t\tthis._emitter.waitForEvent(\"WSSConnectFailed\", reject);\n\n\t\t\tif(host) this.host = host;\n\t\t\tif(port) this.port = port;\n\n\t\t\tthis.WebRTMPWorker.postMessage({cmd: \"open\", host: this.host, port: this.port});\n\t\t})\n\t}\n\n\t/**\n\t * Websocket disconnect\n\t */\n\tdisconnect() {\n\t\tthis.WSSReconnect = false;\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"disconnect\"});\n\t}\n\n\t/**\n\t * RTMP connect application\n\t * @param {String} appName\n\t */\n\tconnect(appName){\n\t\treturn new Promise((resolve, reject)=>{\n\t\t\tthis._emitter.waitForEvent(\"RTMPStreamCreated\", resolve);\n\t\t\tthis.WebRTMPWorker.postMessage({cmd: \"connect\", appName: appName});\n\t\t})\n\n\t}\n\n\t/**\n\t * RTMP play streamname\n\t * @param {String} streamName\n\t */\n\tplay(streamName){\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"play\", streamName: streamName});\n\t}\n\n    /**\n     * RTMP stop\n     */\n\tstop(){\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"stop\"});\n\t}\n\n    /**\n     * Pause a video, RTMP Connection will also paused\n     * @param {boolean} enable - Enable or disable pause mode\n     */\n    pause(enable){\n        this.WebRTMPWorker.postMessage({cmd: \"pause\", enable: enable});\n    }\n\n\n\t/**\n\t * add Eventlistener\n\t * @param type\n\t * @param listener\n\t * @param {boolean} modal - Register only one Event, if exists overwrite\n\t */\n\taddEventListener(type, listener, modal){\n\t\tthis._emitter.addEventListener(type, listener, modal);\n\t}\n\n    /**\n     * Remove Eventlistner\n     * @param {String} type - Event name\n     * @param {Function} listener - callback when event occurs\n     */\n\tremoveEventListener(type, listener){\n\t\tthis._emitter.removeEventListener(type, listener);\n\t}\n\n    /**\n     * Remove All registered Listener\n     * @param type\n     */\n\tremoveAllEventListener(type){\n\t\tthis._emitter.removeAllEventListener(type);\n\t}\n\n\n\t/**\n\t *\n\t * @param {MessageEvent} evt\n\t * @constructor\n\t */\n\tWorkerListener(evt){\n\t\t// Message.data wieder zum Event machen\n\t\tconst data = evt.data;\n\n\t\tswitch(data[0]){\n\t\t\tcase \"ConnectionLost\":\n\t\t\t\tthis._emitter.emit(\"ConnectionLost\");\n\t\t\t\tLog.d(this.TAG, \"Event ConnectionLost\");\n\n\t\t\t\tthis.isConnected = false;\n\n\t\t\t\tif(this.WSSReconnect) {\n\t\t\t\t\tLog.w(this.TAG,\"[ WorkerListener ] Reconnect timed\");\n\n\t\t\t\t\twindow.setTimeout(()=>{\n\t\t\t\t\t\tLog.w(this.TAG, \"timed Reconnect\");\n\t\t\t\t\t\tthis.open(this.host, this.port);\n\t\t\t\t\t}, 1000)\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"Connected\":\n\t\t\t\tLog.d(this.TAG, \"Event Connected\");\n\t\t\t\tthis._emitter.emit(\"Connected\");\n\t\t\t\tthis.isConnected = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"Started\":\n\t\t\t\tthis.WebRTMPWorker.postMessage({\n\t\t\t\t\tcmd: \"loglevels\",\n\t\t\t\t\tloglevels: this.loglevels\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tLog.i(this.TAG, data[0], data.slice(1));\n\t\t\t\tthis._emitter.emit(data[0], data.slice(1));\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport default WebRTMP_Controller;\n","/*\r\n *\r\n * Copyright (C) 2023 itNOX. All Rights Reserved.\r\n *\r\n * @author Michael Balen <mb@itnox.de>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\n\r\nimport Log from \"./utils/logger\";\r\nimport MSEController from \"./utils/mse-controller\";\r\nimport {defaultConfig, ErrorDetails, ErrorTypes, MSEEvents, PlayerEvents, TransmuxingEvents} from \"./utils/utils\";\r\nimport EventEmitter from \"./utils/event_emitter\";\r\nimport WebRTMP_Controller from \"./wss/webrtmp.controller\";\r\n\r\n/**\r\n * the main class for webrtmp. Handles the remuxer result\r\n */\r\nexport class WebRTMP{\r\n\tTAG = 'WebRTMP';\r\n\r\n\t/**\r\n\t *\r\n\t * @type {HTMLVideoElement}\r\n\t * @private\r\n\t */\r\n\t_mediaElement = null;\r\n\r\n\tconstructor() {\r\n\t\tthis.wss = new WebRTMP_Controller();\r\n\r\n\t\tthis._config = defaultConfig\r\n\r\n\t\tthis.wss.addEventListener(\"RTMPMessageArrived\", (data)=>{\r\n\t\t\tLog.d(this.TAG,\"RTMPMessageArrived\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"ProtocolControlMessage\", (data)=>{\r\n\t\t\tLog.d(this.TAG,\"ProtocolControlMessage\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"UserControlMessage\", (data)=>{\r\n\t\t\tLog.d(this.TAG,\"UserControlMessage\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"ConnectionLost\", ()=>{});\r\n\r\n\t\tthis._emitter = new EventEmitter();\r\n\r\n\t\tthis.e = {\r\n\t\t\tonvLoadedMetadata: this._onvLoadedMetadata.bind(this),\r\n\t\t\tonvCanPlay: this._onvCanPlay.bind(this),\r\n\t\t\tonvStalled: this._onvStalled.bind(this),\r\n\t\t\tonvProgress: this._onvProgress.bind(this),\r\n\t\t\tonvPlay: this._onvPlay.bind(this),\r\n\t\t\tonvPause: this._onvPause.bind(this),\r\n\t\t\tonAppendInitSegment: this._appendMediaSegment.bind(this),\r\n\t\t\tonAppendMediaSegment: this._appendMediaSegment.bind(this)\r\n\t\t};\r\n\t}\r\n\r\n\t_checkAndResumeStuckPlayback(stalled) {\r\n\t\tlet media = this._mediaElement;\r\n\t\tif (stalled || !this._receivedCanPlay || media.readyState < 2) {  // HAVE_CURRENT_DATA\r\n\t\t\tlet buffered = media.buffered;\r\n\t\t\tif (buffered.length > 0 && media.currentTime < buffered.start(0)) {\r\n\t\t\t\tLog.w(this.TAG, `Playback seems stuck at ${media.currentTime}, seek to ${buffered.start(0)}`);\r\n\t\t\t\t//this._requestSetTime = true;\r\n\t\t\t\tthis._mediaElement.currentTime = buffered.start(0);\r\n\t\t\t\tthis._mediaElement.removeEventListener('progress', this.e.onvProgress);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Playback didn't stuck, remove progress event listener\r\n\t\t\tthis._mediaElement.removeEventListener('progress', this.e.onvProgress);\r\n\t\t}\r\n\t}\r\n\r\n\t_onvLoadedMetadata() {\r\n\t\tif (this._pendingSeekTime != null) {\r\n\t\t\tthis._mediaElement.currentTime = this._pendingSeekTime;\r\n\t\t\tthis._pendingSeekTime = null;\r\n\t\t}\r\n\t}\r\n\r\n\t_onvCanPlay(e) {\r\n\t\tLog.d(this.TAG, \"onvCanPlay\", e);\r\n\t\tthis._mediaElement.play().then(()=>{\r\n\t\t\tLog.d(this.TAG, \"promise play\");\r\n\t\t});\r\n\t\tthis._receivedCanPlay = true;\r\n\t\tthis._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\r\n\t}\r\n\r\n\t_onvStalled() {\r\n\t\tthis._checkAndResumeStuckPlayback(true);\r\n\t}\r\n\r\n\t_onvProgress() {\r\n\t\tthis._checkAndResumeStuckPlayback();\r\n\t}\r\n\r\n\t_onmseBufferFull() {\r\n\t\tLog.w(this.TAG, 'MSE SourceBuffer is full');\r\n\t}\r\n\r\n\t_onvPlay(e){\r\n\t\tLog.d(this.TAG, \"play:\", e);\r\n\t\tthis.pause(false);\r\n\t}\r\n\r\n\t_onvPause(e) {\r\n\t\tLog.d(this.TAG, \"pause\", e);\r\n\t\tthis.pause(true);\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tLog.w(this.TAG, \"destroy webrtmp\");\r\n\t\tif (this._mediaElement) {\r\n\t\t\tthis.detachMediaElement();\r\n\t\t}\r\n\t\tthis.e = null;\r\n\t\tthis._emitter.removeAllListener();\r\n\t\tthis._emitter = null;\r\n\t}\r\n\r\n\tdisconnect(){\r\n\t\tthis.wss.disconnect();\r\n\t\tthis.wss.removeAllEventListener(\"RTMPHandshakeDone\");\r\n\t\tthis.wss.removeAllEventListener(\"WSSConnectFailed\");\r\n\t}\r\n\r\n\t/**\r\n\t * send play command\r\n\t * @param {String} streamName\r\n\t * @returns {Promise<unknown>}\r\n\t */\r\n\tplay(streamName){\r\n\t\tthis.wss.play(streamName);\r\n\t\treturn this._mediaElement.play();\r\n\t}\r\n\r\n    /**\r\n     * Stops loading, same as pause(true)\r\n     */\r\n\tstopLoad(){\r\n\t\t//this.wss.stop()\r\n\t\tthis._mediaElement.pause();\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {String|null} host\r\n\t * @param {Number|null} port\r\n\t * @returns {Promise<unknown>}\r\n\t */\r\n\topen(host, port){\r\n\t\treturn this.wss.open(host, port);\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {String} appName\r\n\t * @returns {Promise<unknown>}\r\n\t */\r\n\tconnect(appName){\r\n\t\treturn this.wss.connect(appName);\r\n\t}\r\n\r\n    /**\r\n     * Pause a rtmp stream\r\n     * @param {boolean} enable\r\n     */\r\n\tpause(enable){\r\n\t\tthis.wss.pause(enable);\r\n\r\n\t\tif(enable) {\r\n\t\t\tthis._mediaElement.pause();\r\n\r\n\t\t} else {\r\n\t\t\tthis.kerkDown = 10;\r\n\t\t\tthis._mediaElement.play().then(()=>{\r\n\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * Detach Mediaelement\r\n     */\r\n\tdetachMediaElement() {\r\n\t\tthis.wss.removeAllEventListener(TransmuxingEvents.INIT_SEGMENT);\r\n\t\tthis.wss.removeAllEventListener(TransmuxingEvents.MEDIA_SEGMENT);\r\n\r\n\t\tif (this._mediaElement) {\r\n\t\t\tthis._msectl.detachMediaElement();\r\n\t\t\tthis._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\r\n\t\t\tthis._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\r\n\t\t\tthis._mediaElement.removeEventListener('stalled', this.e.onvStalled);\r\n\t\t\tthis._mediaElement.removeEventListener('progress', this.e.onvProgress);\r\n\t\t\tthis._mediaElement.removeEventListener('play', this.e.onvPlay);\r\n\t\t\tthis._mediaElement.removeEventListener('pause', this.e.onvPause);\r\n\t\t\tthis._mediaElement = null;\r\n\t\t}\r\n\r\n\t\tif (this._msectl) {\r\n\t\t\tthis._msectl.destroy();\r\n\t\t\tthis._msectl = null;\r\n\t\t}\r\n\r\n\t\tthis.disconnect();\r\n\t}\r\n\r\n\t/**\r\n\t * Attach MediaElement\r\n\t * @param {HTMLVideoElement} mediaElement\r\n\t */\r\n\tattachMediaElement(mediaElement) {\r\n\t\tthis._mediaElement = mediaElement;\r\n\t\tmediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\r\n\t\tmediaElement.addEventListener('canplay', this.e.onvCanPlay);\r\n\t\tmediaElement.addEventListener('stalled', this.e.onvStalled);\r\n\t\tmediaElement.addEventListener('progress', this.e.onvProgress);\r\n\t\tmediaElement.addEventListener('play', this.e.onvPlay);\r\n\t\tmediaElement.addEventListener('pause', this.e.onvPause);\r\n\r\n\t\tthis._msectl = new MSEController(defaultConfig);\r\n\r\n\t\t//this._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\r\n\t\tthis._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\r\n\r\n\t\tthis._msectl.on(MSEEvents.ERROR, (info) => {\r\n\t\t\tthis._emitter.emit(PlayerEvents.ERROR,\r\n\t\t\t\tErrorTypes.MEDIA_ERROR,\r\n\t\t\t\tErrorDetails.MEDIA_MSE_ERROR,\r\n\t\t\t\tinfo\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(TransmuxingEvents.INIT_SEGMENT, this._appendInitSegment.bind(this), true);\r\n\t\tthis.wss.addEventListener(TransmuxingEvents.MEDIA_SEGMENT, this._appendMediaSegment.bind(this), true);\r\n\r\n\t\tthis._msectl.attachMediaElement(mediaElement);\r\n\t}\r\n\r\n    /**\r\n     * Append Init Segment to MSE\r\n     * @param data\r\n     * @private\r\n     */\r\n\t_appendInitSegment(data){\r\n\t\tLog.i(this.TAG, TransmuxingEvents.INIT_SEGMENT, data[0], data[1]);\r\n\t\tthis._msectl.appendInitSegment(data[1]);\r\n\t}\r\n\r\n    /**\r\n     * Append Media Segment to MSE\r\n     * @param data\r\n     * @private\r\n     */\r\n\t_appendMediaSegment(data){\r\n\t\tLog.t(this.TAG, TransmuxingEvents.MEDIA_SEGMENT, data[0], data[1]);\r\n\t\tthis._msectl.appendMediaSegment(data[1]);\r\n\t\tif(this.kerkDown) {\r\n\t\t\tthis.kerkDown--;\r\n\t\t\tthis._mediaElement.currentTime = 2000000000;\r\n\r\n\t\t\tif(!this.kerkDown) Log.d(this.TAG, \"kerkdown reached\");\r\n\t\t}\r\n\t}\r\n}\r\n","/*\n *\n * Copyright (C) 2023 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n\nimport { WebRTMP } from \"./webrtmp\";\nimport Log from \"./utils/logger\";\nexport { WebRTMP } from \"./webrtmp\";\n\nexport function createWebRTMP(){\n    return new WebRTMP();\n}\n\nwindow[\"Log\"] = Log;\n"],"names":[],"sourceRoot":""}