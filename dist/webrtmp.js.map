{"version":3,"file":"dist/webrtmp.js","mappings":";;;;UAAA;UACA;;UAEA;UACA;;;;;WCJA;WACA;WACA;WACA;WACA;;;;;WCJA;;;;;WCAA;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;;;;;;;;;;;ACrBO,MAAM,UAAG;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAC6B;;AAE7B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO,YAAK;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK,YAAK;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,aAAa;AACjC;AACA,iBAAiB,SAAS,SAAS;AACnC;;AAEA;;AAEA,EAAE,YAAK;AACP;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK,YAAK;AACV,0CAA0C,qCAAqC;AAC/E;AACA;AACA,KAAK;AACL,IAAI,YAAK,sBAAsB,SAAS,4BAA4B,yBAAyB,YAAY,SAAS;AAClH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK,YAAK;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA,0CAA0C,WAAW;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA,2DAA2D;AAC3D;AACA;AACA;AACA,6CAA6C,6BAA6B;AAC1E;AACA,OAAO;AACP;AACA,4CAA4C,uBAAuB;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG,YAAK,+CAA+C,SAAS,KAAK,OAAO;AAC5E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA,yBAAyB;AACzB,MAAM,YAAK,qDAAqD,eAAe,KAAK,aAAa;AACjG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,YAAK;AACX,2CAA2C,qCAAqC;AAChF;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,YAAK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,YAAK;AACP;;AAEA;AACA;AACA,EAAE,YAAK;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,EAAE,YAAK,kCAAkC,EAAE;AAC3C;AACA;;AAEA;;AAEA,qDAAe,aAAa,EAAC;;;ACthB7B;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;;AAEO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;;AAEA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGO,MAAM,uBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO,MAAM,eAAS;AACtB;AACA;AACA;AACA;AACA;;AAEO,MAAM,kBAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,MAAM,gBAAU;AACvB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,MAAM,kBAAY;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AC3JA;AACA;;AAEA,oCAAoC,6FAAuC;AAC3E;AACA,QAAQ,SAAQ;AAChB,4BAA4B,wBAAwB;AACpD,EAAE;;;AAGF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yCAAyC;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;;AAEA;AACA,kCAAkC,iCAAiC;AACnE;;AAEA;AACA,kCAAkC,oCAAoC;AACtE;;AAEA;AACA,wCAAwC,6BAA6B;AACrE;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,QAAQ;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAAe,kBAAkB,EAAC;;;AC7IlC,MAAM,0BAAY;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAe,0BAAY,EAAC;;;;ACnC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA,wBAAwB,gBAAgB,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,0CAAe,GAAG,EAAC;;;ACrjBnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B;;AAEA,gCAAgC;AAChC;AACA;AACA;;AAEA;;AAEA;AACO,MAAM,gCAAa;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACO;;AAEP;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iDAAe,GAAG,EAAC;;;ACtDnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO,MAAM,+BAAqB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,eAAO;;AAEX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,eAAO;AACxB,MAAM,eAAO;AACb,UAAU,eAAO;AACjB;AACA;AACA,eAAe,eAAO;AACtB;;AAEA;;AAEA,8CAAe,eAAO,EAAC;;;AC/HvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACwB;AACgE;AACzD;AAC0B;AAClB;;AAEvC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,oBAAoB;AACvD,mCAAmC,oBAAoB;;AAEvD;AACA;;AAEA;AACA;AACA,yBAAyB,cAAc;AACvC,IAAI,qBAAqB;AACzB,KAAK,qBAAqB,WAAW,qBAAqB;;AAE1D;AACA;AACA,+BAA+B,cAAc,IAAI,YAAY;;AAE7D;AACA,2BAA2B,eAAe;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,+BAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,uBAAuB;AACrC;AACA,IAAI;AACJ;AACA,aAAa,uBAAuB;AACpC,IAAI;AACJ;AACA;;AAEA;AACA;AACA,aAAa,+BAAqB;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK,GAAG,UAAU;AACnC;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAkB;AACvC;AACA;AACA;AACA,sDAAsD,IAAI,cAAc,oBAAoB;AAC5F,uBAAuB,sCAAsC;AAC7D;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,aAAa,iBAAiB,WAAW,6BAA6B,eAAe;AAClJ;AACA;AACA,yGAAyG,cAAc;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa,iBAAiB,WAAW;AAC/D,wBAAwB,2BAA2B,gBAAgB,YAAY;;;AAG/E;AACA;;AAEA,sBAAsB,yBAAkB;AACxC;AACA;AACA,UAAU,+BAA+B,OAAO,8BAA8B;AAC9E;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA,MAAM,QAAQ;AACd,gCAAgC;AAChC;AACA;AACA,OAAO,oCAAoC;AAC3C;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK,QAAQ;AACb,+BAA+B;AAC/B;AACA;AACA,MAAM,oCAAoC;AAC1C;AACA,MAAM,QAAQ;AACd;AACA;AACA;;AAEA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;;AAE5B;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kDAAe,UAAU,EAAC;;;AC7uB1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACiD;AACC;AACF;;AAEhD;;AAEA;AACA;AACA,4BAA4B,aAAY;;AAExC;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,4BAA4B,WAAU;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,2BAA2B,wCAAkC;AAC7D;;AAEA;AACA,2BAA2B,0CAAoC;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B,wCAAkC;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,2CAAqC;AAChE;;AAEA;AACA,+CAA+C,KAAK,WAAW,UAAU,UAAU,SAAS;AAC5F,2BAA2B,gCAA0B;AACrD;AACA;;AAEA;AACA,kDAAkD,KAAK,WAAW,KAAK;AACvE,2BAA2B,mCAA6B;AACxD;;AAEA;AACA,2BAA2B,oCAA8B;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qCAA+B;;AAE1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,2CAAqC;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;;AAEA,2BAA2B,kCAA4B;AACvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uCAAiC;AAC5D;;AAEA;;AAEA,iDAAe,UAAU,EAAC;;;AC9VS;AACgB;AACP;AACiB;AACnB;AACO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAkB;AACnC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,6CAA6C;AAC7C;AACA,oDAAoD;AACpD;AACA,oDAAoD;AACpD;AACA,sBAAsB,aAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,YAAK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,YAAK;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAK;AACX;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,8CAAe,OAAO,EAAC","sources":["webpack://webrtmp/webpack/bootstrap","webpack://webrtmp/webpack/runtime/get javascript chunk filename","webpack://webrtmp/webpack/runtime/hasOwnProperty shorthand","webpack://webrtmp/webpack/runtime/publicPath","webpack://webrtmp/webpack/runtime/jsonp chunk loading","webpack://webrtmp/./utils/logger.js","webpack://webrtmp/./utils/mse-controller.js","webpack://webrtmp/./utils/utils.js","webpack://webrtmp/./wss/connection.controller.js","webpack://webrtmp/./utils/event_emitter.js","webpack://webrtmp/./formats/mp4.js","webpack://webrtmp/./formats/media-segment-info.js","webpack://webrtmp/./formats/aac-silent.js","webpack://webrtmp/./utils/exception.js","webpack://webrtmp/./utils/browser.js","webpack://webrtmp/./formats/mp4-remuxer.js","webpack://webrtmp/./flv/transmuxer.js","webpack://webrtmp/./webrtmp.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + \"webrtmp.worker\" + \".js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/webrtmp/\";","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","export class Log {\n    static v(...params){\n        console.log(...params);\n    }\n\n    static e(...params){\n        console.error(...params);\n    }\n\n    static w(...params){\n        console.warn(...params);\n    }\n\n    static t(...params){\n        console.trace(...params);\n    }\n\n    static i(...params){\n        console.info(...params);\n    }\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// Media Source Extensions controller\nimport {Log} from \"./logger\";\n\nclass MSEController {\n\n\tconstructor(config) {\n\t\tthis.TAG = 'MSEController';\n\n\t\tthis._config = config;\n\t\tthis._emitter = new EventEmitter();\n\n\t\tif (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n\t\t\t// For live stream, do auto cleanup by default\n\t\t\tthis._config.autoCleanupSourceBuffer = true;\n\t\t}\n\n\t\tthis.e = {\n\t\t\tonSourceOpen: this._onSourceOpen.bind(this),\n\t\t\tonSourceEnded: this._onSourceEnded.bind(this),\n\t\t\tonSourceClose: this._onSourceClose.bind(this),\n\t\t\tonSourceBufferError: this._onSourceBufferError.bind(this),\n\t\t\tonSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n\t\t};\n\n\t\tthis._mediaSource = null;\n\t\tthis._mediaSourceObjectURL = null;\n\t\tthis._mediaElement = null;\n\n\t\tthis._isBufferFull = false;\n\t\tthis._hasPendingEos = false;\n\n\t\tthis._requireSetMediaDuration = false;\n\t\tthis._pendingMediaDuration = 0;\n\n\t\tthis._pendingSourceBufferInit = [];\n\t\tthis._mimeTypes = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._sourceBuffers = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._lastInitSegments = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._pendingSegments = {\n\t\t\tvideo: [],\n\t\t\taudio: []\n\t\t};\n\t\tthis._pendingRemoveRanges = {\n\t\t\tvideo: [],\n\t\t\taudio: []\n\t\t};\n\t\tthis._idrList = new IDRSampleList();\n\t}\n\n\tdestroy() {\n\t\tif (this._mediaElement || this._mediaSource) {\n\t\t\tthis.detachMediaElement();\n\t\t}\n\t\tthis.e = null;\n\t\tthis._emitter.removeAllListeners();\n\t\tthis._emitter = null;\n\t}\n\n\ton(event, listener) {\n\t\tthis._emitter.addListener(event, listener);\n\t}\n\n\toff(event, listener) {\n\t\tthis._emitter.removeListener(event, listener);\n\t}\n\n\tattachMediaElement(mediaElement) {\n\t\tif (this._mediaSource) {\n\t\t\tthrow new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n\t\t}\n\t\tlet ms = this._mediaSource = new window.MediaSource();\n\t\tms.addEventListener('sourceopen', this.e.onSourceOpen);\n\t\tms.addEventListener('sourceended', this.e.onSourceEnded);\n\t\tms.addEventListener('sourceclose', this.e.onSourceClose);\n\n\t\tthis._mediaElement = mediaElement;\n\t\tthis._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n\t\tmediaElement.src = this._mediaSourceObjectURL;\n\t}\n\n\tdetachMediaElement() {\n\t\tif (this._mediaSource) {\n\t\t\tlet ms = this._mediaSource;\n\t\t\tfor (let type in this._sourceBuffers) {\n\t\t\t\t// pending segments should be discard\n\t\t\t\tlet ps = this._pendingSegments[type];\n\t\t\t\tps.splice(0, ps.length);\n\t\t\t\tthis._pendingSegments[type] = null;\n\t\t\t\tthis._pendingRemoveRanges[type] = null;\n\t\t\t\tthis._lastInitSegments[type] = null;\n\n\t\t\t\t// remove all sourcebuffers\n\t\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\t\tif (sb) {\n\t\t\t\t\tif (ms.readyState !== 'closed') {\n\t\t\t\t\t\t// ms edge can throw an error: Unexpected call to method or property access\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tms.removeSourceBuffer(sb);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsb.removeEventListener('error', this.e.onSourceBufferError);\n\t\t\t\t\t\tsb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n\t\t\t\t\t}\n\t\t\t\t\tthis._mimeTypes[type] = null;\n\t\t\t\t\tthis._sourceBuffers[type] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ms.readyState === 'open') {\n\t\t\t\ttry {\n\t\t\t\t\tms.endOfStream();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tms.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t\tms.removeEventListener('sourceended', this.e.onSourceEnded);\n\t\t\tms.removeEventListener('sourceclose', this.e.onSourceClose);\n\t\t\tthis._pendingSourceBufferInit = [];\n\t\t\tthis._isBufferFull = false;\n\t\t\tthis._idrList.clear();\n\t\t\tthis._mediaSource = null;\n\t\t}\n\n\t\tif (this._mediaElement) {\n\t\t\tthis._mediaElement.src = '';\n\t\t\tthis._mediaElement.removeAttribute('src');\n\t\t\tthis._mediaElement = null;\n\t\t}\n\t\tif (this._mediaSourceObjectURL) {\n\t\t\twindow.URL.revokeObjectURL(this._mediaSourceObjectURL);\n\t\t\tthis._mediaSourceObjectURL = null;\n\t\t}\n\t}\n\n\tappendInitSegment(initSegment, deferred) {\n\t\tif (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n\t\t\t// sourcebuffer creation requires mediaSource.readyState === 'open'\n\t\t\t// so we defer the sourcebuffer creation, until sourceopen event triggered\n\t\t\tthis._pendingSourceBufferInit.push(initSegment);\n\t\t\t// make sure that this InitSegment is in the front of pending segments queue\n\t\t\tthis._pendingSegments[initSegment.type].push(initSegment);\n\t\t\treturn;\n\t\t}\n\n\t\tlet is = initSegment;\n\t\tlet mimeType = `${is.container}`;\n\t\tif (is.codec && is.codec.length > 0) {\n\t\t\tmimeType += `;codecs=${is.codec}`;\n\t\t}\n\n\t\tlet firstInitSegment = false;\n\n\t\tLog.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n\t\tthis._lastInitSegments[is.type] = is;\n\n\t\tif (mimeType !== this._mimeTypes[is.type]) {\n\t\t\tif (!this._mimeTypes[is.type]) {  // empty, first chance create sourcebuffer\n\t\t\t\tfirstInitSegment = true;\n\t\t\t\ttry {\n\t\t\t\t\tlet sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n\t\t\t\t\tsb.addEventListener('error', this.e.onSourceBufferError);\n\t\t\t\t\tsb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\tthis._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLog.v(this.TAG, `Notice: ${is.type} mimeType changed, origin: ${this._mimeTypes[is.type]}, target: ${mimeType}`);\n\t\t\t}\n\t\t\tthis._mimeTypes[is.type] = mimeType;\n\t\t}\n\n\t\tif (!deferred) {\n\t\t\t// deferred means this InitSegment has been pushed to pendingSegments queue\n\t\t\tthis._pendingSegments[is.type].push(is);\n\t\t}\n\t\tif (!firstInitSegment) {  // append immediately only if init segment in subsequence\n\t\t\tif (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n\t\t\t\tthis._doAppendSegments();\n\t\t\t}\n\t\t}\n\t\tif (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n\t\t\t// 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n\t\t\t// Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n\t\t\tthis._requireSetMediaDuration = true;\n\t\t\tthis._pendingMediaDuration = is.mediaDuration / 1000;  // in seconds\n\t\t\tthis._updateMediaSourceDuration();\n\t\t}\n\t}\n\n\tappendMediaSegment(mediaSegment) {\n\t\tlet ms = mediaSegment;\n\t\tthis._pendingSegments[ms.type].push(ms);\n\n\t\tif (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n\t\t\tthis._doCleanupSourceBuffer();\n\t\t}\n\n\t\tlet sb = this._sourceBuffers[ms.type];\n\t\tif (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n\t\t\tthis._doAppendSegments();\n\t\t}\n\t}\n\n\tseek(seconds) {\n\t\t// remove all appended buffers\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tif (!this._sourceBuffers[type]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// abort current buffer append algorithm\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (this._mediaSource.readyState === 'open') {\n\t\t\t\ttry {\n\t\t\t\t\t// If range removal algorithm is running, InvalidStateError will be throwed\n\t\t\t\t\t// Ignore it.\n\t\t\t\t\tsb.abort();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// IDRList should be clear\n\t\t\tthis._idrList.clear();\n\n\t\t\t// pending segments should be discard\n\t\t\tlet ps = this._pendingSegments[type];\n\t\t\tps.splice(0, ps.length);\n\n\t\t\tif (this._mediaSource.readyState === 'closed') {\n\t\t\t\t// Parent MediaSource object has been detached from HTMLMediaElement\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// record ranges to be remove from SourceBuffer\n\t\t\tfor (let i = 0; i < sb.buffered.length; i++) {\n\t\t\t\tlet start = sb.buffered.start(i);\n\t\t\t\tlet end = sb.buffered.end(i);\n\t\t\t\tthis._pendingRemoveRanges[type].push({start, end});\n\t\t\t}\n\n\t\t\t// if sb is not updating, let's remove ranges now!\n\t\t\tif (!sb.updating) {\n\t\t\t\tthis._doRemoveRanges();\n\t\t\t}\n\n\t\t\t// Safari 10 may get InvalidStateError in the later appendBuffer() after SourceBuffer.remove() call\n\t\t\t// Internal parser's state may be invalid at this time. Re-append last InitSegment to workaround.\n\t\t\t// Related issue: https://bugs.webkit.org/show_bug.cgi?id=159230\n\t\t\tif (Browser.safari) {\n\t\t\t\tlet lastInitSegment = this._lastInitSegments[type];\n\t\t\t\tif (lastInitSegment) {\n\t\t\t\t\tthis._pendingSegments[type].push(lastInitSegment);\n\t\t\t\t\tif (!sb.updating) {\n\t\t\t\t\t\tthis._doAppendSegments();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tendOfStream() {\n\t\tlet ms = this._mediaSource;\n\t\tlet sb = this._sourceBuffers;\n\t\tif (!ms || ms.readyState !== 'open') {\n\t\t\tif (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n\t\t\t\t// If MediaSource hasn't turned into open state, and there're pending segments\n\t\t\t\t// Mark pending endOfStream, defer call until all pending segments appended complete\n\t\t\t\tthis._hasPendingEos = true;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n\t\t\t// If any sourcebuffer is updating, defer endOfStream operation\n\t\t\t// See _onSourceBufferUpdateEnd()\n\t\t\tthis._hasPendingEos = true;\n\t\t} else {\n\t\t\tthis._hasPendingEos = false;\n\t\t\t// Notify media data loading complete\n\t\t\t// This is helpful for correcting total duration to match last media segment\n\t\t\t// Otherwise MediaElement's ended event may not be triggered\n\t\t\tms.endOfStream();\n\t\t}\n\t}\n\n\tgetNearestKeyframe(dts) {\n\t\treturn this._idrList.getLastSyncPointBeforeDts(dts);\n\t}\n\n\t_needCleanupSourceBuffer() {\n\t\tif (!this._config.autoCleanupSourceBuffer) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet currentTime = this._mediaElement.currentTime;\n\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (sb) {\n\t\t\t\tlet buffered = sb.buffered;\n\t\t\t\tif (buffered.length >= 1) {\n\t\t\t\t\tif (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_doCleanupSourceBuffer() {\n\t\tlet currentTime = this._mediaElement.currentTime;\n\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (sb) {\n\t\t\t\tlet buffered = sb.buffered;\n\t\t\t\tlet doRemove = false;\n\n\t\t\t\tfor (let i = 0; i < buffered.length; i++) {\n\t\t\t\t\tlet start = buffered.start(i);\n\t\t\t\t\tlet end = buffered.end(i);\n\n\t\t\t\t\tif (start <= currentTime && currentTime < end + 3) {  // padding 3 seconds\n\t\t\t\t\t\tif (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n\t\t\t\t\t\t\tdoRemove = true;\n\t\t\t\t\t\t\tlet removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n\t\t\t\t\t\t\tthis._pendingRemoveRanges[type].push({start: start, end: removeEnd});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (end < currentTime) {\n\t\t\t\t\t\tdoRemove = true;\n\t\t\t\t\t\tthis._pendingRemoveRanges[type].push({start: start, end: end});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (doRemove && !sb.updating) {\n\t\t\t\t\tthis._doRemoveRanges();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateMediaSourceDuration() {\n\t\tlet sb = this._sourceBuffers;\n\t\tif (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n\t\t\treturn;\n\t\t}\n\t\tif ((sb.video && sb.video.updating) || (sb.audio && sb.audio.updating)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet current = this._mediaSource.duration;\n\t\tlet target = this._pendingMediaDuration;\n\n\t\tif (target > 0 && (isNaN(current) || target > current)) {\n\t\t\tLog.v(this.TAG, `Update MediaSource duration from ${current} to ${target}`);\n\t\t\tthis._mediaSource.duration = target;\n\t\t}\n\n\t\tthis._requireSetMediaDuration = false;\n\t\tthis._pendingMediaDuration = 0;\n\t}\n\n\t_doRemoveRanges() {\n\t\tfor (let type in this._pendingRemoveRanges) {\n\t\t\tif (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tlet ranges = this._pendingRemoveRanges[type];\n\t\t\twhile (ranges.length && !sb.updating) {\n\t\t\t\tlet range = ranges.shift();\n\t\t\t\tsb.remove(range.start, range.end);\n\t\t\t}\n\t\t}\n\t}\n\n\t_doAppendSegments() {\n\t\tlet pendingSegments = this._pendingSegments;\n\n\t\tfor (let type in pendingSegments) {\n\t\t\tif (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pendingSegments[type].length > 0) {\n\t\t\t\tlet segment = pendingSegments[type].shift();\n\n\t\t\t\tif (segment.timestampOffset) {\n\t\t\t\t\t// For MPEG audio stream in MSE, if unbuffered-seeking occurred\n\t\t\t\t\t// We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n\t\t\t\t\tlet currentOffset = this._sourceBuffers[type].timestampOffset;\n\t\t\t\t\tlet targetOffset = segment.timestampOffset / 1000;  // in seconds\n\n\t\t\t\t\tlet delta = Math.abs(currentOffset - targetOffset);\n\t\t\t\t\tif (delta > 0.1) {  // If time delta > 100ms\n\t\t\t\t\t\tLog.v(this.TAG, `Update MPEG audio timestampOffset from ${currentOffset} to ${targetOffset}`);\n\t\t\t\t\t\tthis._sourceBuffers[type].timestampOffset = targetOffset;\n\t\t\t\t\t}\n\t\t\t\t\tdelete segment.timestampOffset;\n\t\t\t\t}\n\n\t\t\t\tif (!segment.data || segment.data.byteLength === 0) {\n\t\t\t\t\t// Ignore empty buffer\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tthis._sourceBuffers[type].appendBuffer(segment.data);\n\t\t\t\t\tthis._isBufferFull = false;\n\t\t\t\t\tif (type === 'video' && segment.hasOwnProperty('info')) {\n\t\t\t\t\t\tthis._idrList.appendArray(segment.info.syncPoints);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._pendingSegments[type].unshift(segment);\n\t\t\t\t\tif (error.code === 22) {  // QuotaExceededError\n\t\t\t\t\t\t/* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n\t\t\t\t\t\t * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n\t\t\t\t\t\t * SourceBuffer eviction policy may be changed in future version of FireFox.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Related issues:\n\t\t\t\t\t\t * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n\t\t\t\t\t\t * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n\t\t\t\t\t\t */\n\n\t\t\t\t\t\t// report buffer full, abort network IO\n\t\t\t\t\t\tif (!this._isBufferFull) {\n\t\t\t\t\t\t\tthis._emitter.emit(MSEEvents.BUFFER_FULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._isBufferFull = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\t\tthis._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSourceOpen() {\n\t\tLog.v(this.TAG, 'MediaSource onSourceOpen');\n\t\tthis._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t// deferred sourcebuffer creation / initialization\n\t\tif (this._pendingSourceBufferInit.length > 0) {\n\t\t\tlet pendings = this._pendingSourceBufferInit;\n\t\t\twhile (pendings.length) {\n\t\t\t\tlet segment = pendings.shift();\n\t\t\t\tthis.appendInitSegment(segment, true);\n\t\t\t}\n\t\t}\n\t\t// there may be some pending media segments, append them\n\t\tif (this._hasPendingSegments()) {\n\t\t\tthis._doAppendSegments();\n\t\t}\n\t\tthis._emitter.emit(MSEEvents.SOURCE_OPEN);\n\t}\n\n\t_onSourceEnded() {\n\t\t// fired on endOfStream\n\t\tLog.v(this.TAG, 'MediaSource onSourceEnded');\n\t}\n\n\t_onSourceClose() {\n\t\t// fired on detaching from media element\n\t\tLog.v(this.TAG, 'MediaSource onSourceClose');\n\t\tif (this._mediaSource && this.e != null) {\n\t\t\tthis._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t\tthis._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n\t\t\tthis._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n\t\t}\n\t}\n\n\t_hasPendingSegments() {\n\t\tlet ps = this._pendingSegments;\n\t\treturn ps.video.length > 0 || ps.audio.length > 0;\n\t}\n\n\t_hasPendingRemoveRanges() {\n\t\tlet prr = this._pendingRemoveRanges;\n\t\treturn prr.video.length > 0 || prr.audio.length > 0;\n\t}\n\n\t_onSourceBufferUpdateEnd() {\n\t\tif (this._requireSetMediaDuration) {\n\t\t\tthis._updateMediaSourceDuration();\n\t\t} else if (this._hasPendingRemoveRanges()) {\n\t\t\tthis._doRemoveRanges();\n\t\t} else if (this._hasPendingSegments()) {\n\t\t\tthis._doAppendSegments();\n\t\t} else if (this._hasPendingEos) {\n\t\t\tthis.endOfStream();\n\t\t}\n\t\tthis._emitter.emit(MSEEvents.UPDATE_END);\n\t}\n\n\t_onSourceBufferError(e) {\n\t\tLog.e(this.TAG, `SourceBuffer Error: ${e}`);\n\t\t// this error might not always be fatal, just ignore it\n\t}\n\n}\n\nexport default MSEController;\n","/**\n *\n * @param {Uint8Array} bufs\n * @returns {Uint8Array}\n */\n\nexport function _concatArrayBuffers(...bufs){\n    const result = new Uint8Array(bufs.reduce((totalSize, buf)=>totalSize+buf.byteLength,0));\n    bufs.reduce((offset, buf)=>{\n        result.set(buf,offset)\n        return offset+buf.byteLength\n    },0)\n\n    return result;\n}\n\nexport function _stringToByteArray(str) {\n    const bytes = [];\n\n    for(let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        if(char > 0xFF) {\n            bytes.push(char >>> 8);\n        }\n\n        bytes.push(char & 0xFF);\n    }\n    return bytes;\n}\n\nexport function _numberToByteArray(num) {\n    const buffer = new ArrayBuffer(8);\n    new DataView(buffer).setFloat64(0, num, false);\n    return [].slice.call(new Uint8Array(buffer));\n}\n\nexport function _byteArrayToNumber(ba){\n    let buf = new ArrayBuffer(ba.length);\n    let view = new DataView(buf);\n\n    ba.forEach(function (b, i) {\n        view.setUint8(i, b);\n    });\n\n    return view.getFloat64(0);\n}\n\nexport function _byteArrayToString(ba){\n    let ret = \"\";\n\n    for(let i = 0; i < ba.length; i++){\n        ret += String.fromCharCode(ba[i]);\n    }\n\n    return ret;\n}\n\nexport const defaultConfig = {\n    enableWorker: false,\n    enableStashBuffer: true,\n    stashInitialSize: undefined,\n\n    isLive: true,\n\n    lazyLoad: true,\n    lazyLoadMaxDuration: 3 * 60,\n    lazyLoadRecoverDuration: 30,\n    deferLoadAfterSourceOpen: true,\n\n    // autoCleanupSourceBuffer: default as false, leave unspecified\n    autoCleanupMaxBackwardDuration: 3 * 60,\n    autoCleanupMinBackwardDuration: 2 * 60,\n\n    statisticsInfoReportInterval: 600,\n\n    fixAudioTimestampGap: true,\n\n    accurateSeek: false,\n    seekType: 'range',  // [range, param, custom]\n    seekParamStart: 'bstart',\n    seekParamEnd: 'bend',\n    rangeLoadZeroStart: false,\n    customSeekHandler: undefined,\n    reuseRedirectedURL: false,\n    // referrerPolicy: leave as unspecified\n\n    headers: undefined,\n    customLoader: undefined\n};\n\n\nexport const TransmuxingEvents = {\n    IO_ERROR: 'io_error',\n    DEMUX_ERROR: 'demux_error',\n    INIT_SEGMENT: 'init_segment',\n    MEDIA_SEGMENT: 'media_segment',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info',\n    RECOMMEND_SEEKPOINT: 'recommend_seekpoint'\n};\n\nexport const DemuxErrors = {\n    OK: 'OK',\n    FORMAT_ERROR: 'FormatError',\n    FORMAT_UNSUPPORTED: 'FormatUnsupported',\n    CODEC_UNSUPPORTED: 'CodecUnsupported'\n};\n\nexport const MSEEvents = {\n    ERROR: 'error',\n    SOURCE_OPEN: 'source_open',\n    UPDATE_END: 'update_end',\n    BUFFER_FULL: 'buffer_full'\n};\n\nexport const PlayerEvents = {\n    ERROR: 'error',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info'\n};\n\nexport const ErrorTypes = {\n    NETWORK_ERROR: 'NetworkError',\n    MEDIA_ERROR: 'MediaError',\n    OTHER_ERROR: 'OtherError'\n};\n\nexport const LoaderErrors = {\n    OK: 'OK',\n    EXCEPTION: 'Exception',\n    HTTP_STATUS_CODE_INVALID: 'HttpStatusCodeInvalid',\n    CONNECTING_TIMEOUT: 'ConnectingTimeout',\n    EARLY_EOF: 'EarlyEof',\n    UNRECOVERABLE_EARLY_EOF: 'UnrecoverableEarlyEof'\n};\n\nexport const ErrorDetails = {\n    NETWORK_EXCEPTION: LoaderErrors.EXCEPTION,\n    NETWORK_STATUS_CODE_INVALID: LoaderErrors.HTTP_STATUS_CODE_INVALID,\n    NETWORK_TIMEOUT: LoaderErrors.CONNECTING_TIMEOUT,\n    NETWORK_UNRECOVERABLE_EARLY_EOF: LoaderErrors.UNRECOVERABLE_EARLY_EOF,\n\n    MEDIA_MSE_ERROR: 'MediaMSEError',\n\n    MEDIA_FORMAT_ERROR: DemuxErrors.FORMAT_ERROR,\n    MEDIA_FORMAT_UNSUPPORTED: DemuxErrors.FORMAT_UNSUPPORTED,\n    MEDIA_CODEC_UNSUPPORTED: DemuxErrors.CODEC_UNSUPPORTED\n};\n","class WebRTMP_Controller {\n\thost = document.location.host;\n\n\tWebRTMPWorker = new Worker(new URL('connection.worker.js', import.meta.url), {\n\t\tname: \"webrtmp.worker\",\n\t\ttype: \"module\"\n\t\t/* webpackEntryOptions: { filename: \"[name].js\" } */\n\t});\n\n\n\tDEBUG = false;\n\n\tisConnected = false;\n\n\tListenerList = [];\n\n\tconstructor() {\n\t\tthis.WebRTMPWorker.addEventListener(\"message\", (e)=>{\n\t\t\tthis.WorkerListener(e);\n\t\t})\n\t}\n\n\t/**\n\t * WSS Verbindung aufbauen\n\t */\n\tcreateConnection(){\n\t\tif(this.isConnected) return false;\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"createConnection\", host: this.host});\n\t}\n\n\t/**\n\t * MQTT Verbindung trennen\n\t */\n\tdisconnect() {\n\t\tthis.MQTT_Reconnect = true;\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"disconnect\"});\n\t}\n\n\tconnect(appName){\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"connect\", appName: appName});\n\t}\n\n\tplay(streamName){\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"play\", streamName: streamName});\n\t}\n\n    pause(enable){\n        this.WebRTMPWorker.postMessage({cmd: \"pause\", enable: enable});\n    }\n\n\n\t/**\n\t * Eventlistenre hinzufügenm\n\t * @param type\n\t * @param listener\n\t */\n\taddEventListener(type, listener){\n\t\tswitch(type) {\n\t\t\tcase \"MessageArrived\":\n\t\t\tcase \"Connected\":\n\t\t\tcase \"ConnectionLost\":\n\t\t\tcase \"Started\":\n\t\t\tcase \"Subscribed\":\n\t\t\tcase \"RTMPConnected\":\n\t\t\tcase \"RTMPMessageArrived\":\n\t\t\tcase \"ProtocolControlMessage\":\n\t\t\tcase \"UserControlMessage\":\n            case \"NetConnection.Connect.Success\":\n\t\t\t\tthis.ListenerList[this.ListenerList.length] = {type: type, listener: listener};\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error(\"Event \" + type + \" not recognized\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * intern: Feuert Event\n\t * @param type\n\t * @param message\n\t */\n\tfireEvent(type, message){\n\t\tfor(let i = 0; i < this.ListenerList.length; i++){\n\t\t\tlet evt = this.ListenerList[i];\n\t\t\tif(evt.type === type) {\n\t\t\t\tevt.listener.call(this, message);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Verarbeitet MQTT Events\n\t * @param e Event\n\t */\n\tWorkerListener(e){\n\t\t// Message.data wieder zum Event machen\n\t\tconst data = e.data;\n\n\t\tswitch(data[0]){\n\t\t\tcase \"ConnectionLost\":\n\t\t\t\tthis.fireEvent(\"ConnectionLost\");\n\t\t\t\tconsole.log(\"[ WorkerListener ] Event ConnectionLost\");\n\n\t\t\t\tthis.isConnected = false;\n\n\t\t\t\tif(this.MQTT_Reconnect) {\n\t\t\t\t\tconsole.log(\"[ WorkerListener ] Reconnect timed\");\n\n\t\t\t\t\twindow.setTimeout(()=>{\n\t\t\t\t\t\tconsole.log(\"[ WorkerListener ] timed Reconnect\");\n\t\t\t\t\t\tthis.createConnection();\n\t\t\t\t\t}, 1000)\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"Connected\":\n\t\t\t\tconsole.log(\"[ WorkerListener ] Event Connected\");\n\t\t\t\tthis.fireEvent(\"Connected\");\n\t\t\t\tthis.isConnected = true;\n\t\t\t\tthis.streams = []; // Streams löschen, damit Änderung erkannt wird nach einloggen und Liste aktualisiert\n\t\t\t\tbreak;\n\n\t\t\tcase \"Started\":\n\t\t\t\tconsole.log(\"[ WorkerListener ] Event Started\");\n\n\t\t\t\tthis.createConnection();\n\t\t\t\t/*\n\t\t\t\twindow.setTimeout(()=>{\n\t\t\t\t\tthis.connect();\n\t\t\t\t}, 2000);*/\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.fireEvent(data[0], data[1]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport default WebRTMP_Controller;\n","class EventEmitter{\n\tListenerList = [];\n\n\tconstructor() {\n\t}\n\n\taddListener(event, listener){\n\t\tthis.ListenerList.push([event, listener]);\n\t}\n\n\tremoveListener(event, listener){\n\t\tfor(let i = 0; i < this.ListenerList.length;i++){\n\t\t\tlet entry = this.ListenerList[i];\n\t\t\tif(entry[0] == event && entry[1] == listener){\n\t\t\t\tthis.ListenerList.splice(i,1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveAllListeners(){\n\t\tthis.ListenerList = [];\n\t}\n\n\temit(event, data){\n\t\tconsole.log(\"emit EVENT: \" + event, data);\n\t\tfor(let i = 0; i < this.ListenerList.length;i++){\n\t\t\tlet entry = this.ListenerList[i];\n\t\t\tif(entry[0] == event){\n\t\t\t\tentry[1].call(this, data);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default EventEmitter;\n\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * This file is derived from dailymotion's hls.js library (hls.js/src/remux/mp4-generator.js)\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//  MP4 boxes generator for ISO BMFF (ISO Base Media File Format, defined in ISO/IEC 14496-12)\nclass MP4 {\n    static init() {\n        MP4.types = {\n            avc1: [], avcC: [], btrt: [], dinf: [],\n            dref: [], esds: [], ftyp: [], hdlr: [],\n            mdat: [], mdhd: [], mdia: [], mfhd: [],\n            minf: [], moof: [], moov: [], mp4a: [],\n            mvex: [], mvhd: [], sdtp: [], stbl: [],\n            stco: [], stsc: [], stsd: [], stsz: [],\n            stts: [], tfdt: [], tfhd: [], traf: [],\n            trak: [], trun: [], trex: [], tkhd: [],\n            vmhd: [], smhd: [], '.mp3': []\n        };\n\n        for (let name in MP4.types) {\n            if (MP4.types.hasOwnProperty(name)) {\n                MP4.types[name] = [\n                    name.charCodeAt(0),\n                    name.charCodeAt(1),\n                    name.charCodeAt(2),\n                    name.charCodeAt(3)\n                ];\n            }\n        }\n\n        let constants = MP4.constants = {};\n\n        constants.FTYP = new Uint8Array([\n            0x69, 0x73, 0x6F, 0x6D,  // major_brand: isom\n            0x0,  0x0,  0x0,  0x1,   // minor_version: 0x01\n            0x69, 0x73, 0x6F, 0x6D,  // isom\n            0x61, 0x76, 0x63, 0x31   // avc1\n        ]);\n\n        constants.STSD_PREFIX = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x01   // entry_count\n        ]);\n\n        constants.STTS = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00   // entry_count\n        ]);\n\n        constants.STSC = constants.STCO = constants.STTS;\n\n        constants.STSZ = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00,  // sample_size\n            0x00, 0x00, 0x00, 0x00   // sample_count\n        ]);\n\n        constants.HDLR_VIDEO = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00,  // pre_defined\n            0x76, 0x69, 0x64, 0x65,  // handler_type: 'vide'\n            0x00, 0x00, 0x00, 0x00,  // reserved: 3 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x56, 0x69, 0x64, 0x65,\n            0x6F, 0x48, 0x61, 0x6E,\n            0x64, 0x6C, 0x65, 0x72, 0x00  // name: VideoHandler\n        ]);\n\n        constants.HDLR_AUDIO = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00,  // pre_defined\n            0x73, 0x6F, 0x75, 0x6E,  // handler_type: 'soun'\n            0x00, 0x00, 0x00, 0x00,  // reserved: 3 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x53, 0x6F, 0x75, 0x6E,\n            0x64, 0x48, 0x61, 0x6E,\n            0x64, 0x6C, 0x65, 0x72, 0x00  // name: SoundHandler\n        ]);\n\n        constants.DREF = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x01,  // entry_count\n            0x00, 0x00, 0x00, 0x0C,  // entry_size\n            0x75, 0x72, 0x6C, 0x20,  // type 'url '\n            0x00, 0x00, 0x00, 0x01   // version(0) + flags\n        ]);\n\n        // Sound media header\n        constants.SMHD = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00   // balance(2) + reserved(2)\n        ]);\n\n        // video media header\n        constants.VMHD = new Uint8Array([\n            0x00, 0x00, 0x00, 0x01,  // version(0) + flags\n            0x00, 0x00,              // graphicsmode: 2 bytes\n            0x00, 0x00, 0x00, 0x00,  // opcolor: 3 * 2 bytes\n            0x00, 0x00\n        ]);\n    }\n\n    // Generate a box\n    static box(type) {\n        let size = 8;\n        let result;\n        let datas = Array.prototype.slice.call(arguments, 1);\n        let arrayCount = datas.length;\n\n        for (let i = 0; i < arrayCount; i++) {\n            size += datas[i].byteLength;\n        }\n\n        result = new Uint8Array(size);\n        result[0] = (size >>> 24) & 0xFF;  // size\n        result[1] = (size >>> 16) & 0xFF;\n        result[2] = (size >>>  8) & 0xFF;\n        result[3] = (size) & 0xFF;\n\n        result.set(type, 4);  // type\n\n        let offset = 8;\n        for (let i = 0; i < arrayCount; i++) {  // data body\n            result.set(datas[i], offset);\n            offset += datas[i].byteLength;\n        }\n\n        return result;\n    }\n\n    // emit ftyp & moov\n    static generateInitSegment(meta) {\n        let ftyp = MP4.box(MP4.types.ftyp, MP4.constants.FTYP);\n        let moov = MP4.moov(meta);\n\n        let result = new Uint8Array(ftyp.byteLength + moov.byteLength);\n        result.set(ftyp, 0);\n        result.set(moov, ftyp.byteLength);\n        return result;\n    }\n\n    // Movie metadata box\n    static moov(meta) {\n        let mvhd = MP4.mvhd(meta.timescale, meta.duration);\n        let trak = MP4.trak(meta);\n        let mvex = MP4.mvex(meta);\n        return MP4.box(MP4.types.moov, mvhd, trak, mvex);\n    }\n\n    // Movie header box\n    static mvhd(timescale, duration) {\n        return MP4.box(MP4.types.mvhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00,  // creation_time\n            0x00, 0x00, 0x00, 0x00,  // modification_time\n            (timescale >>> 24) & 0xFF,  // timescale: 4 bytes\n            (timescale >>> 16) & 0xFF,\n            (timescale >>>  8) & 0xFF,\n            (timescale) & 0xFF,\n            (duration >>> 24) & 0xFF,   // duration: 4 bytes\n            (duration >>> 16) & 0xFF,\n            (duration >>>  8) & 0xFF,\n            (duration) & 0xFF,\n            0x00, 0x01, 0x00, 0x00,  // Preferred rate: 1.0\n            0x01, 0x00, 0x00, 0x00,  // PreferredVolume(1.0, 2bytes) + reserved(2bytes)\n            0x00, 0x00, 0x00, 0x00,  // reserved: 4 + 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00,  // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00,  // ----end composition matrix----\n            0x00, 0x00, 0x00, 0x00,  // ----begin pre_defined 6 * 4 bytes----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,  // ----end pre_defined 6 * 4 bytes----\n            0xFF, 0xFF, 0xFF, 0xFF   // next_track_ID\n        ]));\n    }\n\n    // Track box\n    static trak(meta) {\n        return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));\n    }\n\n    // Track header box\n    static tkhd(meta) {\n        let trackId = meta.id, duration = meta.duration;\n        let width = meta.presentWidth, height = meta.presentHeight;\n\n        return MP4.box(MP4.types.tkhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x07,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00,  // creation_time\n            0x00, 0x00, 0x00, 0x00,  // modification_time\n            (trackId >>> 24) & 0xFF,  // track_ID: 4 bytes\n            (trackId >>> 16) & 0xFF,\n            (trackId >>>  8) & 0xFF,\n            (trackId) & 0xFF,\n            0x00, 0x00, 0x00, 0x00,  // reserved: 4 bytes\n            (duration >>> 24) & 0xFF, // duration: 4 bytes\n            (duration >>> 16) & 0xFF,\n            (duration >>>  8) & 0xFF,\n            (duration) & 0xFF,\n            0x00, 0x00, 0x00, 0x00,  // reserved: 2 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,  // layer(2bytes) + alternate_group(2bytes)\n            0x00, 0x00, 0x00, 0x00,  // volume(2bytes) + reserved(2bytes)\n            0x00, 0x01, 0x00, 0x00,  // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00,  // ----end composition matrix----\n            (width >>> 8) & 0xFF,    // width and height\n            (width) & 0xFF,\n            0x00, 0x00,\n            (height >>> 8) & 0xFF,\n            (height) & 0xFF,\n            0x00, 0x00\n        ]));\n    }\n\n    // Media Box\n    static mdia(meta) {\n        return MP4.box(MP4.types.mdia, MP4.mdhd(meta), MP4.hdlr(meta), MP4.minf(meta));\n    }\n\n    // Media header box\n    static mdhd(meta) {\n        let timescale = meta.timescale;\n        let duration = meta.duration;\n        return MP4.box(MP4.types.mdhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            0x00, 0x00, 0x00, 0x00,  // creation_time\n            0x00, 0x00, 0x00, 0x00,  // modification_time\n            (timescale >>> 24) & 0xFF,  // timescale: 4 bytes\n            (timescale >>> 16) & 0xFF,\n            (timescale >>>  8) & 0xFF,\n            (timescale) & 0xFF,\n            (duration >>> 24) & 0xFF,   // duration: 4 bytes\n            (duration >>> 16) & 0xFF,\n            (duration >>>  8) & 0xFF,\n            (duration) & 0xFF,\n            0x55, 0xC4,             // language: und (undetermined)\n            0x00, 0x00              // pre_defined = 0\n        ]));\n    }\n\n    // Media handler reference box\n    static hdlr(meta) {\n        let data;\n        if (meta.type === 'audio') {\n            data = MP4.constants.HDLR_AUDIO;\n        } else {\n            data = MP4.constants.HDLR_VIDEO;\n        }\n        return MP4.box(MP4.types.hdlr, data);\n    }\n\n    // Media infomation box\n    static minf(meta) {\n        let xmhd;\n        if (meta.type === 'audio') {\n            xmhd = MP4.box(MP4.types.smhd, MP4.constants.SMHD);\n        } else {\n            xmhd = MP4.box(MP4.types.vmhd, MP4.constants.VMHD);\n        }\n        return MP4.box(MP4.types.minf, xmhd, MP4.dinf(), MP4.stbl(meta));\n    }\n\n    // Data infomation box\n    static dinf() {\n        return MP4.box(MP4.types.dinf,\n            MP4.box(MP4.types.dref, MP4.constants.DREF)\n        );\n    }\n\n    // Sample table box\n    static stbl(meta) {\n        return MP4.box(MP4.types.stbl,  // type: stbl\n            MP4.stsd(meta),  // Sample Description Table\n            MP4.box(MP4.types.stts, MP4.constants.STTS),  // Time-To-Sample\n            MP4.box(MP4.types.stsc, MP4.constants.STSC),  // Sample-To-Chunk\n            MP4.box(MP4.types.stsz, MP4.constants.STSZ),  // Sample size\n            MP4.box(MP4.types.stco, MP4.constants.STCO)   // Chunk offset\n        );\n    }\n\n    // Sample description box\n    static stsd(meta) {\n        if (meta.type === 'audio') {\n            if (meta.codec === 'mp3') {\n                return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp3(meta));\n            }\n            // else: aac -> mp4a\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp4a(meta));\n        } else {\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.avc1(meta));\n        }\n    }\n\n    static mp3(meta) {\n        let channelCount = meta.channelCount;\n        let sampleRate = meta.audioSampleRate;\n\n        let data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\n            0x00, 0x00, 0x00, 0x01,  // reserved(2) + data_reference_index(2)\n            0x00, 0x00, 0x00, 0x00,  // reserved: 2 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, channelCount,      // channelCount(2)\n            0x00, 0x10,              // sampleSize(2)\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\n            (sampleRate >>> 8) & 0xFF,  // Audio sample rate\n            (sampleRate) & 0xFF,\n            0x00, 0x00\n        ]);\n\n        return MP4.box(MP4.types['.mp3'], data);\n    }\n\n    static mp4a(meta) {\n        let channelCount = meta.channelCount;\n        let sampleRate = meta.audioSampleRate;\n\n        let data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\n            0x00, 0x00, 0x00, 0x01,  // reserved(2) + data_reference_index(2)\n            0x00, 0x00, 0x00, 0x00,  // reserved: 2 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, channelCount,      // channelCount(2)\n            0x00, 0x10,              // sampleSize(2)\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\n            (sampleRate >>> 8) & 0xFF,  // Audio sample rate\n            (sampleRate) & 0xFF,\n            0x00, 0x00\n        ]);\n\n        return MP4.box(MP4.types.mp4a, data, MP4.esds(meta));\n    }\n\n    static esds(meta) {\n        let config = meta.config || [];\n        let configSize = config.length;\n        let data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version 0 + flags\n\n            0x03,                    // descriptor_type\n            0x17 + configSize,       // length3\n            0x00, 0x01,              // es_id\n            0x00,                    // stream_priority\n\n            0x04,                    // descriptor_type\n            0x0F + configSize,       // length\n            0x40,                    // codec: mpeg4_audio\n            0x15,                    // stream_type: Audio\n            0x00, 0x00, 0x00,        // buffer_size\n            0x00, 0x00, 0x00, 0x00,  // maxBitrate\n            0x00, 0x00, 0x00, 0x00,  // avgBitrate\n\n            0x05                     // descriptor_type\n        ].concat([\n            configSize\n        ]).concat(\n            config\n        ).concat([\n            0x06, 0x01, 0x02         // GASpecificConfig\n        ]));\n        return MP4.box(MP4.types.esds, data);\n    }\n\n    static avc1(meta) {\n        let avcc = meta.avcc;\n        let width = meta.codecWidth, height = meta.codecHeight;\n\n        let data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // reserved(4)\n            0x00, 0x00, 0x00, 0x01,  // reserved(2) + data_reference_index(2)\n            0x00, 0x00, 0x00, 0x00,  // pre_defined(2) + reserved(2)\n            0x00, 0x00, 0x00, 0x00,  // pre_defined: 3 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            (width >>> 8) & 0xFF,    // width: 2 bytes\n            (width) & 0xFF,\n            (height >>> 8) & 0xFF,   // height: 2 bytes\n            (height) & 0xFF,\n            0x00, 0x48, 0x00, 0x00,  // horizresolution: 4 bytes\n            0x00, 0x48, 0x00, 0x00,  // vertresolution: 4 bytes\n            0x00, 0x00, 0x00, 0x00,  // reserved: 4 bytes\n            0x00, 0x01,              // frame_count\n            0x0A,                    // strlen\n            0x78, 0x71, 0x71, 0x2F,  // compressorname: 32 bytes\n            0x66, 0x6C, 0x76, 0x2E,\n            0x6A, 0x73, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00,\n            0x00, 0x18,              // depth\n            0xFF, 0xFF               // pre_defined = -1\n        ]);\n        return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));\n    }\n\n    // Movie Extends box\n    static mvex(meta) {\n        return MP4.box(MP4.types.mvex, MP4.trex(meta));\n    }\n\n    // Track Extends box\n    static trex(meta) {\n        let trackId = meta.id;\n        let data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) + flags\n            (trackId >>> 24) & 0xFF, // track_ID\n            (trackId >>> 16) & 0xFF,\n            (trackId >>>  8) & 0xFF,\n            (trackId) & 0xFF,\n            0x00, 0x00, 0x00, 0x01,  // default_sample_description_index\n            0x00, 0x00, 0x00, 0x00,  // default_sample_duration\n            0x00, 0x00, 0x00, 0x00,  // default_sample_size\n            0x00, 0x01, 0x00, 0x01   // default_sample_flags\n        ]);\n        return MP4.box(MP4.types.trex, data);\n    }\n\n    // Movie fragment box\n    static moof(track, baseMediaDecodeTime) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(track.sequenceNumber), MP4.traf(track, baseMediaDecodeTime));\n    }\n\n    static mfhd(sequenceNumber) {\n        let data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,\n            (sequenceNumber >>> 24) & 0xFF,  // sequence_number: int32\n            (sequenceNumber >>> 16) & 0xFF,\n            (sequenceNumber >>>  8) & 0xFF,\n            (sequenceNumber) & 0xFF\n        ]);\n        return MP4.box(MP4.types.mfhd, data);\n    }\n\n    // Track fragment box\n    static traf(track, baseMediaDecodeTime) {\n        let trackId = track.id;\n\n        // Track fragment header box\n        let tfhd = MP4.box(MP4.types.tfhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) & flags\n            (trackId >>> 24) & 0xFF, // track_ID\n            (trackId >>> 16) & 0xFF,\n            (trackId >>>  8) & 0xFF,\n            (trackId) & 0xFF\n        ]));\n        // Track Fragment Decode Time\n        let tfdt = MP4.box(MP4.types.tfdt, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,  // version(0) & flags\n            (baseMediaDecodeTime >>> 24) & 0xFF,  // baseMediaDecodeTime: int32\n            (baseMediaDecodeTime >>> 16) & 0xFF,\n            (baseMediaDecodeTime >>>  8) & 0xFF,\n            (baseMediaDecodeTime) & 0xFF\n        ]));\n        let sdtp = MP4.sdtp(track);\n        let trun = MP4.trun(track, sdtp.byteLength + 16 + 16 + 8 + 16 + 8 + 8);\n\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun, sdtp);\n    }\n\n    // Sample Dependency Type box\n    static sdtp(track) {\n        let samples = track.samples || [];\n        let sampleCount = samples.length;\n        let data = new Uint8Array(4 + sampleCount);\n        // 0~4 bytes: version(0) & flags\n        for (let i = 0; i < sampleCount; i++) {\n            let flags = samples[i].flags;\n            data[i + 4] = (flags.isLeading << 6)    // is_leading: 2 (bit)\n                | (flags.dependsOn << 4)    // sample_depends_on\n                | (flags.isDependedOn << 2) // sample_is_depended_on\n                | (flags.hasRedundancy);    // sample_has_redundancy\n        }\n        return MP4.box(MP4.types.sdtp, data);\n    }\n\n    // Track fragment run box\n    static trun(track, offset) {\n        let samples = track.samples || [];\n        let sampleCount = samples.length;\n        let dataSize = 12 + 16 * sampleCount;\n        let data = new Uint8Array(dataSize);\n        offset += 8 + dataSize;\n\n        data.set([\n            0x00, 0x00, 0x0F, 0x01,      // version(0) & flags\n            (sampleCount >>> 24) & 0xFF, // sample_count\n            (sampleCount >>> 16) & 0xFF,\n            (sampleCount >>>  8) & 0xFF,\n            (sampleCount) & 0xFF,\n            (offset >>> 24) & 0xFF,      // data_offset\n            (offset >>> 16) & 0xFF,\n            (offset >>>  8) & 0xFF,\n            (offset) & 0xFF\n        ], 0);\n\n        for (let i = 0; i < sampleCount; i++) {\n            let duration = samples[i].duration;\n            let size = samples[i].size;\n            let flags = samples[i].flags;\n            let cts = samples[i].cts;\n            data.set([\n                (duration >>> 24) & 0xFF,  // sample_duration\n                (duration >>> 16) & 0xFF,\n                (duration >>>  8) & 0xFF,\n                (duration) & 0xFF,\n                (size >>> 24) & 0xFF,      // sample_size\n                (size >>> 16) & 0xFF,\n                (size >>>  8) & 0xFF,\n                (size) & 0xFF,\n                (flags.isLeading << 2) | flags.dependsOn,  // sample_flags\n                (flags.isDependedOn << 6) | (flags.hasRedundancy << 4) | flags.isNonSync,\n                0x00, 0x00,                // sample_degradation_priority\n                (cts >>> 24) & 0xFF,       // sample_composition_time_offset\n                (cts >>> 16) & 0xFF,\n                (cts >>>  8) & 0xFF,\n                (cts) & 0xFF\n            ], 12 + 16 * i);\n        }\n        return MP4.box(MP4.types.trun, data);\n    }\n\n    static mdat(data) {\n        return MP4.box(MP4.types.mdat, data);\n    }\n\n}\n\nMP4.init();\n\nexport default MP4;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Represents an media sample (audio / video)\nexport class SampleInfo {\n\n\tconstructor(dts, pts, duration, originalDts, isSync) {\n\t\tthis.dts = dts;\n\t\tthis.pts = pts;\n\t\tthis.duration = duration;\n\t\tthis.originalDts = originalDts;\n\t\tthis.isSyncPoint = isSync;\n\t\tthis.fileposition = null;\n\t}\n\n}\n\n// Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\nexport class MediaSegmentInfo {\n\n\tconstructor() {\n\t\tthis.beginDts = 0;\n\t\tthis.endDts = 0;\n\t\tthis.beginPts = 0;\n\t\tthis.endPts = 0;\n\t\tthis.originalBeginDts = 0;\n\t\tthis.originalEndDts = 0;\n\t\tthis.syncPoints = [];     // SampleInfo[n], for video IDR frames only\n\t\tthis.firstSample = null;  // SampleInfo\n\t\tthis.lastSample = null;   // SampleInfo\n\t}\n\n\tappendSyncPoint(sampleInfo) {  // also called Random Access Point\n\t\tsampleInfo.isSyncPoint = true;\n\t\tthis.syncPoints.push(sampleInfo);\n\t}\n\n}\n\n// Ordered list for recording video IDR frames, sorted by originalDts\nexport class IDRSampleList {\n\n\tconstructor() {\n\t\tthis._list = [];\n\t}\n\n\tclear() {\n\t\tthis._list = [];\n\t}\n\n\tappendArray(syncPoints) {\n\t\tlet list = this._list;\n\n\t\tif (syncPoints.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n\t\t\tthis.clear();\n\t\t}\n\n\t\tArray.prototype.push.apply(list, syncPoints);\n\t}\n\n\tgetLastSyncPointBeforeDts(dts) {\n\t\tif (this._list.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet list = this._list;\n\t\tlet idx = 0;\n\t\tlet last = list.length - 1;\n\t\tlet mid = 0;\n\t\tlet lbound = 0;\n\t\tlet ubound = last;\n\n\t\tif (dts < list[0].dts) {\n\t\t\tidx = 0;\n\t\t\tlbound = ubound + 1;\n\t\t}\n\n\t\twhile (lbound <= ubound) {\n\t\t\tmid = lbound + Math.floor((ubound - lbound) / 2);\n\t\t\tif (mid === last || (dts >= list[mid].dts && dts < list[mid + 1].dts)) {\n\t\t\t\tidx = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (list[mid].dts < dts) {\n\t\t\t\tlbound = mid + 1;\n\t\t\t} else {\n\t\t\t\tubound = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn this._list[idx];\n\t}\n\n}\n\n// Data structure for recording information of media segments in single track.\nexport class MediaSegmentInfoList {\n\n\tconstructor(type) {\n\t\tthis._type = type;\n\t\tthis._list = [];\n\t\tthis._lastAppendLocation = -1;  // cached last insert location\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget length() {\n\t\treturn this._list.length;\n\t}\n\n\tisEmpty() {\n\t\treturn this._list.length === 0;\n\t}\n\n\tclear() {\n\t\tthis._list = [];\n\t\tthis._lastAppendLocation = -1;\n\t}\n\n\t_searchNearestSegmentBefore(originalBeginDts) {\n\t\tlet list = this._list;\n\t\tif (list.length === 0) {\n\t\t\treturn -2;\n\t\t}\n\t\tlet last = list.length - 1;\n\t\tlet mid = 0;\n\t\tlet lbound = 0;\n\t\tlet ubound = last;\n\n\t\tlet idx = 0;\n\n\t\tif (originalBeginDts < list[0].originalBeginDts) {\n\t\t\tidx = -1;\n\t\t\treturn idx;\n\t\t}\n\n\t\twhile (lbound <= ubound) {\n\t\t\tmid = lbound + Math.floor((ubound - lbound) / 2);\n\t\t\tif (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\n\t\t\t\t(originalBeginDts < list[mid + 1].originalBeginDts))) {\n\t\t\t\tidx = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (list[mid].originalBeginDts < originalBeginDts) {\n\t\t\t\tlbound = mid + 1;\n\t\t\t} else {\n\t\t\t\tubound = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\n\t_searchNearestSegmentAfter(originalBeginDts) {\n\t\treturn this._searchNearestSegmentBefore(originalBeginDts) + 1;\n\t}\n\n\tappend(mediaSegmentInfo) {\n\t\tlet list = this._list;\n\t\tlet msi = mediaSegmentInfo;\n\t\tlet lastAppendIdx = this._lastAppendLocation;\n\t\tlet insertIdx = 0;\n\n\t\tif (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\n\t\t\tmsi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\n\t\t\t((lastAppendIdx === list.length - 1) ||\n\t\t\t\t(lastAppendIdx < list.length - 1 &&\n\t\t\t\t\tmsi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\n\t\t\tinsertIdx = lastAppendIdx + 1;  // use cached location idx\n\t\t} else {\n\t\t\tif (list.length > 0) {\n\t\t\t\tinsertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n\t\t\t}\n\t\t}\n\n\t\tthis._lastAppendLocation = insertIdx;\n\t\tthis._list.splice(insertIdx, 0, msi);\n\t}\n\n\tgetLastSegmentBefore(originalBeginDts) {\n\t\tlet idx = this._searchNearestSegmentBefore(originalBeginDts);\n\t\tif (idx >= 0) {\n\t\t\treturn this._list[idx];\n\t\t} else {  // -1\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetLastSampleBefore(originalBeginDts) {\n\t\tlet segment = this.getLastSegmentBefore(originalBeginDts);\n\t\tif (segment != null) {\n\t\t\treturn segment.lastSample;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetLastSyncPointBefore(originalBeginDts) {\n\t\tlet segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n\t\tlet syncPoints = this._list[segmentIdx].syncPoints;\n\t\twhile (syncPoints.length === 0 && segmentIdx > 0) {\n\t\t\tsegmentIdx--;\n\t\t\tsyncPoints = this._list[segmentIdx].syncPoints;\n\t\t}\n\t\tif (syncPoints.length > 0) {\n\t\t\treturn syncPoints[syncPoints.length - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * This file is modified from dailymotion's hls.js library (hls.js/src/helper/aac.js)\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass AAC {\n\tstatic getSilentFrame(codec, channelCount) {\n\t\tif (codec === 'mp4a.40.2') {\n\t\t\t// handle LC-AAC\n\t\t\tif (channelCount === 1) {\n\t\t\t\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n\t\t\t} else if (channelCount === 2) {\n\t\t\t\treturn new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n\t\t\t} else if (channelCount === 3) {\n\t\t\t\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n\t\t\t} else if (channelCount === 4) {\n\t\t\t\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n\t\t\t} else if (channelCount === 5) {\n\t\t\t\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n\t\t\t} else if (channelCount === 6) {\n\t\t\t\treturn new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n\t\t\t}\n\t\t} else {\n\t\t\t// handle HE-AAC (mp4a.40.5 / mp4a.40.29)\n\t\t\tif (channelCount === 1) {\n\t\t\t\t// ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n\t\t\t\treturn new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n\t\t\t} else if (channelCount === 2) {\n\t\t\t\t// ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n\t\t\t\treturn new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n\t\t\t} else if (channelCount === 3) {\n\t\t\t\t// ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n\t\t\t\treturn new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n}\n\nexport default AAC;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class RuntimeException {\n    constructor(message) {\n        this._message = message;\n    }\n\n    get name() {\n        return 'RuntimeException';\n    }\n\n    get message() {\n        return this._message;\n    }\n\n    toString() {\n        return this.name + ': ' + this.message;\n    }\n}\n\nexport class IllegalStateException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'IllegalStateException';\n    }\n}\n\nexport class InvalidArgumentException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'InvalidArgumentException';\n    }\n}\n\nexport class NotImplementedException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'NotImplementedException';\n    }\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet Browser = {};\n\nfunction detect() {\n\t// modified from jquery-browser-plugin\n\n\tlet ua = self.navigator.userAgent.toLowerCase();\n\n\tlet match = /(edge)\\/([\\w.]+)/.exec(ua) ||\n\t\t/(opr)[\\/]([\\w.]+)/.exec(ua) ||\n\t\t/(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(iemobile)[\\/]([\\w.]+)/.exec(ua) ||\n\t\t/(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(msie) ([\\w.]+)/.exec(ua) ||\n\t\tua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua) ||\n\t\tua.indexOf('compatible') < 0 && /(firefox)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t[];\n\n\tlet platform_match = /(ipad)/.exec(ua) ||\n\t\t/(ipod)/.exec(ua) ||\n\t\t/(windows phone)/.exec(ua) ||\n\t\t/(iphone)/.exec(ua) ||\n\t\t/(kindle)/.exec(ua) ||\n\t\t/(android)/.exec(ua) ||\n\t\t/(windows)/.exec(ua) ||\n\t\t/(mac)/.exec(ua) ||\n\t\t/(linux)/.exec(ua) ||\n\t\t/(cros)/.exec(ua) ||\n\t\t[];\n\n\tlet matched = {\n\t\tbrowser: match[5] || match[3] || match[1] || '',\n\t\tversion: match[2] || match[4] || '0',\n\t\tmajorVersion: match[4] || match[2] || '0',\n\t\tplatform: platform_match[0] || ''\n\t};\n\n\tlet browser = {};\n\tif (matched.browser) {\n\t\tbrowser[matched.browser] = true;\n\n\t\tlet versionArray = matched.majorVersion.split('.');\n\t\tbrowser.version = {\n\t\t\tmajor: parseInt(matched.majorVersion, 10),\n\t\t\tstring: matched.version\n\t\t};\n\t\tif (versionArray.length > 1) {\n\t\t\tbrowser.version.minor = parseInt(versionArray[1], 10);\n\t\t}\n\t\tif (versionArray.length > 2) {\n\t\t\tbrowser.version.build = parseInt(versionArray[2], 10);\n\t\t}\n\t}\n\n\tif (matched.platform) {\n\t\tbrowser[matched.platform] = true;\n\t}\n\n\tif (browser.chrome || browser.opr || browser.safari) {\n\t\tbrowser.webkit = true;\n\t}\n\n\t// MSIE. IE11 has 'rv' identifer\n\tif (browser.rv || browser.iemobile) {\n\t\tif (browser.rv) {\n\t\t\tdelete browser.rv;\n\t\t}\n\t\tlet msie = 'msie';\n\t\tmatched.browser = msie;\n\t\tbrowser[msie] = true;\n\t}\n\n\t// Microsoft Edge\n\tif (browser.edge) {\n\t\tdelete browser.edge;\n\t\tlet msedge = 'msedge';\n\t\tmatched.browser = msedge;\n\t\tbrowser[msedge] = true;\n\t}\n\n\t// Opera 15+\n\tif (browser.opr) {\n\t\tlet opera = 'opera';\n\t\tmatched.browser = opera;\n\t\tbrowser[opera] = true;\n\t}\n\n\t// Stock android browsers are marked as Safari\n\tif (browser.safari && browser.android) {\n\t\tlet android = 'android';\n\t\tmatched.browser = android;\n\t\tbrowser[android] = true;\n\t}\n\n\tbrowser.name = matched.browser;\n\tbrowser.platform = matched.platform;\n\n\tfor (let key in Browser) {\n\t\tif (Browser.hasOwnProperty(key)) {\n\t\t\tdelete Browser[key];\n\t\t}\n\t}\n\tObject.assign(Browser, browser);\n}\n\ndetect();\n\nexport default Browser;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// Fragmented mp4 remuxer\nimport MP4 from \"./mp4\";\nimport {MediaSegmentInfo, MediaSegmentInfoList, SampleInfo} from \"./media-segment-info\";\nimport AAC from \"./aac-silent\";\nimport {IllegalStateException} from \"../utils/exception\";\nimport Browser from \"../utils/browser\";\n\nclass MP4Remuxer {\n\n\tconstructor(config) {\n\t\tthis.TAG = 'MP4Remuxer';\n\n\t\tthis._config = config;\n\t\tthis._isLive = (config.isLive === true) ? true : false;\n\n\t\tthis._dtsBase = -1;\n\t\tthis._dtsBaseInited = false;\n\t\tthis._audioDtsBase = Infinity;\n\t\tthis._videoDtsBase = Infinity;\n\t\tthis._audioNextDts = undefined;\n\t\tthis._videoNextDts = undefined;\n\t\tthis._audioStashedLastSample = null;\n\t\tthis._videoStashedLastSample = null;\n\n\t\tthis._audioMeta = null;\n\t\tthis._videoMeta = null;\n\n\t\tthis._audioSegmentInfoList = new MediaSegmentInfoList('audio');\n\t\tthis._videoSegmentInfoList = new MediaSegmentInfoList('video');\n\n\t\tthis._onInitSegment = null;\n\t\tthis._onMediaSegment = null;\n\n\t\t// Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n\t\t// see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n\t\tthis._forceFirstIDR = (Browser.chrome &&\n\t\t\t(Browser.version.major < 50 ||\n\t\t\t\t(Browser.version.major === 50 && Browser.version.build < 2661))) ? true : false;\n\n\t\t// Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\n\t\t// Make audio beginDts equals with video beginDts, in order to fix seek freeze\n\t\tthis._fillSilentAfterSeek = (Browser.msedge || Browser.msie);\n\n\t\t// While only FireFox supports 'audio/mp4, codecs=\"mp3\"', use 'audio/mpeg' for chrome, safari, ...\n\t\tthis._mp3UseMpegAudio = !Browser.firefox;\n\n\t\tthis._fillAudioTimestampGap = this._config.fixAudioTimestampGap;\n\t}\n\n\tdestroy() {\n\t\tthis._dtsBase = -1;\n\t\tthis._dtsBaseInited = false;\n\t\tthis._audioMeta = null;\n\t\tthis._videoMeta = null;\n\t\tthis._audioSegmentInfoList.clear();\n\t\tthis._audioSegmentInfoList = null;\n\t\tthis._videoSegmentInfoList.clear();\n\t\tthis._videoSegmentInfoList = null;\n\t\tthis._onInitSegment = null;\n\t\tthis._onMediaSegment = null;\n\t}\n\n\tbindDataSource(producer) {\n\t\tproducer.onDataAvailable = this.remux.bind(this);\n\t\tproducer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n\t\treturn this;\n\t}\n\n\tget onInitSegment() {\n\t\treturn this._onInitSegment;\n\t}\n\n\tset onInitSegment(callback) {\n\t\tthis._onInitSegment = callback;\n\t}\n\n\tget onMediaSegment() {\n\t\treturn this._onMediaSegment;\n\t}\n\n\tset onMediaSegment(callback) {\n\t\tthis._onMediaSegment = callback;\n\t}\n\n\tinsertDiscontinuity() {\n\t\tthis._audioNextDts = this._videoNextDts = undefined;\n\t}\n\n\tseek(originalDts) {\n\t\tthis._audioStashedLastSample = null;\n\t\tthis._videoStashedLastSample = null;\n\t\tthis._videoSegmentInfoList.clear();\n\t\tthis._audioSegmentInfoList.clear();\n\t}\n\n\tremux(audioTrack, videoTrack) {\n\t\tif (!this._onMediaSegment) {\n\t\t\tthrow new IllegalStateException('MP4Remuxer: onMediaSegment callback must be specificed!');\n\t\t}\n\t\tif (!this._dtsBaseInited) {\n\t\t\tthis._calculateDtsBase(audioTrack, videoTrack);\n\t\t}\n\t\tthis._remuxVideo(videoTrack);\n\t\tthis._remuxAudio(audioTrack);\n\t}\n\n\t_onTrackMetadataReceived(type, metadata) {\n\t\tlet metabox = null;\n\n\t\tlet container = 'mp4';\n\t\tlet codec = metadata.codec;\n\n\t\tif (type === 'audio') {\n\t\t\tthis._audioMeta = metadata;\n\t\t\tif (metadata.codec === 'mp3' && this._mp3UseMpegAudio) {\n\t\t\t\t// 'audio/mpeg' for MP3 audio track\n\t\t\t\tcontainer = 'mpeg';\n\t\t\t\tcodec = '';\n\t\t\t\tmetabox = new Uint8Array();\n\t\t\t} else {\n\t\t\t\t// 'audio/mp4, codecs=\"codec\"'\n\t\t\t\tmetabox = MP4.generateInitSegment(metadata);\n\t\t\t}\n\t\t} else if (type === 'video') {\n\t\t\tthis._videoMeta = metadata;\n\t\t\tmetabox = MP4.generateInitSegment(metadata);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// dispatch metabox (Initialization Segment)\n\t\tif (!this._onInitSegment) {\n\t\t\tthrow new IllegalStateException('MP4Remuxer: onInitSegment callback must be specified!');\n\t\t}\n\t\tthis._onInitSegment(type, {\n\t\t\ttype: type,\n\t\t\tdata: metabox.buffer,\n\t\t\tcodec: codec,\n\t\t\tcontainer: `${type}/${container}`,\n\t\t\tmediaDuration: metadata.duration  // in timescale 1000 (milliseconds)\n\t\t});\n\t}\n\n\t_calculateDtsBase(audioTrack, videoTrack) {\n\t\tif (this._dtsBaseInited) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (audioTrack.samples && audioTrack.samples.length) {\n\t\t\tthis._audioDtsBase = audioTrack.samples[0].dts;\n\t\t}\n\t\tif (videoTrack.samples && videoTrack.samples.length) {\n\t\t\tthis._videoDtsBase = videoTrack.samples[0].dts;\n\t\t}\n\n\t\tthis._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\n\t\tthis._dtsBaseInited = true;\n\t}\n\n\tflushStashedSamples() {\n\t\tlet videoSample = this._videoStashedLastSample;\n\t\tlet audioSample = this._audioStashedLastSample;\n\n\t\tlet videoTrack = {\n\t\t\ttype: 'video',\n\t\t\tid: 1,\n\t\t\tsequenceNumber: 0,\n\t\t\tsamples: [],\n\t\t\tlength: 0\n\t\t};\n\n\t\tif (videoSample != null) {\n\t\t\tvideoTrack.samples.push(videoSample);\n\t\t\tvideoTrack.length = videoSample.length;\n\t\t}\n\n\t\tlet audioTrack = {\n\t\t\ttype: 'audio',\n\t\t\tid: 2,\n\t\t\tsequenceNumber: 0,\n\t\t\tsamples: [],\n\t\t\tlength: 0\n\t\t};\n\n\t\tif (audioSample != null) {\n\t\t\taudioTrack.samples.push(audioSample);\n\t\t\taudioTrack.length = audioSample.length;\n\t\t}\n\n\t\tthis._videoStashedLastSample = null;\n\t\tthis._audioStashedLastSample = null;\n\n\t\tthis._remuxVideo(videoTrack, true);\n\t\tthis._remuxAudio(audioTrack, true);\n\t}\n\n\t_remuxAudio(audioTrack, force) {\n\t\tif (this._audioMeta == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet track = audioTrack;\n\t\tlet samples = track.samples;\n\t\tlet dtsCorrection = undefined;\n\t\tlet firstDts = -1, lastDts = -1, lastPts = -1;\n\t\tlet refSampleDuration = this._audioMeta.refSampleDuration;\n\n\t\tlet mpegRawTrack = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio;\n\t\tlet firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === undefined;\n\n\t\tlet insertPrefixSilentFrame = false;\n\n\t\tif (!samples || samples.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (samples.length === 1 && !force) {\n\t\t\t// If [sample count in current batch] === 1 && (force != true)\n\t\t\t// Ignore and keep in demuxer's queue\n\t\t\treturn;\n\t\t}  // else if (force === true) do remux\n\n\t\tlet offset = 0;\n\t\tlet mdatbox = null;\n\t\tlet mdatBytes = 0;\n\n\t\t// calculate initial mdat size\n\t\tif (mpegRawTrack) {\n\t\t\t// for raw mpeg buffer\n\t\t\toffset = 0;\n\t\t\tmdatBytes = track.length;\n\t\t} else {\n\t\t\t// for fmp4 mdat box\n\t\t\toffset = 8;  // size + type\n\t\t\tmdatBytes = 8 + track.length;\n\t\t}\n\n\n\t\tlet lastSample = null;\n\n\t\t// Pop the lastSample and waiting for stash\n\t\tif (samples.length > 1) {\n\t\t\tlastSample = samples.pop();\n\t\t\tmdatBytes -= lastSample.length;\n\t\t}\n\n\t\t// Insert [stashed lastSample in the previous batch] to the front\n\t\tif (this._audioStashedLastSample != null) {\n\t\t\tlet sample = this._audioStashedLastSample;\n\t\t\tthis._audioStashedLastSample = null;\n\t\t\tsamples.unshift(sample);\n\t\t\tmdatBytes += sample.length;\n\t\t}\n\n\t\t// Stash the lastSample of current batch, waiting for next batch\n\t\tif (lastSample != null) {\n\t\t\tthis._audioStashedLastSample = lastSample;\n\t\t}\n\n\n\t\tlet firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n\t\t// calculate dtsCorrection\n\t\tif (this._audioNextDts) {\n\t\t\tdtsCorrection = firstSampleOriginalDts - this._audioNextDts;\n\t\t} else {  // this._audioNextDts == undefined\n\t\t\tif (this._audioSegmentInfoList.isEmpty()) {\n\t\t\t\tdtsCorrection = 0;\n\t\t\t\tif (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\n\t\t\t\t\tif (this._audioMeta.originalCodec !== 'mp3') {\n\t\t\t\t\t\tinsertPrefixSilentFrame = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet lastSample = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n\t\t\t\tif (lastSample != null) {\n\t\t\t\t\tlet distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n\t\t\t\t\tif (distance <= 3) {\n\t\t\t\t\t\tdistance = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlet expectedDts = lastSample.dts + lastSample.duration + distance;\n\t\t\t\t\tdtsCorrection = firstSampleOriginalDts - expectedDts;\n\t\t\t\t} else { // lastSample == null, cannot found\n\t\t\t\t\tdtsCorrection = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (insertPrefixSilentFrame) {\n\t\t\t// align audio segment beginDts to match with current video segment's beginDts\n\t\t\tlet firstSampleDts = firstSampleOriginalDts - dtsCorrection;\n\t\t\tlet videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);\n\t\t\tif (videoSegment != null && videoSegment.beginDts < firstSampleDts) {\n\t\t\t\tlet silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n\t\t\t\tif (silentUnit) {\n\t\t\t\t\tlet dts = videoSegment.beginDts;\n\t\t\t\t\tlet silentFrameDuration = firstSampleDts - videoSegment.beginDts;\n\t\t\t\t\tLog.v(this.TAG, `InsertPrefixSilentAudio: dts: ${dts}, duration: ${silentFrameDuration}`);\n\t\t\t\t\tsamples.unshift({ unit: silentUnit, dts: dts, pts: dts });\n\t\t\t\t\tmdatBytes += silentUnit.byteLength;\n\t\t\t\t}  // silentUnit == null: Cannot generate, skip\n\t\t\t} else {\n\t\t\t\tinsertPrefixSilentFrame = false;\n\t\t\t}\n\t\t}\n\n\t\tlet mp4Samples = [];\n\n\t\t// Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n\t\tfor (let i = 0; i < samples.length; i++) {\n\t\t\tlet sample = samples[i];\n\t\t\tlet unit = sample.unit;\n\t\t\tlet originalDts = sample.dts - this._dtsBase;\n\t\t\tlet dts = originalDts;\n\t\t\tlet needFillSilentFrames = false;\n\t\t\tlet silentFrames = null;\n\t\t\tlet sampleDuration = 0;\n\n\t\t\tif (originalDts < -0.001) {\n\t\t\t\tcontinue; //pass the first sample with the invalid dts\n\t\t\t}\n\n\t\t\tif (this._audioMeta.codec !== 'mp3') {\n\t\t\t\t// for AAC codec, we need to keep dts increase based on refSampleDuration\n\t\t\t\tlet curRefDts = originalDts;\n\t\t\t\tconst maxAudioFramesDrift = 3;\n\t\t\t\tif (this._audioNextDts) {\n\t\t\t\t\tcurRefDts = this._audioNextDts;\n\t\t\t\t}\n\n\t\t\t\tdtsCorrection = originalDts - curRefDts;\n\t\t\t\tif (dtsCorrection <= -maxAudioFramesDrift * refSampleDuration) {\n\t\t\t\t\t// If we're overlapping by more than maxAudioFramesDrift number of frame, drop this sample\n\t\t\t\t\tLog.w(this.TAG, `Dropping 1 audio frame (originalDts: ${originalDts} ms ,curRefDts: ${curRefDts} ms)  due to dtsCorrection: ${dtsCorrection} ms overlap.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (dtsCorrection >= maxAudioFramesDrift * refSampleDuration && this._fillAudioTimestampGap && !Browser.safari) {\n\t\t\t\t\t// Silent frame generation, if large timestamp gap detected && config.fixAudioTimestampGap\n\t\t\t\t\tneedFillSilentFrames = true;\n\t\t\t\t\t// We need to insert silent frames to fill timestamp gap\n\t\t\t\t\tlet frameCount = Math.floor(dtsCorrection / refSampleDuration);\n\t\t\t\t\tLog.w(this.TAG, 'Large audio timestamp gap detected, may cause AV sync to drift. ' +\n\t\t\t\t\t\t'Silent frames will be generated to avoid unsync.\\n' +\n\t\t\t\t\t\t`originalDts: ${originalDts} ms, curRefDts: ${curRefDts} ms, ` +\n\t\t\t\t\t\t`dtsCorrection: ${Math.round(dtsCorrection)} ms, generate: ${frameCount} frames`);\n\n\n\t\t\t\t\tdts = Math.floor(curRefDts);\n\t\t\t\t\tsampleDuration = Math.floor(curRefDts + refSampleDuration) - dts;\n\n\t\t\t\t\tlet silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n\t\t\t\t\tif (silentUnit == null) {\n\t\t\t\t\t\tLog.w(this.TAG, 'Unable to generate silent frame for ' +\n\t\t\t\t\t\t\t`${this._audioMeta.originalCodec} with ${this._audioMeta.channelCount} channels, repeat last frame`);\n\t\t\t\t\t\t// Repeat last frame\n\t\t\t\t\t\tsilentUnit = unit;\n\t\t\t\t\t}\n\t\t\t\t\tsilentFrames = [];\n\n\t\t\t\t\tfor (let j = 0; j < frameCount; j++) {\n\t\t\t\t\t\tcurRefDts = curRefDts + refSampleDuration;\n\t\t\t\t\t\tlet intDts = Math.floor(curRefDts);  // change to integer\n\t\t\t\t\t\tlet intDuration = Math.floor(curRefDts + refSampleDuration) - intDts;\n\t\t\t\t\t\tlet frame = {\n\t\t\t\t\t\t\tdts: intDts,\n\t\t\t\t\t\t\tpts: intDts,\n\t\t\t\t\t\t\tcts: 0,\n\t\t\t\t\t\t\tunit: silentUnit,\n\t\t\t\t\t\t\tsize: silentUnit.byteLength,\n\t\t\t\t\t\t\tduration: intDuration,  // wait for next sample\n\t\t\t\t\t\t\toriginalDts: originalDts,\n\t\t\t\t\t\t\tflags: {\n\t\t\t\t\t\t\t\tisLeading: 0,\n\t\t\t\t\t\t\t\tdependsOn: 1,\n\t\t\t\t\t\t\t\tisDependedOn: 0,\n\t\t\t\t\t\t\t\thasRedundancy: 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsilentFrames.push(frame);\n\t\t\t\t\t\tmdatBytes += frame.size;;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._audioNextDts = curRefDts + refSampleDuration;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdts = Math.floor(curRefDts);\n\t\t\t\t\tsampleDuration = Math.floor(curRefDts + refSampleDuration) - dts;\n\t\t\t\t\tthis._audioNextDts = curRefDts + refSampleDuration;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// keep the original dts calculate algorithm for mp3\n\t\t\t\tdts = originalDts - dtsCorrection;\n\n\n\t\t\t\tif (i !== samples.length - 1) {\n\t\t\t\t\tlet nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n\t\t\t\t\tsampleDuration = nextDts - dts;\n\t\t\t\t} else {  // the last sample\n\t\t\t\t\tif (lastSample != null) {  // use stashed sample's dts to calculate sample duration\n\t\t\t\t\t\tlet nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n\t\t\t\t\t\tsampleDuration = nextDts - dts;\n\t\t\t\t\t} else if (mp4Samples.length >= 1) {  // use second last sample duration\n\t\t\t\t\t\tsampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n\t\t\t\t\t} else {  // the only one sample, use reference sample duration\n\t\t\t\t\t\tsampleDuration = Math.floor(refSampleDuration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._audioNextDts = dts + sampleDuration;\n\t\t\t}\n\n\t\t\tif (firstDts === -1) {\n\t\t\t\tfirstDts = dts;\n\t\t\t}\n\t\t\tmp4Samples.push({\n\t\t\t\tdts: dts,\n\t\t\t\tpts: dts,\n\t\t\t\tcts: 0,\n\t\t\t\tunit: sample.unit,\n\t\t\t\tsize: sample.unit.byteLength,\n\t\t\t\tduration: sampleDuration,\n\t\t\t\toriginalDts: originalDts,\n\t\t\t\tflags: {\n\t\t\t\t\tisLeading: 0,\n\t\t\t\t\tdependsOn: 1,\n\t\t\t\t\tisDependedOn: 0,\n\t\t\t\t\thasRedundancy: 0\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (needFillSilentFrames) {\n\t\t\t\t// Silent frames should be inserted after wrong-duration frame\n\t\t\t\tmp4Samples.push.apply(mp4Samples, silentFrames);\n\t\t\t}\n\t\t}\n\n\t\tif (mp4Samples.length === 0) {\n\t\t\t//no samples need to remux\n\t\t\ttrack.samples = [];\n\t\t\ttrack.length = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// allocate mdatbox\n\t\tif (mpegRawTrack) {\n\t\t\t// allocate for raw mpeg buffer\n\t\t\tmdatbox = new Uint8Array(mdatBytes);\n\t\t} else {\n\t\t\t// allocate for fmp4 mdat box\n\t\t\tmdatbox = new Uint8Array(mdatBytes);\n\t\t\t// size field\n\t\t\tmdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n\t\t\tmdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n\t\t\tmdatbox[2] = (mdatBytes >>> 8) & 0xFF;\n\t\t\tmdatbox[3] = (mdatBytes) & 0xFF;\n\t\t\t// type field (fourCC)\n\t\t\tmdatbox.set(MP4.types.mdat, 4);\n\t\t}\n\n\t\t// Write samples into mdatbox\n\t\tfor (let i = 0; i < mp4Samples.length; i++) {\n\t\t\tlet unit = mp4Samples[i].unit;\n\t\t\tmdatbox.set(unit, offset);\n\t\t\toffset += unit.byteLength;\n\t\t}\n\n\t\tlet latest = mp4Samples[mp4Samples.length - 1];\n\t\tlastDts = latest.dts + latest.duration;\n\t\t//this._audioNextDts = lastDts;\n\n\t\t// fill media segment info & add to info list\n\t\tlet info = new MediaSegmentInfo();\n\t\tinfo.beginDts = firstDts;\n\t\tinfo.endDts = lastDts;\n\t\tinfo.beginPts = firstDts;\n\t\tinfo.endPts = lastDts;\n\t\tinfo.originalBeginDts = mp4Samples[0].originalDts;\n\t\tinfo.originalEndDts = latest.originalDts + latest.duration;\n\t\tinfo.firstSample = new SampleInfo(mp4Samples[0].dts,\n\t\t\tmp4Samples[0].pts,\n\t\t\tmp4Samples[0].duration,\n\t\t\tmp4Samples[0].originalDts,\n\t\t\tfalse);\n\t\tinfo.lastSample = new SampleInfo(latest.dts,\n\t\t\tlatest.pts,\n\t\t\tlatest.duration,\n\t\t\tlatest.originalDts,\n\t\t\tfalse);\n\t\tif (!this._isLive) {\n\t\t\tthis._audioSegmentInfoList.append(info);\n\t\t}\n\n\t\ttrack.samples = mp4Samples;\n\t\ttrack.sequenceNumber++;\n\n\t\tlet moofbox = null;\n\n\t\tif (mpegRawTrack) {\n\t\t\t// Generate empty buffer, because useless for raw mpeg\n\t\t\tmoofbox = new Uint8Array();\n\t\t} else {\n\t\t\t// Generate moof for fmp4 segment\n\t\t\tmoofbox = MP4.moof(track, firstDts);\n\t\t}\n\n\t\ttrack.samples = [];\n\t\ttrack.length = 0;\n\n\t\tlet segment = {\n\t\t\ttype: 'audio',\n\t\t\tdata: this._mergeBoxes(moofbox, mdatbox).buffer,\n\t\t\tsampleCount: mp4Samples.length,\n\t\t\tinfo: info\n\t\t};\n\n\t\tif (mpegRawTrack && firstSegmentAfterSeek) {\n\t\t\t// For MPEG audio stream in MSE, if seeking occurred, before appending new buffer\n\t\t\t// We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n\t\t\tsegment.timestampOffset = firstDts;\n\t\t}\n\n\t\tthis._onMediaSegment('audio', segment);\n\t}\n\n\t_remuxVideo(videoTrack, force) {\n\t\tif (this._videoMeta == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet track = videoTrack;\n\t\tlet samples = track.samples;\n\t\tlet dtsCorrection = undefined;\n\t\tlet firstDts = -1, lastDts = -1;\n\t\tlet firstPts = -1, lastPts = -1;\n\n\t\tif (!samples || samples.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (samples.length === 1 && !force) {\n\t\t\t// If [sample count in current batch] === 1 && (force != true)\n\t\t\t// Ignore and keep in demuxer's queue\n\t\t\treturn;\n\t\t}  // else if (force === true) do remux\n\n\t\tlet offset = 8;\n\t\tlet mdatbox = null;\n\t\tlet mdatBytes = 8 + videoTrack.length;\n\n\n\t\tlet lastSample = null;\n\n\t\t// Pop the lastSample and waiting for stash\n\t\tif (samples.length > 1) {\n\t\t\tlastSample = samples.pop();\n\t\t\tmdatBytes -= lastSample.length;\n\t\t}\n\n\t\t// Insert [stashed lastSample in the previous batch] to the front\n\t\tif (this._videoStashedLastSample != null) {\n\t\t\tlet sample = this._videoStashedLastSample;\n\t\t\tthis._videoStashedLastSample = null;\n\t\t\tsamples.unshift(sample);\n\t\t\tmdatBytes += sample.length;\n\t\t}\n\n\t\t// Stash the lastSample of current batch, waiting for next batch\n\t\tif (lastSample != null) {\n\t\t\tthis._videoStashedLastSample = lastSample;\n\t\t}\n\n\n\t\tlet firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n\t\t// calculate dtsCorrection\n\t\tif (this._videoNextDts) {\n\t\t\tdtsCorrection = firstSampleOriginalDts - this._videoNextDts;\n\t\t} else {  // this._videoNextDts == undefined\n\t\t\tif (this._videoSegmentInfoList.isEmpty()) {\n\t\t\t\tdtsCorrection = 0;\n\t\t\t} else {\n\t\t\t\tlet lastSample = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n\t\t\t\tif (lastSample != null) {\n\t\t\t\t\tlet distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n\t\t\t\t\tif (distance <= 3) {\n\t\t\t\t\t\tdistance = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlet expectedDts = lastSample.dts + lastSample.duration + distance;\n\t\t\t\t\tdtsCorrection = firstSampleOriginalDts - expectedDts;\n\t\t\t\t} else { // lastSample == null, cannot found\n\t\t\t\t\tdtsCorrection = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet info = new MediaSegmentInfo();\n\t\tlet mp4Samples = [];\n\n\t\t// Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n\t\tfor (let i = 0; i < samples.length; i++) {\n\t\t\tlet sample = samples[i];\n\t\t\tlet originalDts = sample.dts - this._dtsBase;\n\t\t\tlet isKeyframe = sample.isKeyframe;\n\t\t\tlet dts = originalDts - dtsCorrection;\n\t\t\tlet cts = sample.cts;\n\t\t\tlet pts = dts + cts;\n\n\t\t\tif (firstDts === -1) {\n\t\t\t\tfirstDts = dts;\n\t\t\t\tfirstPts = pts;\n\t\t\t}\n\n\t\t\tlet sampleDuration = 0;\n\n\t\t\tif (i !== samples.length - 1) {\n\t\t\t\tlet nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n\t\t\t\tsampleDuration = nextDts - dts;\n\t\t\t} else {  // the last sample\n\t\t\t\tif (lastSample != null) {  // use stashed sample's dts to calculate sample duration\n\t\t\t\t\tlet nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n\t\t\t\t\tsampleDuration = nextDts - dts;\n\t\t\t\t} else if (mp4Samples.length >= 1) {  // use second last sample duration\n\t\t\t\t\tsampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n\t\t\t\t} else {  // the only one sample, use reference sample duration\n\t\t\t\t\tsampleDuration = Math.floor(this._videoMeta.refSampleDuration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isKeyframe) {\n\t\t\t\tlet syncPoint = new SampleInfo(dts, pts, sampleDuration, sample.dts, true);\n\t\t\t\tsyncPoint.fileposition = sample.fileposition;\n\t\t\t\tinfo.appendSyncPoint(syncPoint);\n\t\t\t}\n\n\t\t\tmp4Samples.push({\n\t\t\t\tdts: dts,\n\t\t\t\tpts: pts,\n\t\t\t\tcts: cts,\n\t\t\t\tunits: sample.units,\n\t\t\t\tsize: sample.length,\n\t\t\t\tisKeyframe: isKeyframe,\n\t\t\t\tduration: sampleDuration,\n\t\t\t\toriginalDts: originalDts,\n\t\t\t\tflags: {\n\t\t\t\t\tisLeading: 0,\n\t\t\t\t\tdependsOn: isKeyframe ? 2 : 1,\n\t\t\t\t\tisDependedOn: isKeyframe ? 1 : 0,\n\t\t\t\t\thasRedundancy: 0,\n\t\t\t\t\tisNonSync: isKeyframe ? 0 : 1\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// allocate mdatbox\n\t\tmdatbox = new Uint8Array(mdatBytes);\n\t\tmdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n\t\tmdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n\t\tmdatbox[2] = (mdatBytes >>> 8) & 0xFF;\n\t\tmdatbox[3] = (mdatBytes) & 0xFF;\n\t\tmdatbox.set(MP4.types.mdat, 4);\n\n\t\t// Write samples into mdatbox\n\t\tfor (let i = 0; i < mp4Samples.length; i++) {\n\t\t\tlet units = mp4Samples[i].units;\n\t\t\twhile (units.length) {\n\t\t\t\tlet unit = units.shift();\n\t\t\t\tlet data = unit.data;\n\t\t\t\tmdatbox.set(data, offset);\n\t\t\t\toffset += data.byteLength;\n\t\t\t}\n\t\t}\n\n\t\tlet latest = mp4Samples[mp4Samples.length - 1];\n\t\tlastDts = latest.dts + latest.duration;\n\t\tlastPts = latest.pts + latest.duration;\n\t\tthis._videoNextDts = lastDts;\n\n\t\t// fill media segment info & add to info list\n\t\tinfo.beginDts = firstDts;\n\t\tinfo.endDts = lastDts;\n\t\tinfo.beginPts = firstPts;\n\t\tinfo.endPts = lastPts;\n\t\tinfo.originalBeginDts = mp4Samples[0].originalDts;\n\t\tinfo.originalEndDts = latest.originalDts + latest.duration;\n\t\tinfo.firstSample = new SampleInfo(mp4Samples[0].dts,\n\t\t\tmp4Samples[0].pts,\n\t\t\tmp4Samples[0].duration,\n\t\t\tmp4Samples[0].originalDts,\n\t\t\tmp4Samples[0].isKeyframe);\n\t\tinfo.lastSample = new SampleInfo(latest.dts,\n\t\t\tlatest.pts,\n\t\t\tlatest.duration,\n\t\t\tlatest.originalDts,\n\t\t\tlatest.isKeyframe);\n\t\tif (!this._isLive) {\n\t\t\tthis._videoSegmentInfoList.append(info);\n\t\t}\n\n\t\ttrack.samples = mp4Samples;\n\t\ttrack.sequenceNumber++;\n\n\t\t// workaround for chrome < 50: force first sample as a random access point\n\t\t// see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n\t\tif (this._forceFirstIDR) {\n\t\t\tlet flags = mp4Samples[0].flags;\n\t\t\tflags.dependsOn = 2;\n\t\t\tflags.isNonSync = 0;\n\t\t}\n\n\t\tlet moofbox = MP4.moof(track, firstDts);\n\t\ttrack.samples = [];\n\t\ttrack.length = 0;\n\n\t\tthis._onMediaSegment('video', {\n\t\t\ttype: 'video',\n\t\t\tdata: this._mergeBoxes(moofbox, mdatbox).buffer,\n\t\t\tsampleCount: mp4Samples.length,\n\t\t\tinfo: info\n\t\t});\n\t}\n\n\t_mergeBoxes(moof, mdat) {\n\t\tlet result = new Uint8Array(moof.byteLength + mdat.byteLength);\n\t\tresult.set(moof, 0);\n\t\tresult.set(mdat, moof.byteLength);\n\t\treturn result;\n\t}\n\n}\n\nexport default MP4Remuxer;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// Transmuxing (IO, Demuxing, Remuxing) controller, with multipart support\nimport {TransmuxingEvents} from \"../utils/utils\";\nimport EventEmitter from \"../utils/event_emitter\";\nimport MP4Remuxer from \"../formats/mp4-remuxer\";\n\nclass Transmuxer {\n\n    constructor(mediaDataSource, config) {\n        this.TAG = 'Transmuxer';\n        this._emitter = new EventEmitter();\n\n        this._config = config;\n\n\n        this._mediaDataSource = mediaDataSource;\n        this._currentSegmentIndex = 0;\n\n        this._mediaInfo = null;\n        this._remuxer = null;\n        this._ioctl = null;\n\n        this._pendingSeekTime = null;\n        this._pendingResolveSeekPoint = null;\n\n        this._statisticsReporter = null;\n\n        this._remuxer = new MP4Remuxer(this._config);\n    }\n\n    destroy() {\n        this._mediaInfo = null;\n        this._mediaDataSource = null;\n\n        if (this._statisticsReporter) {\n            this._disableStatisticsReporter();\n        }\n        if (this._ioctl) {\n            this._ioctl.destroy();\n            this._ioctl = null;\n        }\n        if (this._demuxer) {\n            this._demuxer.destroy();\n            this._demuxer = null;\n        }\n        if (this._remuxer) {\n            this._remuxer.destroy();\n            this._remuxer = null;\n        }\n\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n    }\n\n    on(event, listener) {\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n\n    /*\n    _loadSegment(segmentIndex, optionalFrom) {\n        this._currentSegmentIndex = segmentIndex;\n        let dataSource = this._mediaDataSource.segments[segmentIndex];\n\n        let ioctl = this._ioctl = new IOController(dataSource, this._config, segmentIndex);\n        ioctl.onError = this._onIOException.bind(this);\n        ioctl.onSeeked = this._onIOSeeked.bind(this);\n        ioctl.onComplete = this._onIOComplete.bind(this);\n        ioctl.onRedirect = this._onIORedirect.bind(this);\n        ioctl.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this);\n\n        if (optionalFrom) {\n            this._demuxer.bindDataSource(this._ioctl);\n        } else {\n            ioctl.onDataArrival = this._onInitChunkArrival.bind(this);\n        }\n\n        ioctl.open(optionalFrom);\n    }*/\n\n    stop() {\n        this._internalAbort();\n        this._disableStatisticsReporter();\n    }\n\n    _internalAbort() {\n        if (this._ioctl) {\n            this._ioctl.destroy();\n            this._ioctl = null;\n        }\n    }\n\n\n    seek(milliseconds) {\n        if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) {\n            return;\n        }\n\n        let targetSegmentIndex = this._searchSegmentIndexContains(milliseconds);\n\n        if (targetSegmentIndex === this._currentSegmentIndex) {\n            // intra-segment seeking\n            let segmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n            if (segmentInfo == undefined) {\n                // current segment loading started, but mediainfo hasn't received yet\n                // wait for the metadata loaded, then seek to expected position\n                this._pendingSeekTime = milliseconds;\n            } else {\n                let keyframe = segmentInfo.getNearestKeyframe(milliseconds);\n                this._remuxer.seek(keyframe.milliseconds);\n                this._ioctl.seek(keyframe.fileposition);\n                // Will be resolved in _onRemuxerMediaSegmentArrival()\n                this._pendingResolveSeekPoint = keyframe.milliseconds;\n            }\n        } else {\n            // cross-segment seeking\n            let targetSegmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n            if (targetSegmentInfo == undefined) {\n                // target segment hasn't been loaded. We need metadata then seek to expected time\n                this._pendingSeekTime = milliseconds;\n                this._internalAbort();\n                this._remuxer.seek();\n                this._remuxer.insertDiscontinuity();\n                this._loadSegment(targetSegmentIndex);\n                // Here we wait for the metadata loaded, then seek to expected position\n            } else {\n                // We have target segment's metadata, direct seek to target position\n                let keyframe = targetSegmentInfo.getNearestKeyframe(milliseconds);\n                this._internalAbort();\n                this._remuxer.seek(milliseconds);\n                this._remuxer.insertDiscontinuity();\n                this._demuxer.resetMediaInfo();\n                this._demuxer.timestampBase = this._mediaDataSource.segments[targetSegmentIndex].timestampBase;\n                this._loadSegment(targetSegmentIndex, keyframe.fileposition);\n                this._pendingResolveSeekPoint = keyframe.milliseconds;\n                this._reportSegmentMediaInfo(targetSegmentIndex);\n            }\n        }\n\n        this._enableStatisticsReporter();\n    }\n\n    _searchSegmentIndexContains(milliseconds) {\n        let segments = this._mediaDataSource.segments;\n        let idx = segments.length - 1;\n\n        for (let i = 0; i < segments.length; i++) {\n            if (milliseconds < segments[i].timestampBase) {\n                idx = i - 1;\n                break;\n            }\n        }\n        return idx;\n    }\n\n    _onInitChunkArrival() {\n\n\n        let mds = this._mediaDataSource;\n        if (mds.duration != undefined && !isNaN(mds.duration)) {\n            this._demuxer.overridedDuration = mds.duration;\n        }\n        if (typeof mds.hasAudio === 'boolean') {\n            this._demuxer.overridedHasAudio = mds.hasAudio;\n        }\n        if (typeof mds.hasVideo === 'boolean') {\n            this._demuxer.overridedHasVideo = mds.hasVideo;\n        }\n\n        this._demuxer.timestampBase = mds.segments[this._currentSegmentIndex].timestampBase;\n\n        this._demuxer.onError = this._onDemuxException.bind(this);\n        this._demuxer.onMediaInfo = this._onMediaInfo.bind(this);\n        this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this);\n        this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this);\n\n        this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this);\n        this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this);\n\n    }\n\n    _onMediaInfo(mediaInfo) {\n        if (this._mediaInfo == null) {\n            // Store first segment's mediainfo as global mediaInfo\n            this._mediaInfo = Object.assign({}, mediaInfo);\n            this._mediaInfo.keyframesIndex = null;\n            this._mediaInfo.segments = [];\n            this._mediaInfo.segmentCount = this._mediaDataSource.segments.length;\n            Object.setPrototypeOf(this._mediaInfo, MediaInfo.prototype);\n        }\n\n        let segmentInfo = Object.assign({}, mediaInfo);\n        Object.setPrototypeOf(segmentInfo, MediaInfo.prototype);\n        this._mediaInfo.segments[this._currentSegmentIndex] = segmentInfo;\n\n        // notify mediaInfo update\n        this._reportSegmentMediaInfo(this._currentSegmentIndex);\n\n        if (this._pendingSeekTime != null) {\n            Promise.resolve().then(() => {\n                let target = this._pendingSeekTime;\n                this._pendingSeekTime = null;\n                this.seek(target);\n            });\n        }\n    }\n\n    _onMetaDataArrived(metadata) {\n        this._emitter.emit(TransmuxingEvents.METADATA_ARRIVED, metadata);\n    }\n\n    _onScriptDataArrived(data) {\n        this._emitter.emit(TransmuxingEvents.SCRIPTDATA_ARRIVED, data);\n    }\n\n    _onIOSeeked() {\n        this._remuxer.insertDiscontinuity();\n    }\n\n    _onIOComplete(extraData) {\n        let segmentIndex = extraData;\n        let nextSegmentIndex = segmentIndex + 1;\n\n        if (nextSegmentIndex < this._mediaDataSource.segments.length) {\n            this._internalAbort();\n            this._remuxer.flushStashedSamples();\n            this._loadSegment(nextSegmentIndex);\n        } else {\n            this._remuxer.flushStashedSamples();\n            this._emitter.emit(TransmuxingEvents.LOADING_COMPLETE);\n            this._disableStatisticsReporter();\n        }\n    }\n\n    _onIORedirect(redirectedURL) {\n        let segmentIndex = this._ioctl.extraData;\n        this._mediaDataSource.segments[segmentIndex].redirectedURL = redirectedURL;\n    }\n\n    _onIORecoveredEarlyEof() {\n        this._emitter.emit(TransmuxingEvents.RECOVERED_EARLY_EOF);\n    }\n\n    _onIOException(type, info) {\n        Log.e(this.TAG, `IOException: type = ${type}, code = ${info.code}, msg = ${info.msg}`);\n        this._emitter.emit(TransmuxingEvents.IO_ERROR, type, info);\n        this._disableStatisticsReporter();\n    }\n\n    _onDemuxException(type, info) {\n        Log.e(this.TAG, `DemuxException: type = ${type}, info = ${info}`);\n        this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, type, info);\n    }\n\n    _onRemuxerInitSegmentArrival(type, initSegment) {\n        this._emitter.emit(TransmuxingEvents.INIT_SEGMENT, type, initSegment);\n    }\n\n    _onRemuxerMediaSegmentArrival(type, mediaSegment) {\n        if (this._pendingSeekTime != null) {\n            // Media segments after new-segment cross-seeking should be dropped.\n            return;\n        }\n        this._emitter.emit(TransmuxingEvents.MEDIA_SEGMENT, type, mediaSegment);\n\n        // Resolve pending seekPoint\n        if (this._pendingResolveSeekPoint != null && type === 'video') {\n            let syncPoints = mediaSegment.info.syncPoints;\n            let seekpoint = this._pendingResolveSeekPoint;\n            this._pendingResolveSeekPoint = null;\n\n            // Safari: Pass PTS for recommend_seekpoint\n            if (Browser.safari && syncPoints.length > 0 && syncPoints[0].originalDts === seekpoint) {\n                seekpoint = syncPoints[0].pts;\n            }\n            // else: use original DTS (keyframe.milliseconds)\n\n            this._emitter.emit(TransmuxingEvents.RECOMMEND_SEEKPOINT, seekpoint);\n        }\n    }\n\n    _enableStatisticsReporter() {\n        if (this._statisticsReporter == null) {\n            this._statisticsReporter = self.setInterval(\n                this._reportStatisticsInfo.bind(this),\n                this._config.statisticsInfoReportInterval);\n        }\n    }\n\n    _disableStatisticsReporter() {\n        if (this._statisticsReporter) {\n            self.clearInterval(this._statisticsReporter);\n            this._statisticsReporter = null;\n        }\n    }\n\n    _reportSegmentMediaInfo(segmentIndex) {\n        let segmentInfo = this._mediaInfo.segments[segmentIndex];\n        let exportInfo = Object.assign({}, segmentInfo);\n\n        exportInfo.duration = this._mediaInfo.duration;\n        exportInfo.segmentCount = this._mediaInfo.segmentCount;\n        delete exportInfo.segments;\n        delete exportInfo.keyframesIndex;\n\n        this._emitter.emit(TransmuxingEvents.MEDIA_INFO, exportInfo);\n    }\n\n    _reportStatisticsInfo() {\n        let info = {};\n\n        info.url = this._ioctl.currentURL;\n        info.hasRedirect = this._ioctl.hasRedirect;\n        if (info.hasRedirect) {\n            info.redirectedURL = this._ioctl.currentRedirectedURL;\n        }\n\n        info.speed = this._ioctl.currentSpeed;\n        info.loaderType = this._ioctl.loaderType;\n        info.currentSegmentIndex = this._currentSegmentIndex;\n        info.totalSegmentCount = this._mediaDataSource.segments.length;\n\n        this._emitter.emit(TransmuxingEvents.STATISTICS_INFO, info);\n    }\n\n}\n\nexport default Transmuxer;\n","import {Log} from \"./utils/logger\";\r\nimport MSEController from \"./utils/mse-controller\";\r\nimport {defaultConfig} from \"./utils/utils\";\r\nimport WebRTMP_Controller from \"./wss/connection.controller\";\r\nimport Transmuxer from \"./flv/transmuxer\";\r\nimport EventEmitter from \"./utils/event_emitter\";\r\n\r\nclass WebRTMP{\r\n\tTAG = 'WebRTMP';\r\n\t_type = 'WebRTMP';\r\n\r\n\tconstructor(mediaDataSource, config) {\r\n\t\tthis.wss = new WebRTMP_Controller();\r\n\r\n\t\tthis.wss.addEventListener(\"Connected\", ()=>{\r\n\t\t\tconsole.log(\"[ WebRTMP ] Connected\");\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"RTMPConnected\", ()=>{\r\n\t\t\tconsole.log(\"RTMPConnected\");\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"RTMPMessageArrived\", (data)=>{\r\n\t\t\tconsole.log(\"RTMPMessageArrived\", data);\r\n\t\t});\r\n\r\n\r\n\t\tthis.wss.addEventListener(\"ProtocolControlMessage\", (data)=>{\r\n\t\t\tconsole.log(\"ProtocolControlMessage\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"UserControlMessage\", (data)=>{\r\n\t\t\tconsole.log(\"UserControlMessage\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"Started\", ()=>{});\r\n\r\n\t\tthis.wss.addEventListener(\"ConnectionLost\", ()=>{});\r\n\r\n\t\tthis.wss.addEventListener(\"ConnectionLost\", ()=>{});\r\n\r\n\t\tthis._emitter = new EventEmitter();\r\n\r\n\t\tthis.e = {\r\n\t\t\tonvLoadedMetadata: this._onvLoadedMetadata.bind(this),\r\n\t\t\tonvSeeking: this._onvSeeking.bind(this),\r\n\t\t\tonvCanPlay: this._onvCanPlay.bind(this),\r\n\t\t\tonvStalled: this._onvStalled.bind(this),\r\n\t\t\tonvProgress: this._onvProgress.bind(this)\r\n\t\t};\r\n\r\n\t\tthis._config = defaultConfig;\r\n\t\tif (typeof config === 'object') {\r\n\t\t\tObject.assign(this._config, config);\r\n\t\t}\r\n\r\n\t\tthis._transmuxer = new Transmuxer(mediaDataSource, this._config);\r\n\t}\r\n\r\n\t_onvLoadedMetadata(e) {\r\n\t\tif (this._pendingSeekTime != null) {\r\n\t\t\tthis._mediaElement.currentTime = this._pendingSeekTime;\r\n\t\t\tthis._pendingSeekTime = null;\r\n\t\t}\r\n\t}\r\n\r\n\t_onvCanPlay(e) {\r\n\t\tthis._receivedCanPlay = true;\r\n\t\tthis._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\r\n\t}\r\n\r\n\t_onvStalled(e) {\r\n\t\t//this._checkAndResumeStuckPlayback(true);\r\n\t}\r\n\r\n\t_onvProgress(e) {\r\n\t\t//this._checkAndResumeStuckPlayback();\r\n\t}\r\n\r\n\t_onvSeeking(){\r\n\r\n\t}\r\n\r\n\t_onmseBufferFull() {\r\n\t\tLog.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\r\n\t\tif (this._progressChecker == null) {\r\n\t\t\tthis._suspendTransmuxer();\r\n\t\t}\r\n\t}\r\n\r\n\t_onmseUpdateEnd() {\r\n\t\tif (!this._config.lazyLoad || this._config.isLive) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet buffered = this._mediaElement.buffered;\r\n\t\tlet currentTime = this._mediaElement.currentTime;\r\n\t\tlet currentRangeStart = 0;\r\n\t\tlet currentRangeEnd = 0;\r\n\r\n\t\tfor (let i = 0; i < buffered.length; i++) {\r\n\t\t\tlet start = buffered.start(i);\r\n\t\t\tlet end = buffered.end(i);\r\n\t\t\tif (start <= currentTime && currentTime < end) {\r\n\t\t\t\tcurrentRangeStart = start;\r\n\t\t\t\tcurrentRangeEnd = end;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\r\n\t\t\tLog.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\r\n\t\t\tthis._suspendTransmuxer();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tdestroy() {\r\n\t\tif (this._progressChecker != null) {\r\n\t\t\twindow.clearInterval(this._progressChecker);\r\n\t\t\tthis._progressChecker = null;\r\n\t\t}\r\n\t\tif (this._transmuxer) {\r\n\t\t\tthis.unload();\r\n\t\t}\r\n\t\tif (this._mediaElement) {\r\n\t\t\tthis.detachMediaElement();\r\n\t\t}\r\n\t\tthis.e = null;\r\n\t\tthis._mediaDataSource = null;\r\n\r\n\t\tthis._emitter.removeAllListeners();\r\n\t\tthis._emitter = null;\r\n\t}\r\n\r\n\tdisconnect(){\r\n\t\tthis.wss.disconnect();\r\n\t}\r\n\r\n\tplay(streamName){\r\n\t\tthis.wss.play(streamName);\r\n\t}\r\n\r\n\tconnect(appName){\r\n\t\tthis.wss.connect(appName);\r\n\t}\r\n\r\n\tpause(enable){\r\n\t\tthis.wss.connect(enable);\r\n\t}\r\n\r\n\tdetachMediaElement() {\r\n\t\tif (this._mediaElement) {\r\n\t\t\tthis._msectl.detachMediaElement();\r\n\t\t\tthis._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\r\n\t\t\tthis._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\r\n\t\t\tthis._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\r\n\t\t\tthis._mediaElement.removeEventListener('stalled', this.e.onvStalled);\r\n\t\t\tthis._mediaElement.removeEventListener('progress', this.e.onvProgress);\r\n\t\t\tthis._mediaElement = null;\r\n\t\t}\r\n\r\n\t\tif (this._msectl) {\r\n\t\t\tthis._msectl.destroy();\r\n\t\t\tthis._msectl = null;\r\n\t\t}\r\n\t}\r\n\r\n\tattachMediaElement(mediaElement) {\r\n\t\tthis._mediaElement = mediaElement;\r\n\t\tmediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\r\n\t\tmediaElement.addEventListener('seeking', this.e.onvSeeking);\r\n\t\tmediaElement.addEventListener('canplay', this.e.onvCanPlay);\r\n\t\tmediaElement.addEventListener('stalled', this.e.onvStalled);\r\n\t\tmediaElement.addEventListener('progress', this.e.onvProgress);\r\n\r\n\t\tthis._msectl = new MSEController(this._config);\r\n\r\n\t\tthis._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\r\n\t\tthis._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\r\n\t\tthis._msectl.on(MSEEvents.SOURCE_OPEN, () => {\r\n\t\t\tthis._mseSourceOpened = true;\r\n\t\t\tif (this._hasPendingLoad) {\r\n\t\t\t\tthis._hasPendingLoad = false;\r\n\t\t\t\tthis.load();\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._msectl.on(MSEEvents.ERROR, (info) => {\r\n\t\t\tthis._emitter.emit(PlayerEvents.ERROR,\r\n\t\t\t\tErrorTypes.MEDIA_ERROR,\r\n\t\t\t\tErrorDetails.MEDIA_MSE_ERROR,\r\n\t\t\t\tinfo\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\tthis._msectl.attachMediaElement(mediaElement);\r\n\r\n\t\tif (this._pendingSeekTime != null) {\r\n\t\t\ttry {\r\n\t\t\t\tmediaElement.currentTime = this._pendingSeekTime;\r\n\t\t\t\tthis._pendingSeekTime = null;\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// IE11 may throw InvalidStateError if readyState === 0\r\n\t\t\t\t// We can defer set currentTime operation after loadedmetadata\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tthis._transmuxer.on(TransmuxingEvents.INIT_SEGMENT, (type, is) => {\r\n\t\t\tthis._msectl.appendInitSegment(is);\r\n\t\t});\r\n\t\tthis._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, (type, ms) => {\r\n\t\t\tthis._msectl.appendMediaSegment(ms);\r\n\r\n\t\t\t// lazyLoad check\r\n\t\t\tif (this._config.lazyLoad && !this._config.isLive) {\r\n\t\t\t\tlet currentTime = this._mediaElement.currentTime;\r\n\t\t\t\tif (ms.info.endDts >= (currentTime + this._config.lazyLoadMaxDuration) * 1000) {\r\n\t\t\t\t\tif (this._progressChecker == null) {\r\n\t\t\t\t\t\tLog.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\r\n\t\t\t\t\t\tthis._suspendTransmuxer();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\nwindow[\"webrtmp\"] = new WebRTMP();\r\n\r\nexport default WebRTMP;\r\n"],"names":[],"sourceRoot":""}