{"version":3,"file":"webrtmp.worker.js","mappings":";;;;;;;;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAAe,oBAAoB,EAAC;;;ACtCpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,aAAa,EAAC;;;AC3I7B;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;;AAEO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;;AAEA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AC3JmD;;AAEnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS,mBAAmB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uDAAe,WAAW,EAAC;;;AC7IwB;;AAEnD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA,uBAAuB;;AAEvB,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,mBAAmB;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAe,KAAK,EAAC;;;ACrJrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8DAAe,kBAAkB,EAAC;;;AChElC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAe,sBAAsB,EAAC;;;AC/CwB;AACtB;AACZ;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,2BAAsB;;AAEhD,yBAAyB,gBAAW;AACpC;;AAEA,8BAA8B,UAAK;AACnC,wCAAwC;;AAExC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,yDAAe,aAAa,EAAC;;;AC3EW;AACW;;AAEnD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB,6BAA6B;;AAEtE;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA,qDAAqD;;AAErD,iCAAiC;AACjC;;AAEA,cAAc,yBAAyB;AACvC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oHAAoH;AACpH,yHAAyH;;AAEzH,0BAA0B,gBAAW;AACrC,0EAA0E;AAC1E,gKAAgK;AAChK;;AAEA,8CAA8C;AAC9C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oHAAoH;AACpH,yHAAyH;;AAEzH,0BAA0B,gBAAW;AACrC;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oHAAoH;;AAEpH;;AAEA,8CAA8C;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;AASA,2DAA2D;AAC3D,4EAA4E,6BAAwB;;AAEpG;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAU,kCAAkC;;AAE5C;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAe,WAAW,EAAC;;;ACrP3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO,MAAM,+BAAqB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO,MAAM,kCAAwB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iDAAe,SAAS,EAAC;;;ACjIzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGyD;AACX;;AAE9C;AACA;AACA,iDAAiD;AACjD,8CAA8C;AAC9C,CAAC;;AAED;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,kBAAkB,OAAO,wBAAwB;AACjD;AACA;AACA;AACA,sBAAsB,+BAAqB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,kBAAkB,OAAO,wBAAwB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB,+BAAqB;AAC3C;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+BAAqB;AAC3C;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+BAAqB;AAC3C;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,sBAAsB,+BAAqB;AAC3C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,uCAAuC;AACvC;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,kCAAkC;AAClC,uCAAuC;AACvC;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAe,GAAG,EAAC;;;AChRZ;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,2CAA2C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA,iDAAe,SAAS,EAAC;;;ACjHzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIqC;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,UAAS;;AAE9B;AACA,0CAA0C;AAC1C,wBAAwB;AACxB,wCAAwC;AACxC,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C,2BAA2B;AAC3B,6BAA6B;AAC7B,kCAAkC;AAClC;AACA,gCAAgC,wBAAwB;AACxD,0CAA0C;AAC1C;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,2BAA2B;AAC3B,UAAU;AACV,6BAA6B;AAC7B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,4BAA4B,2CAA2C;AACvE,+BAA+B;AAC/B;AACA;AACA,wCAAwC;AACxC,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,gCAAgC;AAChC;AACA,kCAAkC;AAClC,iCAAiC;AACjC,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA,kCAAkC;AAClC,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA,kCAAkC;AAClC;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iDAAe,SAAS,EAAC;;;ACzRgC;AACX;AACV;AACA;AACO;AACD;;AAE1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8BAA8B,UAAS;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B;AAC5B,4BAA4B;;AAE5B;AACA;AACA,yDAAyD;AACzD,sDAAsD;AACtD,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,UAAS;AACvC;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA,kDAAkD;AAClD;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,sBAAsB,+BAAqB;AAC3C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,yBAAyB,0BAAmB;;AAE5C;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;;AAEA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA,iEAAiE;AACjE;AACA;AACA,yDAAyD;AACzD;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,8CAA8C;AAC9C,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wDAAwD;AACxD,0BAA0B,6BAA6B;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,0BAA0B,wBAAwB;AAClD;AACA;;AAEA,gDAAgD;AAChD;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,kBAAkB;AAClB,gDAAgD;AAChD;AACA;AACA;AACA;AACA,cAAc,sCAAsC;AACpD;AACA,iCAAiC;AACjC;AACA;AACA,cAAc;AACd,gBAAgB,KAAK,6CAA6C,mBAAmB;AACrF;AACA,UAAU,+BAA+B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;;AAErB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,kBAAkB;AAClB,gDAAgD;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,0BAA0B,6BAA6B,4CAA4C,QAAQ;AAC3G;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6CAA6C;;AAE7C,iCAAiC;AACjC;AACA,UAAU,8BAA8B;AACxC;AACA,UAAU;AACV;AACA,UAAU;AACV,0BAA0B,wBAAwB,oCAAoC,WAAW;AACjG;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA,gBAAgB,KAAK;AACrB;AACA;;AAEA,sCAAsC;AACtC,yCAAyC;AACzC,mDAAmD;AACnD,uCAAuC;;AAEvC;AACA,0BAA0B,wBAAwB;AAClD;AACA;;AAEA,yDAAyD;AACzD,yEAAyE;AACzE,0BAA0B,wBAAwB,0CAA0C,yBAAyB;AACrH;AACA;;AAEA,4CAA4C;AAC5C;AACA,0BAA0B,wBAAwB;AAClD;AACA,UAAU;AACV,YAAY,KAAK,sEAAsE,SAAS;AAChG;;AAEA;;AAEA,wBAAwB,cAAc;AACtC,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,mBAAkB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA,cAAc;AACd,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA,0BAA0B,wBAAwB;AAClD;AACA,UAAU;AACV,YAAY,KAAK,sEAAsE,SAAS;AAChG;;AAEA;;AAEA,wBAAwB,cAAc;AACtC,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,KAAK;;AAEb;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA,gBAAgB,KAAK,4CAA4C,IAAI,aAAa,OAAO,eAAe,SAAS;AACjH,wBAAwB;AACxB;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,gBAAgB,KAAK,6CAA6C,IAAI;AACtE;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAe,uBAAuB,EAAC;;;ACv/BuE;;AAE9G;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa,kBAAkB;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB,8BAA8B;;AAEjE;;AAEA;;AAEA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8BAA8B,kBAAkB;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,qCAAqC,kBAAkB;AACvD;;AAEA;AACA;AACA,kCAAkC;AAClC,qCAAqC,kBAAkB;AACvD;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAyC,kBAAkB;;AAE3D;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D;;AAEA;AACA;AACA,6CAA6C,kBAAkB;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAe,UAAU,EAAC;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AC1QwC;AACZ;AAC0B;AACV;AACJ;AACwB;AAC1B;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,gCAAgC,gBAAW;AAC3C,iCAAiC,4BAAuB;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,eAAU;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE,6BAAwB;AAC1F;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA,4BAA4B,eAAU;AACtC;AACA;;AAEA;;AAEA,sBAAsB,gBAAW;AACjC,mCAAmC;AACnC;;AAEA,0BAA0B,UAAK;AAC/B;;AAEA;;AAEA,qCAAqC,kBAAa;;AAElD;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA,4BAA4B,eAAU;AACtC;AACA;;AAEA,sBAAsB,gBAAW;AACjC,mCAAmC;AACnC;;AAEA,0BAA0B,UAAK;AAC/B;;AAEA;;AAEA,qCAAqC,kBAAa;;AAElD;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA,4BAA4B,eAAU;AACtC;AACA;;AAEA,sBAAsB,gBAAW;AACjC,mCAAmC;AACnC;;AAEA,0BAA0B,UAAK;AAC/B;;AAEA;;AAEA,qCAAqC,kBAAa;;AAElD;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA,4BAA4B,eAAU;AACtC;AACA;;AAEA,sBAAsB,gBAAW;AACjC,mCAAmC;AACnC;;AAEA,0BAA0B,UAAK;AAC/B;;AAEA;;AAEA,qCAAqC,kBAAa;;AAElD;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;;AAEA,4BAA4B,uBAAkB;AAC9C,wCAAwC;AACxC;;;AAGA,yBAAyB,gBAAW;AACpC;;AAEA,8BAA8B,UAAK;AACnC,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;;AAEA,8DAAe,kBAAkB,EAAC;;;;ACjVwB;AACR;AACU;;AAE5D;AACA;AACA;;AAEA,wBAAwB,wBAAoB;;AAE5C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAa;;AAExC;AACA;AACA;;AAEA,6BAA6B,uBAAkB;;AAE/C;;AAEA;AACA;AACA;AACA,QAAQ;;AAER,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","sources":["webpack://webrtmp/./wss/WSSConnectionManager.js","webpack://webrtmp/./rtmp/RTMPHandshake.js","webpack://webrtmp/./utils/utils.js","webpack://webrtmp/./rtmp/RTMPMessage.js","webpack://webrtmp/./rtmp/Chunk.js","webpack://webrtmp/./rtmp/UserControlMessage.js","webpack://webrtmp/./rtmp/ProtocolControlMessage.js","webpack://webrtmp/./rtmp/NetConnection.js","webpack://webrtmp/./rtmp/ChunkParser.js","webpack://webrtmp/./utils/exception.js","webpack://webrtmp/./formats/media-info.js","webpack://webrtmp/./utils/utf8-conv.js","webpack://webrtmp/./flv/amf-parser.js","webpack://webrtmp/./utils/logger.js","webpack://webrtmp/./flv/exp-golomb.js","webpack://webrtmp/./flv/sps-parser.js","webpack://webrtmp/./rtmp/RTMPMediaMessageHandler.js","webpack://webrtmp/./rtmp/AMF0Object.js","webpack://webrtmp/./rtmp/RTMPMessageHandler.js","webpack://webrtmp/./wss/connection.worker.js"],"sourcesContent":["class WSSConnectionManager{\n    wss;\n\n    connect(host, port, callback){\n        console.log(\"[ WSSConnectionManager ] connecting to : \" + host + \":\" + port);\n        this.wss = new WebSocket(\"wss://\" + host + \":\" + port + \"/\");\n\n        this.wss.binaryType = \"arraybuffer\";\n\n        this.wss.onopen = (e)=>{\n            console.log(e);\n            callback(true);\n        }\n\n        this.wss.onclose = (e)=>{\n            console.log(e);\n            postMessage([\"ConnectionLost\"]);\n        }\n\n        this.wss.onerror = (e)=>{\n            console.log(e);\n            postMessage([\"Failure\"]);\n        }\n    }\n\n    registerMessageHandler(cb){\n        this.wss.onmessage = cb;\n    }\n\n    getSocket(){\n        return this.wss;\n    }\n\n    close(){\n        this.wss.close();\n    }\n}\n\nexport default WSSConnectionManager;\n","class RTMPHandshake{\n    state = 0;\n    c1;\n    c2;\n    s1;\n    s2;\n\n    constructor(socket) {\n        this.socket = socket;\n\n        this.socket.onmessage = (e)=>{\n            this.processServerInput(e.data);\n        }\n    }\n\n    do(){\n        console.log(\"send C0\");\n        this.socket.send(new Uint8Array([0x03]));\n        this.state = 1;\n\n        this._generateC1();\n        console.log(\"send C1\");\n        this.socket.send(this.c1);\n        this.state = 2;\n    }\n\n    _generateC1(){\n        const c1 = new Uint8Array(1536);\n\n        for(let i = 0; i < c1.length; i++) {\n            c1[i] = Math.floor(Math.random() * 256);\n        }\n\n        let time = Math.round(Date.now() / 1000);\n\n        c1[0] = (time >>> 24);\n        c1[1] = (time >>> 16);\n        c1[2] = (time >>> 8);\n        c1[3] = (time);\n\n        c1[4] = 0;\n        c1[5] = 0;\n        c1[6] = 0;\n        c1[7] = 0;\n\n        this.c1 = c1;\n    }\n\n    _generateC2(){\n        console.log(\"[ RTMPHandshake ] send C2\");\n        this.socket.send(this.s1);\n        this.state = 5;\n    }\n\n    _parseS0(data){\n        console.log(\"[ RTMPHandshake ] S0: \", data);\n\n        let buffer = new Uint8Array(data);\n\n        if(buffer.at(0) != 0x03) {\n            console.error(\"[ RTMPHandshake ] S0 response not 0x03\");\n\n        } else {\n            console.log(\"1st Byte OK\");\n        }\n\n        this.state = 3;\n\n        if(buffer.length > 1) {\n            console.log(\"S1 included\");\n            data = data.slice(1);\n            this.processServerInput(data);\n        }\n    }\n\n    _parseS1(data){\n        console.log(\"[ RTMPHandshake ] parse S1: \", data);\n        this.state = 4;\n\n        this.s1 = data;\n\n        this._generateC2();\n    }\n\n    _parseS2(data) {\n        console.log(\"[ RTMPHandshake ] parse S2: \", data);\n\n        let newdata = [];\n\n        if(data.length > 1536) {\n            console.log(\"data stripped\");\n            data = data.slice(1536);\n        }\n\n\n        if(!this._compare(this.c1, new Uint8Array(data))) {\n            console.warn(\"C1 S1 not equal\");\n            this.onHandshakeDone(false);\n            return;\n        }\n\n        this.state = 6;\n\n        console.log(\"[ RTMPHandshake ] RTMP Connection established\");\n\n        this.onHandshakeDone(true);\n    }\n\n    _compare(ar1, ar2){\n        for(let i = 0; i < ar1.length; i++){\n            if(ar1[i] != ar2[i]) return false;\n        }\n\n        return true;\n    }\n\n    onHandshakeDone(){\n\n    }\n\n    processServerInput(data){\n        console.log(\"[ Connection Worker ] processing mode \" + this.state + \": \", data);\n\n        switch(this.state){\n            case 2:\t\t//\n                this._parseS0(data);\n                break;\n\n            case 3:\n                this._parseS1(data);\n                break;\n\n            case 5:\n                this._parseS2(data);\n                break;\n        }\n    }\n}\n\nexport default RTMPHandshake;\n","/**\n *\n * @param {Uint8Array} bufs\n * @returns {Uint8Array}\n */\n\nexport function _concatArrayBuffers(...bufs){\n    const result = new Uint8Array(bufs.reduce((totalSize, buf)=>totalSize+buf.byteLength,0));\n    bufs.reduce((offset, buf)=>{\n        result.set(buf,offset)\n        return offset+buf.byteLength\n    },0)\n\n    return result;\n}\n\nexport function _stringToByteArray(str) {\n    const bytes = [];\n\n    for(let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        if(char > 0xFF) {\n            bytes.push(char >>> 8);\n        }\n\n        bytes.push(char & 0xFF);\n    }\n    return bytes;\n}\n\nexport function _numberToByteArray(num) {\n    const buffer = new ArrayBuffer(8);\n    new DataView(buffer).setFloat64(0, num, false);\n    return [].slice.call(new Uint8Array(buffer));\n}\n\nexport function _byteArrayToNumber(ba){\n    let buf = new ArrayBuffer(ba.length);\n    let view = new DataView(buf);\n\n    ba.forEach(function (b, i) {\n        view.setUint8(i, b);\n    });\n\n    return view.getFloat64(0);\n}\n\nexport function _byteArrayToString(ba){\n    let ret = \"\";\n\n    for(let i = 0; i < ba.length; i++){\n        ret += String.fromCharCode(ba[i]);\n    }\n\n    return ret;\n}\n\nexport const defaultConfig = {\n    enableWorker: false,\n    enableStashBuffer: true,\n    stashInitialSize: undefined,\n\n    isLive: true,\n\n    lazyLoad: true,\n    lazyLoadMaxDuration: 3 * 60,\n    lazyLoadRecoverDuration: 30,\n    deferLoadAfterSourceOpen: true,\n\n    // autoCleanupSourceBuffer: default as false, leave unspecified\n    autoCleanupMaxBackwardDuration: 3 * 60,\n    autoCleanupMinBackwardDuration: 2 * 60,\n\n    statisticsInfoReportInterval: 600,\n\n    fixAudioTimestampGap: true,\n\n    accurateSeek: false,\n    seekType: 'range',  // [range, param, custom]\n    seekParamStart: 'bstart',\n    seekParamEnd: 'bend',\n    rangeLoadZeroStart: false,\n    customSeekHandler: undefined,\n    reuseRedirectedURL: false,\n    // referrerPolicy: leave as unspecified\n\n    headers: undefined,\n    customLoader: undefined\n};\n\n\nexport const TransmuxingEvents = {\n    IO_ERROR: 'io_error',\n    DEMUX_ERROR: 'demux_error',\n    INIT_SEGMENT: 'init_segment',\n    MEDIA_SEGMENT: 'media_segment',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info',\n    RECOMMEND_SEEKPOINT: 'recommend_seekpoint'\n};\n\nexport const DemuxErrors = {\n    OK: 'OK',\n    FORMAT_ERROR: 'FormatError',\n    FORMAT_UNSUPPORTED: 'FormatUnsupported',\n    CODEC_UNSUPPORTED: 'CodecUnsupported'\n};\n\nexport const MSEEvents = {\n    ERROR: 'error',\n    SOURCE_OPEN: 'source_open',\n    UPDATE_END: 'update_end',\n    BUFFER_FULL: 'buffer_full'\n};\n\nexport const PlayerEvents = {\n    ERROR: 'error',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info'\n};\n\nexport const ErrorTypes = {\n    NETWORK_ERROR: 'NetworkError',\n    MEDIA_ERROR: 'MediaError',\n    OTHER_ERROR: 'OtherError'\n};\n\nexport const LoaderErrors = {\n    OK: 'OK',\n    EXCEPTION: 'Exception',\n    HTTP_STATUS_CODE_INVALID: 'HttpStatusCodeInvalid',\n    CONNECTING_TIMEOUT: 'ConnectingTimeout',\n    EARLY_EOF: 'EarlyEof',\n    UNRECOVERABLE_EARLY_EOF: 'UnrecoverableEarlyEof'\n};\n\nexport const ErrorDetails = {\n    NETWORK_EXCEPTION: LoaderErrors.EXCEPTION,\n    NETWORK_STATUS_CODE_INVALID: LoaderErrors.HTTP_STATUS_CODE_INVALID,\n    NETWORK_TIMEOUT: LoaderErrors.CONNECTING_TIMEOUT,\n    NETWORK_UNRECOVERABLE_EARLY_EOF: LoaderErrors.UNRECOVERABLE_EARLY_EOF,\n\n    MEDIA_MSE_ERROR: 'MediaMSEError',\n\n    MEDIA_FORMAT_ERROR: DemuxErrors.FORMAT_ERROR,\n    MEDIA_FORMAT_UNSUPPORTED: DemuxErrors.FORMAT_UNSUPPORTED,\n    MEDIA_CODEC_UNSUPPORTED: DemuxErrors.CODEC_UNSUPPORTED\n};\n","import {_concatArrayBuffers} from \"../utils/utils\";\n\nclass RTMPMessage{\n    static MessageTypes = [\"dummy\", \"PCMSetChunkSize\", \"PCMAbortMessage\", \"PCMAcknolegement\", \"UserControlMessage\", \"WindowAcknowledgementSize\", \"PCMSetPeerBandwidth\",\n        \"dummy\", \"AudioMessage\", \"VideoMessage\", \"dummy\", \"dummy\", \"dummy\", \"dummy\", \"dummy\", \"DataMessageAMF3\", \"Shared Object Message AMF3\", \"CommandMessageAMF3\",\n        \"DataMessageAMF0\", \"SharedObjectMessageAMF0\", \"CommandMessageAMF0\", \"dummy\", \"Aggregate Message\"];\n\n    messageType;\n\tmessageLength;\n    length;\n\ttimestamp;\n    extendedTimestamp = false;\n\tmessage_stream_id = 0;\n\tpayload;\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     */\n\tconstructor(payload) {\n        if(payload) {\n            this.setPayload(payload);\n        }\n\t}\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     */\n\tsetPayload(payload){\n\t\tthis.payload = payload;\n\t\tthis.length = this.payload.length;\n\t}\n\n    /**\n     *\n     * @returns {Uint8Array}\n     */\n\tgetBytes(){\n\t\tthis.header = new Uint8Array(11);\n\t\tthis.header[0] = this.messageType;\n\n\t\tthis.header[1] = (this.length >>> 16);\n\t\tthis.header[2] = (this.length >>> 8);\n\t\tthis.header[3] = (this.length);\n\n\t\tthis.header[4] = (this.timestamp >>> 24);\n\t\tthis.header[5] = (this.timestamp >>> 16);\n\t\tthis.header[6] = (this.timestamp >>> 8);\n\t\tthis.header[7] = (this.timestamp);\n\n\t\tthis.header[8] = (this.message_stream_id >>> 16);\n\t\tthis.header[9] = (this.message_stream_id >>> 8);\n\t\tthis.header[10] = (this.message_stream_id);\n\n\t\treturn _concatArrayBuffers(this.header, this.payload);\n\t}\n\n    setMessageType(message_type){\n        this.messageType = message_type;\n        switch(message_type){\n            case 1:\t\t// setBandwidth\n            case 2:\n            case 3:\n            case 4:     // UserControlMSG\n            case 5:\n            case 6:\n                this.message_stream_id = 0;\n                break;\n        }\n    }\n\n\tgetMessageType(){\n\t\treturn this.messageType;\n\t}\n\n    getMessageStreamID(){\n        return this.message_stream_id;\n    }\n\n\tsetMessageStreamID(messageStreamID) {\n\t\tthis.message_stream_id = messageStreamID;\n\t}\n\n\tgetPayloadlength(){\n\t\treturn this.payload.length;\n\t}\n\n    getTimestamp(){\n        return this.timestamp;\n    }\n\n\tsetMessageTimestamp(timestamp) {\n\t\tthis.timestamp = timestamp;\n\t}\n\n    /**\n     *\n     * @param {boolean} yes\n     */\n    setExtendedTimestamp(yes){\n        this.extendedTimestamp = yes;\n    }\n\n    getExtendedTimestamp(){\n        return this.extendedTimestamp;\n    }\n\n\taddPayload(data){\n\t\tif(data.length > this.bytesMissing()) {\n\t\t\tconsole.error(\"try to add too much data\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.payload = _concatArrayBuffers(this.payload, data);\n\t\tthis.length = this.payload.length;\n\t\tconsole.log(\"[ RTMPMessage ] payload size is now: \" + this.length);\n\t}\n\n\tgetPayload(){\n\t\treturn this.payload;\n\t}\n\n    setMessageLength(message_length) {\n        this.messageLength = message_length;\n    }\n\n\tgetMessageLength(){\n\t\treturn this.messageLength;\n\t}\n\n\tisComplete(){\n\t\tif(this.payload.length === this.messageLength) return true;\n\t\treturn false;\n\t}\n\n\tbytesMissing(){\n\t\treturn this.messageLength - this.payload.length;\n\t}\n}\n\nexport default RTMPMessage;\n","import {_concatArrayBuffers} from \"../utils/utils\";\n\nclass Chunk{\n    chunk_stream_id = 0;\n\n    length;\n\n    message_type;\n    message_stream_id = 0;\n\n    timestamp;\n    CHUNK_SIZE = 128;\n    payload;\n\n    /**\n     * @param {RTMPMessage} message\n     */\n    constructor(message) {  // RTMP Message\n        this.payload = message.getPayload();\n        this.length = this.payload.length;\n        this.message_type = message.getMessageType();\n        this.message_stream_id = message.getMessageStreamID();\n    }\n\n    /**\n     *\n     * @returns {Uint8Array}\n     */\n    getBytes(){\n        let p = new Uint8Array(this.payload);\n\n        let ret = new Uint8Array(0);\n        let fmt = 0;\n\n        do {\n            console.log(\"[ Chunk ] create chunk: \" + p.length);\n            ret = _concatArrayBuffers(ret, this._getHeaderBytes(fmt), p.slice(0,this.CHUNK_SIZE));\n            p = p.slice(this.CHUNK_SIZE);\n            fmt = 0x3;\t// next chunk without header\n\n        } while(p.length > 0);\n\n        return ret;\n    }\n\n    /**\n     *\n     * @param {Number} fmt\n     * @returns {Uint8Array}\n     * @private\n     */\n    _getHeaderBytes(fmt){\n        let basic_header;\n        let header;\n\n        if(this.chunk_stream_id < 63) {\n            basic_header = new Uint8Array(1);\n            basic_header[0] = (fmt << 6) | this.chunk_stream_id;\n\n        } else if(this.chunk_stream_id < 65599) {\n            basic_header = new Uint8Array(2);\n            basic_header[0] = (fmt << 6);\n            basic_header[1] = (this.chunk_stream_id -64);\n\n        } else {\n            basic_header = new Uint8Array(3);\n            basic_header[0] = (fmt << 6) | 63;\n            basic_header[1] = ((this.chunk_stream_id -64) >>> 8);\n            basic_header[2] = ((this.chunk_stream_id -64));\n        }\n\n        switch(fmt){\n            case 0x0:\n                header = new Uint8Array(11);\n                header[0] = (this.timestamp >>> 16);\n                header[1] = (this.timestamp >>> 8);\n                header[2] = (this.timestamp);\n\n                header[3] = (this.length >>> 16);\n                header[4] = (this.length >>> 8);\n                header[5] = (this.length);\n\n                header[6] = (this.message_type);\n\n                header[7] = (this.message_stream_id >>> 24);\n                header[8] = (this.message_stream_id >>> 16);\n                header[9] = (this.message_stream_id >>> 8);\n                header[10] = (this.message_stream_id);\n                break;\n\n            case 0x1:\n                header = new Uint8Array(7);\n                header[0] = (this.timestamp >>> 16);\n                header[1] = (this.timestamp >>> 8);\n                header[2] = (this.timestamp);\n\n                header[3] = (this.length >>> 16);\n                header[4] = (this.length >>> 8);\n                header[5] = (this.length);\n\n                header[6] = (this.message_type);\n                break;\n\n\n            case 0x2:\n                header = new Uint8Array(3);\n                header[0] = (this.timestamp >>> 16);\n                header[1] = (this.timestamp >>> 8);\n                header[2] = (this.timestamp);\n                break;\n\n            case 0x3:\n                header = new Uint8Array(0);\n                break;\n        }\n\n        return _concatArrayBuffers(basic_header, header);\n    }\n\n    getPayload(){\n        return this.payload;\n    }\n\n    getMessageType(){\n        return this.message_type;\n    }\n\n    getMessageStreamID() {\n        return this.message_stream_id;\n    }\n\n    setChunkSize(size){\n        this.CHUNK_SIZE = size;\n    }\n\n    setChunkStreamID(chunk_stream_id) {\n        console.log(\"[ Chunk ] setChunkStreamID:\" + chunk_stream_id);\n        this.chunk_stream_id = chunk_stream_id;\n    }\n\n    setMessageStreamID(message_stream_id) {\n        this.message_stream_id = message_stream_id;\n    }\n\n    setTimestamp(timestamp){\n        this.timestamp = timestamp;\n    }\n}\n\nexport default Chunk;\n","class UserControlMessage{\n    event_type;\n    event_data1;\n    event_data2;\n\n    static events = [\"StreamBegin\", \"StreamEOF\", \"StreamDry\", \"SetBuffer\", \"StreamIsRecorded\", \"dummy\", \"PingRequest\", \"PingResponse\"];\n\n    /**\n     *\n     * @returns {Uint8Array}\n     */\n    getBytes(){\n        let ret;\n\n        if(this.event_data2) {\n            ret = new Uint8Array(10);\n            ret[0] = (this.event_type >>> 8);\n            ret[1] = (this.event_type);\n\n            ret[2] = (this.event_data1 >>> 24);\n            ret[3] = (this.event_data1 >>> 16);\n            ret[4] = (this.event_data1 >>> 8);\n            ret[5] = (this.event_data1);\n\n            ret[6] = (this.event_data2 >>> 24);\n            ret[7] = (this.event_data2 >>> 16);\n            ret[8] = (this.event_data2 >>> 8);\n            ret[9] = (this.event_data2);\n\n        } else {\n            ret = new Uint8Array(6);\n            ret[0] = (this.event_type >>> 8);\n            ret[1] = (this.event_type);\n\n            ret[2] = (this.event_data1 >>> 24);\n            ret[3] = (this.event_data1 >>> 16);\n            ret[4] = (this.event_data1 >>> 8);\n            ret[5] = (this.event_data1);\n        }\n\n        return ret;\n    }\n\n    getEventMessage(){\n        let o = {};\n\n        if(this.event_type === 3) {\n            o[UserControlMessage.events[this.event_type]] = [this.event_data1, this.event_data2];\n        } else {\n            o[UserControlMessage.events[this.event_type]] = this.event_data1;\n        }\n\n        return o;\n    }\n\n    setType(event_type){\n        this.event_type = event_type;\n    }\n\n    setEventData(event_data){\n        this.event_data1 = event_data;\n    }\n}\n\nexport default UserControlMessage;\n","class ProtocolControlMessage{\n    pcm_type;\n    data;\n\n    static pcm_types = [\"dummy\", \"SetChunkSize\", \"AbortMessage\", \"Acknowledgement\", \"UserControlMessage\", \"WindowAcknowledgementSize\", \"SetPeerBandwidth\"];\n\n    constructor(pcm_type, data) {\n        switch(pcm_type){\n        case 1:\n        case 2:\n        case 3:\n        case 5:\n            this.pcm_type = pcm_type;\n            this.data = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\n            break;\n\n        case 6:\n            console.error(\"Protocol Control Message Type: \" + pcm_type + \" use SetPeerBandwidthMessage\");\n            break;\n\n        default:\n            console.error(\"Protocol Control Message Type: \" + pcm_type + \" not supported\");\n            break;\n        }\n    }\n\n    setPayload(data){\n        this.data = data;\n    }\n\n    getEventMessage(){\n        let o = {};\n        o[ProtocolControlMessage.pcm_types[this.pcm_type]] = this.data;\n        return o;\n    }\n\n    getBytes(){\n        let ret = [];\n\n        ret[0] = (this.data >>> 24);\n        ret[1] = (this.data >>> 16);\n        ret[2] = (this.data >>> 8);\n        ret[3] = (this.data);\n\n        return new Uint8Array(ret);\n    }\n}\nexport default ProtocolControlMessage;\n","import ProtocolControlMessage from \"./ProtocolControlMessage\";\nimport RTMPMessage from \"./RTMPMessage\";\nimport Chunk from \"./Chunk\";\n\nclass NetConnection{\n    WindowAcknowledgementSize;\n    MessageStreamID;\n    CHUNK_SIZE = 128;\n    BandWidth;\n    socket;\n\n    netstreams = [];\n\n    /**\n     *\n     * @param {Number} message_stream_id\n     * @param {RTMPMessageHandler} handler\n     */\n    constructor(message_stream_id, handler) {\n        this.MessageStreamID = message_stream_id;\n\n        console.log(handler);\n\n        this.handler = handler;\n        this.socket = handler.socket;\n    }\n\n    /**\n     *\n     * @param {RTMPMessage} message\n     */\n    parseMessage(message){      // RTMPMessage\n        let data = message.getPayload();\n\n        switch(message.getMessageType()){\n        case 1:         // PCM Set Chunk Size\n            this.CHUNK_SIZE = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\n            this.handler.setChunkSize(this.CHUNK_SIZE)\n            break;\n\n        case 2:         // PCM Abort Message\n        case 3:         // PCM Acknowledgement\n        case 5:         // PCM Window Acknowledgement Size\n            this.WindowAcknowledgementSize = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\n            console.log(\"[ NetConnection ] WindowAcknowledgementSize: \" + this.WindowAcknowledgementSize);\n            break;\n\n        case 6:         // PCM Set Peer Bandwidth\n            this.BandWidth = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\n            console.log(\"[ NetConnection ] SetPeerBandwidth: \" + this.BandWidth);\n\n            // send Window Ack Size\n            let msg = new ProtocolControlMessage(0x05, this.WindowAcknowledgementSize);\n\n            let m2 = new RTMPMessage(msg.getBytes());\n            m2.setMessageType(0x05)     // WinACKSize\n\n            const chunk = new Chunk(m2);\n            chunk.setChunkStreamID(2);  // Control Channel\n\n            console.log(\"[ NetConnection ] send WindowAcksize\");\n            this.socket.send(chunk.getBytes());\n\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    createStream(){\n\n    }\n}\n\nexport default NetConnection;\n","import RTMPMessage from \"./RTMPMessage\";\nimport {_concatArrayBuffers} from \"../utils/utils\";\n\nclass ChunkParser {\n    /**\n     *\n     * @type {number}\n     */\n\tstatic CHUNK_SIZE = 128;\n    chunkstreams = [];\n\n    /**\n     * @type {Uint8Array}\n     */\n    buffer = new Uint8Array(0);\n\n    /**\n     *\n     * @param {RTMPMessageHandler} conn_worker\n     */\n\tconstructor(conn_worker) {\n        this.conn_worker = conn_worker;\n    }\n\n    /**\n     * @param {Uint8Array} newdata\n     */\n    parseChunk(newdata){\n        let msg;\n        let timestamp;\n        let fmt;\n\n        this.buffer = _concatArrayBuffers(this.buffer, newdata);      // Neues Packet an Buffer anfügen\n\n        do {\n            console.log(\"[ ChunkParser ] buffer length: \" + this.buffer.length);\n\n            if(this.buffer.length < 100) console.log(this.buffer);\n\n            /**\n             *\n             * @type {Uint8Array}\n             */\n            let data = this.buffer;\n            let header_length = 0;\n            let message_length = 0;\n            let payload_length = 0;\n\n            // Message Header Type\n            fmt = ((data[0] & 0xC0) >>> 6);  // upper 2 bit\n            console.log(\"[ ChunkParser ] chunk type: \", fmt);\n\n            // Basic Header ChunkID\n            let csid = data[header_length++] & 0x3f;\t// lower 6 bits\n\n            if(csid === 0) {\t\t\t\t\t// csid is 14bit\n                csid = data[header_length++] + 64;\n\n            } else if (csid === 1) {\t\t\t// csid is 22bit\n                csid = data[header_length++] * 256 + data[header_length++] + 64;\n            }\n\n            console.log(\"[ ChunkParser ] chunk_stream_id: \", csid);\n\n            let payload;\n\n            // Message\n            switch(fmt) {\n                case 0:\t\t// 11 byte\n                timestamp = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\t// 3 byte timestamp\n                message_length = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\t// 3 byte Message length\n\n                msg = new RTMPMessage();\n                msg.setMessageType(data[header_length++]);                // 1 byte msg type\n                msg.setMessageStreamID((data[header_length++] << 24) | (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]));\t// 4 byte Message stream id\n                msg.setMessageLength(message_length);\n\n                if (timestamp === 0xFFFFFF) {\t// extended Timestamp\n                    timestamp += data[header_length++];\n                    msg.setExtendedTimestamp(true);\n                }\n\n                msg.setMessageTimestamp(timestamp);\n\n                console.log(\"[ ChunkParser ] message_length: \" + message_length);\n\n                payload_length = message_length;\n\n                if(payload_length > this.CHUNK_SIZE){\n                    // Wir erwarten CHUNK_SIZE bytes\n                    payload_length = this.CHUNK_SIZE;\n                }\n\n                payload = data.slice(header_length, header_length +payload_length);\n\n                // haben wir alles\n                if(payload.length < payload_length){\n                    // wait for next packet\n                    console.log(\"[ ChunkParser ] packet(\" + payload.length + \"/\" + payload_length + \") too small, wait for next\");\n                    return;\n                }\n\n                msg.setPayload(payload);\n\n                this.chunkstreams[csid] = msg;\n                break;\n\n            case 1:\t\t// 7 byte\n                timestamp = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\t// 3 byte timestamp\n                message_length = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\t// 3 byte Message length\n\n                msg = new RTMPMessage();\n                msg.setMessageType(data[header_length++]);\n                msg.setMessageLength(message_length);\n\n                if (timestamp === 0xFFFFFF) {\t// extended Timestamp\n                    timestamp += data[header_length++];\n                    msg.setExtendedTimestamp(true);\n                }\n                msg.setMessageTimestamp(timestamp);\n\n\n                console.log(\"[ ChunkParser ] message_length: \" + message_length);\n\n                payload_length = message_length;\n\n                if(payload_length > this.CHUNK_SIZE){\n                    // Wir erwarten CHUNK_SIZE bytes\n                    payload_length = this.CHUNK_SIZE;\n                }\n\n                payload = data.slice(header_length, header_length +payload_length);\n\n                // haben wir alles? message_length oder CHUNK_SIZE\n                if(payload.length < payload_length){\n                    // wait for next packet\n                    console.log(\"[ ChunkParser ] packet(\" + payload.length + \"/\" + payload_length + \") too small, wait for next\");\n                    return;\n                }\n\n                msg.setPayload(payload);\n\n                this.chunkstreams[csid] = msg;\n                break;\n\n            case 2:\t\t// 3 byte\n                timestamp = (data[header_length++] << 16) | (data[header_length++] << 8) | (data[header_length++]);\t// 3 byte timestamp delta\n\n                msg = this.chunkstreams[csid];\n\n                if (timestamp === 0xFFFFFF) {\t// extended Timestamp\n                    timestamp += data[header_length++];\n                    msg.setExtendedTimestamp(true);\n                }\n\n                msg.setMessageTimestamp(timestamp);\n\n                payload = data.slice(header_length);\n                payload_length = msg.getMessageLength();\n\n                // haben wir alles\n                if(payload.length < payload_length){\n                    // wait for next packet\n                    console.log(\"[ ChunkParser ] packet(\" + payload.length + \"/\" + payload_length + \") too small, wait for next\");\n                    return;\n                }\n\n                if(payload.length > this.CHUNK_SIZE) {\n                    msg.addPayload(payload.slice(0, this.CHUNK_SIZE));\n                } else {\n                    msg.addPayload(payload);\n                }\n                break;\n\n            case 3:\t\t// 0 byte\n                msg = this.chunkstreams[csid];\n\n                // extended timestamp is present when setted in the chunk stream\n                if(msg.getExtendedTimestamp()) {\n                    header_length++;\n                }\n\n                payload_length = msg.bytesMissing();\n\n                if(payload_length > this.CHUNK_SIZE) {\n                    payload_length = this.CHUNK_SIZE;\n                }\n\n                payload = data.slice(header_length, header_length +payload_length);\n\n                // haben wir alles\n                if(payload.length < payload_length){\n                    // wait for next packet\n                    console.log(\"[ ChunkParser ] packet(\" + payload.length + \"/\" + payload_length + \") too small, wait for next\");\n                    return;\n                }\n\n                msg.addPayload(payload);\n                break;\n            }\n\n\n\n\n\n\n\n\n            if(this.chunkstreams[csid].isComplete()) {     // Message complete\n                console.log(\"[ ChunkParser ] RTMP: \", msg.getMessageType(), RTMPMessage.MessageTypes[msg.getMessageType()], msg.getPayloadlength(), msg.getMessageStreamID());\n\n                this.conn_worker.onMessage(this.chunkstreams[csid]);\n            }\n\n            let consumed = (header_length + payload_length);\n\n            console.log(\"[ ChunkParser ] cut: \" + consumed);\n\n            if(isNaN(consumed)) {\n                return;\n            }\n\n            if(consumed > this.buffer.length) {\n                console.warn(\"[ ChunkParser ] mehr abschneiden als da\");\n                return;\n            }\n\n            this.buffer = this.buffer.slice(consumed);\n            console.log(\"[ ChunkParser ] now: \" + this.buffer.length);\n\n        } while(this.buffer.length > 11);   // minimum size\n\n        console.log(\"parseChunk complete\");\n    }\n\n    /**\n     *\n     * @param {Number} size\n     */\n    setChunkSize(size){\n        console.log(\"[ ChunkParser ] SetChunkSize: \" + size);\n        this.CHUNK_SIZE = size;\n    }\n}\n\nexport default ChunkParser;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class RuntimeException {\n    constructor(message) {\n        this._message = message;\n    }\n\n    get name() {\n        return 'RuntimeException';\n    }\n\n    get message() {\n        return this._message;\n    }\n\n    toString() {\n        return this.name + ': ' + this.message;\n    }\n}\n\nexport class IllegalStateException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'IllegalStateException';\n    }\n}\n\nexport class InvalidArgumentException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'InvalidArgumentException';\n    }\n}\n\nexport class NotImplementedException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'NotImplementedException';\n    }\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass MediaInfo {\n\n\tconstructor() {\n\t\tthis.mimeType = null;\n\t\tthis.duration = null;\n\n\t\tthis.hasAudio = null;\n\t\tthis.hasVideo = null;\n\t\tthis.audioCodec = null;\n\t\tthis.videoCodec = null;\n\t\tthis.audioDataRate = null;\n\t\tthis.videoDataRate = null;\n\n\t\tthis.audioSampleRate = null;\n\t\tthis.audioChannelCount = null;\n\n\t\tthis.width = null;\n\t\tthis.height = null;\n\t\tthis.fps = null;\n\t\tthis.profile = null;\n\t\tthis.level = null;\n\t\tthis.refFrames = null;\n\t\tthis.chromaFormat = null;\n\t\tthis.sarNum = null;\n\t\tthis.sarDen = null;\n\n\t\tthis.metadata = null;\n\t\tthis.segments = null;  // MediaInfo[]\n\t\tthis.segmentCount = null;\n\t\tthis.hasKeyframesIndex = null;\n\t\tthis.keyframesIndex = null;\n\t}\n\n\tisComplete() {\n\t\tlet audioInfoComplete = (this.hasAudio === false) ||\n\t\t\t(this.hasAudio === true &&\n\t\t\t\tthis.audioCodec != null &&\n\t\t\t\tthis.audioSampleRate != null &&\n\t\t\t\tthis.audioChannelCount != null);\n\n\t\tlet videoInfoComplete = (this.hasVideo === false) ||\n\t\t\t(this.hasVideo === true &&\n\t\t\t\tthis.videoCodec != null &&\n\t\t\t\tthis.width != null &&\n\t\t\t\tthis.height != null &&\n\t\t\t\tthis.fps != null &&\n\t\t\t\tthis.profile != null &&\n\t\t\t\tthis.level != null &&\n\t\t\t\tthis.refFrames != null &&\n\t\t\t\tthis.chromaFormat != null &&\n\t\t\t\tthis.sarNum != null &&\n\t\t\t\tthis.sarDen != null);\n\n\t\t// keyframesIndex may not be present\n\t\treturn this.mimeType != null &&\n\t\t\tthis.duration != null &&\n\t\t\tthis.metadata != null &&\n\t\t\tthis.hasKeyframesIndex != null &&\n\t\t\taudioInfoComplete &&\n\t\t\tvideoInfoComplete;\n\t}\n\n\tisSeekable() {\n\t\treturn this.hasKeyframesIndex === true;\n\t}\n\n\tgetNearestKeyframe(milliseconds) {\n\t\tif (this.keyframesIndex == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet table = this.keyframesIndex;\n\t\tlet keyframeIdx = this._search(table.times, milliseconds);\n\n\t\treturn {\n\t\t\tindex: keyframeIdx,\n\t\t\tmilliseconds: table.times[keyframeIdx],\n\t\t\tfileposition: table.filepositions[keyframeIdx]\n\t\t};\n\t}\n\n\t_search(list, value) {\n\t\tlet idx = 0;\n\n\t\tlet last = list.length - 1;\n\t\tlet mid = 0;\n\t\tlet lbound = 0;\n\t\tlet ubound = last;\n\n\t\tif (value < list[0]) {\n\t\t\tidx = 0;\n\t\t\tlbound = ubound + 1;  // skip search\n\t\t}\n\n\t\twhile (lbound <= ubound) {\n\t\t\tmid = lbound + Math.floor((ubound - lbound) / 2);\n\t\t\tif (mid === last || (value >= list[mid] && value < list[mid + 1])) {\n\t\t\t\tidx = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (list[mid] < value) {\n\t\t\t\tlbound = mid + 1;\n\t\t\t} else {\n\t\t\t\tubound = mid - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn idx;\n\t}\n\n}\n\nexport default MediaInfo;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * This file is derived from C++ project libWinTF8 (https://github.com/m13253/libWinTF8)\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function checkContinuation(uint8array, start, checkLength) {\n    let array = uint8array;\n    if (start + checkLength < array.length) {\n        while (checkLength--) {\n            if ((array[++start] & 0xC0) !== 0x80)\n                return false;\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function decodeUTF8(uint8array) {\n    let out = [];\n    let input = uint8array;\n    let i = 0;\n    let length = uint8array.length;\n\n    while (i < length) {\n        if (input[i] < 0x80) {\n            out.push(String.fromCharCode(input[i]));\n            ++i;\n            continue;\n        } else if (input[i] < 0xC0) {\n            // fallthrough\n        } else if (input[i] < 0xE0) {\n            if (checkContinuation(input, i, 1)) {\n                let ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F);\n                if (ucs4 >= 0x80) {\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                    i += 2;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF0) {\n            if (checkContinuation(input, i, 2)) {\n                let ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n                if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                    i += 3;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF8) {\n            if (checkContinuation(input, i, 3)) {\n                let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12\n                    | (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F);\n                if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n                    ucs4 -= 0x10000;\n                    out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800));\n                    out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00));\n                    i += 4;\n                    continue;\n                }\n            }\n        }\n        out.push(String.fromCharCode(0xFFFD));\n        ++i;\n    }\n\n    return out.join('');\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport {IllegalStateException} from \"../utils/exception\";\nimport {decodeUTF8} from \"../utils/utf8-conv\";\n\nlet le = (function () {\n    let buf = new ArrayBuffer(2);\n    (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\n    return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\n})();\n\nclass AMF {\n\n    /**\n     *\n     * @param {Uint8Array} array\n     * @returns {{}}\n     */\n    static parseScriptData(array) {\n        console.log(array);\n\n        let data = {};\n\n        try {\n            let name = AMF.parseValue(array);\n            console.log(name);\n\n            let value = AMF.parseValue(array.slice(name.size));\n            console.log(value);\n\n            data[name.data] = value.data;\n\n        } catch (e) {\n            console.error('AMF', e.toString());\n        }\n\n        return data;\n    }\n\n    /**\n     *\n     * @param {Uint8Array} array\n     * @returns {{data: {name: string, value: {}}, size: number, objectEnd: boolean}}\n     */\n    static parseObject(array) {\n        if (array.length < 3) {\n            throw new IllegalStateException('Data not enough when parse ScriptDataObject');\n        }\n        let name = AMF.parseString(array);\n        let value = AMF.parseValue(array.slice(name.size, array.length - name.size));\n        let isObjectEnd = value.objectEnd;\n\n        return {\n            data: {\n                name: name.data,\n                value: value.data\n            },\n            size: name.size + value.size,\n            objectEnd: isObjectEnd\n        };\n    }\n\n    /**\n     *\n     * @param {Uint8Array} array\n     * @returns {{data: {name: string, value: {}}, size: number, objectEnd: boolean}}\n     */\n    static parseVariable(array) {\n        return AMF.parseObject(array);\n    }\n\n    /**\n     *\n     * @param {Uint8Array} array\n     * @returns {{data: string, size: number}}\n     */\n    static parseString(array) {\n        if (array.length < 2) {\n            throw new IllegalStateException('Data not enough when parse String');\n        }\n        let v = new DataView(array.buffer);\n        let length = v.getUint16(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(array.slice(2, 2 + length)));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 2 + length\n        };\n    }\n\n    static parseLongString(array) {\n        if (array.length() < 4) {\n            throw new IllegalStateException('Data not enough when parse LongString');\n        }\n        let v = new DataView(array.buffer);\n        let length = v.getUint32(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(array.slice(4, 4 +length)));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 4 + length\n        };\n    }\n\n    static parseDate(array) {\n        if (array.length() < 10) {\n            throw new IllegalStateException('Data size invalid when parse Date');\n        }\n        let v = new DataView(array.buffer);\n        let timestamp = v.getFloat64(0, !le);\n        let localTimeOffset = v.getInt16(8, !le);\n        timestamp += localTimeOffset * 60 * 1000;  // get UTC time\n\n        return {\n            data: new Date(timestamp),\n            size: 8 + 2\n        };\n    }\n\n    /**\n     *\n     * @param {Uint8Array} array\n     * @returns {{data: {}, size: number, objectEnd: boolean}}\n     */\n    static parseValue(array) {\n        if (array.length < 1) {\n            throw new IllegalStateException('Data not enough when parse Value');\n        }\n\n        let v = new DataView(array.buffer);\n\n        let offset = 1;\n        let type = v.getUint8(0);\n        let value;\n        let objectEnd = false;\n\n        try {\n            switch (type) {\n                case 0:  // Number(Double) type\n                    value = v.getFloat64(1, !le);\n                    offset += 8;\n                    break;\n                case 1: {  // Boolean type\n                    let b = v.getUint8(1);\n                    value = b ? true : false;\n                    offset += 1;\n                    break;\n                }\n                case 2: {  // String type\n                    let amfstr = AMF.parseString(array.slice(1));\n                    value = amfstr.data;\n                    offset += amfstr.size;\n                    break;\n                }\n                case 3: { // Object(s) type\n                    value = {};\n                    let terminal = 0;  // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                    if ((v.getUint32(array.length - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (offset < array.length - 4) {  // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                        let amfobj = AMF.parseObject(array.slice(offset, offset + array.length - terminal));\n                        if (amfobj.objectEnd)\n                            break;\n                        value[amfobj.data.name] = amfobj.data.value;\n                        offset += amfobj.size;\n                    }\n                    if (offset <= array.length - 3) {\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            offset += 3;\n                        }\n                    }\n                    break;\n                }\n                case 8: { // ECMA array type (Mixed array)\n                    value = {};\n                    offset += 4;  // ECMAArrayLength(UI32)\n                    let terminal = 0;  // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                    if ((v.getUint32(array.length - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (offset < array.length - 8) {  // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                        let amfvar = AMF.parseVariable(array.slice(offset, offset + array.length - terminal));\n                        if (amfvar.objectEnd)\n                            break;\n                        value[amfvar.data.name] = amfvar.data.value;\n                        offset += amfvar.size;\n                    }\n                    if (offset <= array.length - 3) {\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            offset += 3;\n                        }\n                    }\n                    break;\n                }\n                case 9:  // ScriptDataObjectEnd\n                    value = undefined;\n                    offset = 1;\n                    objectEnd = true;\n                    break;\n                case 10: {  // Strict array type\n                    // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                    value = [];\n                    let strictArrayLength = v.getUint32(1, !le);\n                    offset += 4;\n                    for (let i = 0; i < strictArrayLength; i++) {\n                        let val = AMF.parseValue(array.slice(offset, array.length));\n                        value.push(val.data);\n                        offset += val.size;\n                    }\n                    break;\n                }\n                case 11: {  // Date type\n                    let date = AMF.parseDate(array.slice(1));\n                    value = date.data;\n                    offset += date.size;\n                    break;\n                }\n                case 12: {  // Long string type\n                    let amfLongStr = AMF.parseString(array.slice(1));\n                    value = amfLongStr.data;\n                    offset += amfLongStr.size;\n                    break;\n                }\n                default:\n                    // ignore and skip\n                    offset = array.length;\n                    console.warn('Unsupported AMF value type ' + type);\n            }\n        } catch (e) {\n            console.error('AMF', e.toString());\n        }\n\n        return {\n            data: value,\n            size: offset,\n            objectEnd: objectEnd\n        };\n    }\n}\n\nexport default AMF;\n","export class Log {\n    static v(...params){\n        console.log(...params);\n    }\n\n    static e(...params){\n        console.error(...params);\n    }\n\n    static w(...params){\n        console.warn(...params);\n    }\n\n    static t(...params){\n        console.trace(...params);\n    }\n\n    static i(...params){\n        console.info(...params);\n    }\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Exponential-Golomb buffer decoder\nclass ExpGolomb {\n\n    constructor(uint8array) {\n        this.TAG = 'ExpGolomb';\n\n        this._buffer = uint8array;\n        this._buffer_index = 0;\n        this._total_bytes = uint8array.byteLength;\n        this._total_bits = uint8array.byteLength * 8;\n        this._current_word = 0;\n        this._current_word_bits_left = 0;\n    }\n\n    destroy() {\n        this._buffer = null;\n    }\n\n    _fillCurrentWord() {\n        let buffer_bytes_left = this._total_bytes - this._buffer_index;\n        if (buffer_bytes_left <= 0)\n            throw new IllegalStateException('ExpGolomb: _fillCurrentWord() but no bytes available');\n\n        let bytes_read = Math.min(4, buffer_bytes_left);\n        let word = new Uint8Array(4);\n        word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));\n        this._current_word = new DataView(word.buffer).getUint32(0, false);\n\n        this._buffer_index += bytes_read;\n        this._current_word_bits_left = bytes_read * 8;\n    }\n\n    readBits(bits) {\n        if (bits > 32)\n            throw new InvalidArgumentException('ExpGolomb: readBits() bits exceeded max 32bits!');\n\n        if (bits <= this._current_word_bits_left) {\n            let result = this._current_word >>> (32 - bits);\n            this._current_word <<= bits;\n            this._current_word_bits_left -= bits;\n            return result;\n        }\n\n        let result = this._current_word_bits_left ? this._current_word : 0;\n        result = result >>> (32 - this._current_word_bits_left);\n        let bits_need_left = bits - this._current_word_bits_left;\n\n        this._fillCurrentWord();\n        let bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);\n\n        let result2 = this._current_word >>> (32 - bits_read_next);\n        this._current_word <<= bits_read_next;\n        this._current_word_bits_left -= bits_read_next;\n\n        result = (result << bits_read_next) | result2;\n        return result;\n    }\n\n    readBool() {\n        return this.readBits(1) === 1;\n    }\n\n    readByte() {\n        return this.readBits(8);\n    }\n\n    _skipLeadingZero() {\n        let zero_count;\n        for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {\n            if (0 !== (this._current_word & (0x80000000 >>> zero_count))) {\n                this._current_word <<= zero_count;\n                this._current_word_bits_left -= zero_count;\n                return zero_count;\n            }\n        }\n        this._fillCurrentWord();\n        return zero_count + this._skipLeadingZero();\n    }\n\n    readUEG() {  // unsigned exponential golomb\n        let leading_zeros = this._skipLeadingZero();\n        return this.readBits(leading_zeros + 1) - 1;\n    }\n\n    readSEG() {  // signed exponential golomb\n        let value = this.readUEG();\n        if (value & 0x01) {\n            return (value + 1) >>> 1;\n        } else {\n            return -1 * (value >>> 1);\n        }\n    }\n\n}\n\nexport default ExpGolomb;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nimport ExpGolomb from \"./exp-golomb\";\n\nclass SPSParser {\n    static _ebsp2rbsp(uint8array) {\n        let src = uint8array;\n        let src_length = src.byteLength;\n        let dst = new Uint8Array(src_length);\n        let dst_idx = 0;\n\n        for (let i = 0; i < src_length; i++) {\n            if (i >= 2) {\n                // Unescape: Skip 0x03 after 00 00\n                if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n                    continue;\n                }\n            }\n            dst[dst_idx] = src[i];\n            dst_idx++;\n        }\n\n        return new Uint8Array(dst.buffer, 0, dst_idx);\n    }\n\n    static parseSPS(uint8array) {\n        let rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb = new ExpGolomb(rbsp);\n\n        gb.readByte();\n        let profile_idc = gb.readByte();  // profile_idc\n        gb.readByte();  // constraint_set_flags[5] + reserved_zero[3]\n        let level_idc = gb.readByte();  // level_idc\n        gb.readUEG();  // seq_parameter_set_id\n\n        let profile_string = SPSParser.getProfileString(profile_idc);\n        let level_string = SPSParser.getLevelString(level_idc);\n        let chroma_format_idc = 1;\n        let chroma_format = 420;\n        let chroma_format_table = [0, 420, 422, 444];\n        let bit_depth = 8;\n\n        if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 ||\n            profile_idc === 244 || profile_idc === 44 || profile_idc === 83 ||\n            profile_idc === 86 || profile_idc === 118 || profile_idc === 128 ||\n            profile_idc === 138 || profile_idc === 144) {\n\n            chroma_format_idc = gb.readUEG();\n            if (chroma_format_idc === 3) {\n                gb.readBits(1);  // separate_colour_plane_flag\n            }\n            if (chroma_format_idc <= 3) {\n                chroma_format = chroma_format_table[chroma_format_idc];\n            }\n\n            bit_depth = gb.readUEG() + 8;  // bit_depth_luma_minus8\n            gb.readUEG();  // bit_depth_chroma_minus8\n            gb.readBits(1);  // qpprime_y_zero_transform_bypass_flag\n            if (gb.readBool()) {  // seq_scaling_matrix_present_flag\n                let scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12;\n                for (let i = 0; i < scaling_list_count; i++) {\n                    if (gb.readBool()) {  // seq_scaling_list_present_flag\n                        if (i < 6) {\n                            SPSParser._skipScalingList(gb, 16);\n                        } else {\n                            SPSParser._skipScalingList(gb, 64);\n                        }\n                    }\n                }\n            }\n        }\n        gb.readUEG();  // log2_max_frame_num_minus4\n        let pic_order_cnt_type = gb.readUEG();\n        if (pic_order_cnt_type === 0) {\n            gb.readUEG();  // log2_max_pic_order_cnt_lsb_minus_4\n        } else if (pic_order_cnt_type === 1) {\n            gb.readBits(1);  // delta_pic_order_always_zero_flag\n            gb.readSEG();  // offset_for_non_ref_pic\n            gb.readSEG();  // offset_for_top_to_bottom_field\n            let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n            for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n                gb.readSEG();  // offset_for_ref_frame\n            }\n        }\n        let ref_frames = gb.readUEG();  // max_num_ref_frames\n        gb.readBits(1);  // gaps_in_frame_num_value_allowed_flag\n\n        let pic_width_in_mbs_minus1 = gb.readUEG();\n        let pic_height_in_map_units_minus1 = gb.readUEG();\n\n        let frame_mbs_only_flag = gb.readBits(1);\n        if (frame_mbs_only_flag === 0) {\n            gb.readBits(1);  // mb_adaptive_frame_field_flag\n        }\n        gb.readBits(1);  // direct_8x8_inference_flag\n\n        let frame_crop_left_offset = 0;\n        let frame_crop_right_offset = 0;\n        let frame_crop_top_offset = 0;\n        let frame_crop_bottom_offset = 0;\n\n        let frame_cropping_flag = gb.readBool();\n        if (frame_cropping_flag) {\n            frame_crop_left_offset = gb.readUEG();\n            frame_crop_right_offset = gb.readUEG();\n            frame_crop_top_offset = gb.readUEG();\n            frame_crop_bottom_offset = gb.readUEG();\n        }\n\n        let sar_width = 1, sar_height = 1;\n        let fps = 0, fps_fixed = true, fps_num = 0, fps_den = 0;\n\n        let vui_parameters_present_flag = gb.readBool();\n        if (vui_parameters_present_flag) {\n            if (gb.readBool()) {  // aspect_ratio_info_present_flag\n                let aspect_ratio_idc = gb.readByte();\n                let sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n                let sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33,  99, 3, 2, 1];\n\n                if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n                    sar_width = sar_w_table[aspect_ratio_idc - 1];\n                    sar_height = sar_h_table[aspect_ratio_idc - 1];\n                } else if (aspect_ratio_idc === 255) {\n                    sar_width = gb.readByte() << 8 | gb.readByte();\n                    sar_height = gb.readByte() << 8 | gb.readByte();\n                }\n            }\n\n            if (gb.readBool()) {  // overscan_info_present_flag\n                gb.readBool();  // overscan_appropriate_flag\n            }\n            if (gb.readBool()) {  // video_signal_type_present_flag\n                gb.readBits(4);  // video_format & video_full_range_flag\n                if (gb.readBool()) {  // colour_description_present_flag\n                    gb.readBits(24);  // colour_primaries & transfer_characteristics & matrix_coefficients\n                }\n            }\n            if (gb.readBool()) {  // chroma_loc_info_present_flag\n                gb.readUEG();  // chroma_sample_loc_type_top_field\n                gb.readUEG();  // chroma_sample_loc_type_bottom_field\n            }\n            if (gb.readBool()) {  // timing_info_present_flag\n                let num_units_in_tick = gb.readBits(32);\n                let time_scale = gb.readBits(32);\n                fps_fixed = gb.readBool();  // fixed_frame_rate_flag\n\n                fps_num = time_scale;\n                fps_den = num_units_in_tick * 2;\n                fps = fps_num / fps_den;\n            }\n        }\n\n        let sarScale = 1;\n        if (sar_width !== 1 || sar_height !== 1) {\n            sarScale = sar_width / sar_height;\n        }\n\n        let crop_unit_x = 0, crop_unit_y = 0;\n        if (chroma_format_idc === 0) {\n            crop_unit_x = 1;\n            crop_unit_y = 2 - frame_mbs_only_flag;\n        } else {\n            let sub_wc = (chroma_format_idc === 3) ? 1 : 2;\n            let sub_hc = (chroma_format_idc === 1) ? 2 : 1;\n            crop_unit_x = sub_wc;\n            crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n        }\n\n        let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n        let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n        let present_width = Math.ceil(codec_width * sarScale);\n\n        gb.destroy();\n        gb = null;\n\n        return {\n            profile_string: profile_string,  // baseline, high, high10, ...\n            level_string: level_string,  // 3, 3.1, 4, 4.1, 5, 5.1, ...\n            bit_depth: bit_depth,  // 8bit, 10bit, ...\n            ref_frames: ref_frames,\n            chroma_format: chroma_format,  // 4:2:0, 4:2:2, ...\n            chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n            frame_rate: {\n                fixed: fps_fixed,\n                fps: fps,\n                fps_den: fps_den,\n                fps_num: fps_num\n            },\n\n            sar_ratio: {\n                width: sar_width,\n                height: sar_height\n            },\n\n            codec_size: {\n                width: codec_width,\n                height: codec_height\n            },\n\n            present_size: {\n                width: present_width,\n                height: codec_height\n            }\n        };\n    }\n\n    static _skipScalingList(gb, count) {\n        let last_scale = 8, next_scale = 8;\n        let delta_scale = 0;\n        for (let i = 0; i < count; i++) {\n            if (next_scale !== 0) {\n                delta_scale = gb.readSEG();\n                next_scale = (last_scale + delta_scale + 256) % 256;\n            }\n            last_scale = (next_scale === 0) ? last_scale : next_scale;\n        }\n    }\n\n    static getProfileString(profile_idc) {\n        switch (profile_idc) {\n            case 66:\n                return 'Baseline';\n            case 77:\n                return 'Main';\n            case 88:\n                return 'Extended';\n            case 100:\n                return 'High';\n            case 110:\n                return 'High10';\n            case 122:\n                return 'High422';\n            case 244:\n                return 'High444';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getLevelString(level_idc) {\n        return (level_idc / 10).toFixed(1);\n    }\n\n    static getChromaFormatString(chroma) {\n        switch (chroma) {\n            case 420:\n                return '4:2:0';\n            case 422:\n                return '4:2:2';\n            case 444:\n                return '4:4:4';\n            default:\n                return 'Unknown';\n        }\n    }\n\n}\n\nexport default SPSParser;\n","import {IllegalStateException} from \"../utils/exception\";\nimport MediaInfo from \"../formats/media-info\";\nimport AMF from \"../flv/amf-parser\";\nimport {Log} from \"../utils/logger\";\nimport {DemuxErrors} from \"../utils/utils\";\nimport SPSParser from \"../flv/sps-parser\";\n\nclass RTMPMediaMessageHandler{\n    TAG = \"RTMPMediaMessageHandler\";\n\n    constructor(probeData, config) {\n        this._config = config;\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onMetaDataArrived = null;\n        this._onScriptDataArrived = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n\n        this._dispatch = false;\n\n        this._hasAudio = true;\n        this._hasVideo = true;\n\n        this._hasAudioFlagOverrided = false;\n        this._hasVideoFlagOverrided = false;\n\n        this._audioInitialMetadataDispatched = false;\n        this._videoInitialMetadataDispatched = false;\n\n        this._mediaInfo = new MediaInfo();\n        this._mediaInfo.hasAudio = this._hasAudio;\n        this._mediaInfo.hasVideo = this._hasVideo;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n\n        this._naluLengthSize = 4;\n        this._timestampBase = 0;  // int32, in milliseconds\n        this._timescale = 1000;\n        this._duration = 0;  // int32, in milliseconds\n        this._durationOverrided = false;\n        this._referenceFrameRate = {\n            fixed: true,\n            fps: 23.976,\n            fps_num: 23976,\n            fps_den: 1000\n        };\n\n        this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\n\n        this._mpegSamplingRates = [\n            96000, 88200, 64000, 48000, 44100, 32000,\n            24000, 22050, 16000, 12000, 11025, 8000, 7350\n        ];\n\n        this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\n        this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\n        this._mpegAudioV25SampleRateTable = [11025, 12000, 8000,  0];\n\n        this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\n        this._mpegAudioL2BitRateTable = [0, 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\n        this._mpegAudioL3BitRateTable = [0, 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, -1];\n\n        this._videoTrack = {type: 'video', id: 1, sequenceNumber: 0, samples: [], length: 0};\n        this._audioTrack = {type: 'audio', id: 2, sequenceNumber: 0, samples: [], length: 0};\n\n        this._littleEndian = (function () {\n            let buf = new ArrayBuffer(2);\n            (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\n            return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\n        })();\n    }\n\n    destroy() {\n        this._mediaInfo = null;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n        this._videoTrack = null;\n        this._audioTrack = null;\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onMetaDataArrived = null;\n        this._onScriptDataArrived = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n    }\n\n    // prototype: function(type: string, metadata: any): void\n    get onTrackMetadata() {\n        return this._onTrackMetadata;\n    }\n\n    set onTrackMetadata(callback) {\n        this._onTrackMetadata = callback;\n    }\n\n    // prototype: function(mediaInfo: MediaInfo): void\n    get onMediaInfo() {\n        return this._onMediaInfo;\n    }\n\n    set onMediaInfo(callback) {\n        this._onMediaInfo = callback;\n    }\n\n    get onMetaDataArrived() {\n        return this._onMetaDataArrived;\n    }\n\n    set onMetaDataArrived(callback) {\n        this._onMetaDataArrived = callback;\n    }\n\n    get onScriptDataArrived() {\n        return this._onScriptDataArrived;\n    }\n\n    set onScriptDataArrived(callback) {\n        this._onScriptDataArrived = callback;\n    }\n\n    // prototype: function(type: number, info: string): void\n    get onError() {\n        return this._onError;\n    }\n\n    set onError(callback) {\n        this._onError = callback;\n    }\n\n    // prototype: function(videoTrack: any, audioTrack: any): void\n    get onDataAvailable() {\n        return this._onDataAvailable;\n    }\n\n    set onDataAvailable(callback) {\n        this._onDataAvailable = callback;\n    }\n\n    // timestamp base for output samples, must be in milliseconds\n    get timestampBase() {\n        return this._timestampBase;\n    }\n\n    set timestampBase(base) {\n        this._timestampBase = base;\n    }\n\n    get overridedDuration() {\n        return this._duration;\n    }\n\n    // Force-override media duration. Must be in milliseconds, int32\n    set overridedDuration(duration) {\n        this._durationOverrided = true;\n        this._duration = duration;\n        this._mediaInfo.duration = duration;\n    }\n\n    // Force-override audio track present flag, boolean\n    set overridedHasAudio(hasAudio) {\n        this._hasAudioFlagOverrided = true;\n        this._hasAudio = hasAudio;\n        this._mediaInfo.hasAudio = hasAudio;\n    }\n\n    // Force-override video track present flag, boolean\n    set overridedHasVideo(hasVideo) {\n        this._hasVideoFlagOverrided = true;\n        this._hasVideo = hasVideo;\n        this._mediaInfo.hasVideo = hasVideo;\n    }\n\n    resetMediaInfo() {\n        this._mediaInfo = new MediaInfo();\n    }\n\n    _isInitialMetadataDispatched() {\n        if (this._hasAudio && this._hasVideo) {  // both audio & video\n            return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n        }\n        if (this._hasAudio && !this._hasVideo) {  // audio only\n            return this._audioInitialMetadataDispatched;\n        }\n        if (!this._hasAudio && this._hasVideo) {  // video only\n            return this._videoInitialMetadataDispatched;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @param {RTMPMessage} msg\n     */\n    handleMediaMessage(msg) {\n        if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\n            throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\n        }\n\n        this._dispatch = true;\n\n        let tagType = msg.getMessageType();\n        let timestamp = msg.getTimestamp();\n        let streamId = msg.getMessageStreamID()\n        if (streamId !== 0) {\n            Log.w(this.TAG, 'Meet tag which has StreamID != 0!');\n        }\n\n        switch (tagType) {\n            case 8:  // Audio\n                this._parseAudioData(msg.getPayload(), timestamp);\n                break;\n            case 9:  // Video\n                this._parseVideoData(msg.getPayload(), timestamp, 0);\n                break;\n            case 18:  // ScriptDataObject\n                this._parseScriptData(msg.getPayload());\n                break;\n        }\n\n        // dispatch parsed frames to consumer (typically, the remuxer)\n        if (this._isInitialMetadataDispatched()) {\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        }\n\n        return;\n    }\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     * @private\n     */\n    _parseScriptData(payload) {\n        let scriptData = AMF.parseScriptData(payload);\n\n        if (scriptData.hasOwnProperty('onMetaData')) {\n            if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\n                Log.w(this.TAG, 'Invalid onMetaData structure!');\n                return;\n            }\n            if (this._metadata) {\n                Log.w(this.TAG, 'Found another onMetaData tag!');\n            }\n            this._metadata = scriptData;\n            let onMetaData = this._metadata.onMetaData;\n\n            if (this._onMetaDataArrived) {\n                this._onMetaDataArrived(Object.assign({}, onMetaData));\n            }\n\n            if (typeof onMetaData.hasAudio === 'boolean') {  // hasAudio\n                if (this._hasAudioFlagOverrided === false) {\n                    this._hasAudio = onMetaData.hasAudio;\n                    this._mediaInfo.hasAudio = this._hasAudio;\n                }\n            }\n            if (typeof onMetaData.hasVideo === 'boolean') {  // hasVideo\n                if (this._hasVideoFlagOverrided === false) {\n                    this._hasVideo = onMetaData.hasVideo;\n                    this._mediaInfo.hasVideo = this._hasVideo;\n                }\n            }\n            if (typeof onMetaData.audiodatarate === 'number') {  // audiodatarate\n                this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n            }\n            if (typeof onMetaData.videodatarate === 'number') {  // videodatarate\n                this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n            }\n            if (typeof onMetaData.width === 'number') {  // width\n                this._mediaInfo.width = onMetaData.width;\n            }\n            if (typeof onMetaData.height === 'number') {  // height\n                this._mediaInfo.height = onMetaData.height;\n            }\n            if (typeof onMetaData.duration === 'number') {  // duration\n                if (!this._durationOverrided) {\n                    let duration = Math.floor(onMetaData.duration * this._timescale);\n                    this._duration = duration;\n                    this._mediaInfo.duration = duration;\n                }\n            } else {\n                this._mediaInfo.duration = 0;\n            }\n            if (typeof onMetaData.framerate === 'number') {  // framerate\n                let fps_num = Math.floor(onMetaData.framerate * 1000);\n                if (fps_num > 0) {\n                    let fps = fps_num / 1000;\n                    this._referenceFrameRate.fixed = true;\n                    this._referenceFrameRate.fps = fps;\n                    this._referenceFrameRate.fps_num = fps_num;\n                    this._referenceFrameRate.fps_den = 1000;\n                    this._mediaInfo.fps = fps;\n                }\n            }\n            if (typeof onMetaData.keyframes === 'object') {  // keyframes\n                this._mediaInfo.hasKeyframesIndex = true;\n                let keyframes = onMetaData.keyframes;\n                this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n                onMetaData.keyframes = null;  // keyframes has been extracted, remove it\n            } else {\n                this._mediaInfo.hasKeyframesIndex = false;\n            }\n            this._dispatch = false;\n            this._mediaInfo.metadata = onMetaData;\n            Log.v(this.TAG, 'Parsed onMetaData');\n            if (this._mediaInfo.isComplete()) {\n                this._onMediaInfo(this._mediaInfo);\n            }\n        }\n\n        if (Object.keys(scriptData).length > 0) {\n            if (this._onScriptDataArrived) {\n                this._onScriptDataArrived(Object.assign({}, scriptData));\n            }\n        }\n    }\n\n    _parseKeyframesIndex(keyframes) {\n        let times = [];\n        let filepositions = [];\n\n        // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n        for (let i = 1; i < keyframes.times.length; i++) {\n            let time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n            times.push(time);\n            filepositions.push(keyframes.filepositions[i]);\n        }\n\n        return {\n            times: times,\n            filepositions: filepositions\n        };\n    }\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     * @param tagTimestamp\n     * @private\n     */\n    _parseAudioData(payload, tagTimestamp) {\n        if (payload.length <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n            return;\n        }\n\n        if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\n            // If hasAudio: false indicated explicitly in MediaDataSource,\n            // Ignore all the audio packets\n            return;\n        }\n\n        let le = this._littleEndian;\n        let v = new DataView(payload.buffer);\n\n        let soundSpec = v.getUint8(0);\n\n        let soundFormat = soundSpec >>> 4;\n        if (soundFormat !== 2 && soundFormat !== 10) {  // MP3 or AAC\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n            return;\n        }\n\n        let soundRate = 0;\n        let soundRateIndex = (soundSpec & 12) >>> 2;\n        if (soundRateIndex >= 0 && soundRateIndex <= 4) {\n            soundRate = this._flvSoundRateTable[soundRateIndex];\n        } else {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n            return;\n        }\n\n        let soundSize = (soundSpec & 2) >>> 1;  // unused\n        let soundType = (soundSpec & 1);\n\n\n        let meta = this._audioMetadata;\n        let track = this._audioTrack;\n\n        if (!meta) {\n            if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\n                this._hasAudio = true;\n                this._mediaInfo.hasAudio = true;\n            }\n\n            // initial metadata\n            meta = this._audioMetadata = {};\n            meta.type = 'audio';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n            meta.audioSampleRate = soundRate;\n            meta.channelCount = (soundType === 0 ? 1 : 2);\n        }\n\n        if (soundFormat === 10) {  // AAC\n            let aacData = this._parseAACAudioData(payload.slice(1));\n            if (aacData == undefined) {\n                return;\n            }\n\n            if (aacData.packetType === 0) {  // AAC sequence header (AudioSpecificConfig)\n                if (meta.config) {\n                    Log.w(this.TAG, 'Found another AudioSpecificConfig!');\n                }\n                let misc = aacData.data;\n                meta.audioSampleRate = misc.samplingRate;\n                meta.channelCount = misc.channelCount;\n                meta.codec = misc.codec;\n                meta.originalCodec = misc.originalCodec;\n                meta.config = misc.config;\n                // The decode result of an aac sample is 1024 PCM samples\n                meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\n                Log.v(this.TAG, 'Parsed AudioSpecificConfig');\n\n                if (this._isInitialMetadataDispatched()) {\n                    // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n                    if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                        this._onDataAvailable(this._audioTrack, this._videoTrack);\n                    }\n                } else {\n                    this._audioInitialMetadataDispatched = true;\n                }\n                // then notify new metadata\n                this._dispatch = false;\n                this._onTrackMetadata('audio', meta);\n\n                let mi = this._mediaInfo;\n                mi.audioCodec = meta.originalCodec;\n                mi.audioSampleRate = meta.audioSampleRate;\n                mi.audioChannelCount = meta.channelCount;\n                if (mi.hasVideo) {\n                    if (mi.videoCodec != null) {\n                        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                    }\n                } else {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n                }\n                if (mi.isComplete()) {\n                    this._onMediaInfo(mi);\n                }\n            } else if (aacData.packetType === 1) {  // AAC raw frame data\n                let dts = this._timestampBase + tagTimestamp;\n                let aacSample = {unit: aacData.data, length: aacData.data.byteLength, dts: dts, pts: dts};\n                track.samples.push(aacSample);\n                track.length += aacData.data.length;\n            } else {\n                Log.e(this.TAG, `Flv: Unsupported AAC data type ${aacData.packetType}`);\n            }\n        } else if (soundFormat === 2) {  // MP3\n            if (!meta.codec) {\n                // We need metadata for mp3 audio track, extract info from frame header\n                let misc = this._parseMP3AudioData(payload.slice(1), true);\n                if (misc == undefined) {\n                    return;\n                }\n                meta.audioSampleRate = misc.samplingRate;\n                meta.channelCount = misc.channelCount;\n                meta.codec = misc.codec;\n                meta.originalCodec = misc.originalCodec;\n                // The decode result of an mp3 sample is 1152 PCM samples\n                meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\n                Log.v(this.TAG, 'Parsed MPEG Audio Frame Header');\n\n                this._audioInitialMetadataDispatched = true;\n                this._onTrackMetadata('audio', meta);\n\n                let mi = this._mediaInfo;\n                mi.audioCodec = meta.codec;\n                mi.audioSampleRate = meta.audioSampleRate;\n                mi.audioChannelCount = meta.channelCount;\n                mi.audioDataRate = misc.bitRate;\n                if (mi.hasVideo) {\n                    if (mi.videoCodec != null) {\n                        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                    }\n                } else {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n                }\n                if (mi.isComplete()) {\n                    this._onMediaInfo(mi);\n                }\n            }\n\n            // This packet is always a valid audio packet, extract it\n            let data = this._parseMP3AudioData(payload.slice(1), false);\n            if (data == undefined) {\n                return;\n            }\n            let dts = this._timestampBase + tagTimestamp;\n            let mp3Sample = {unit: data, length: data.byteLength, dts: dts, pts: dts};\n            track.samples.push(mp3Sample);\n            track.length += data.length;\n        }\n    }\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     * @returns {{}}\n     * @private\n     */\n    _parseAACAudioData(payload) {\n        if (payload.length <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n            return;\n        }\n\n        let result = {};\n\n        result.packetType = payload[0];\n\n        if (payload[0] === 0) {\n            result.data = this._parseAACAudioSpecificConfig(payload.slice(1));\n        } else {\n            result.data = payload.subarray(1);\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {Uint8Array} array\n     * @returns {{channelCount: number, codec: string, originalCodec: string, samplingRate: *, config: any[]}}\n     * @private\n     */\n    _parseAACAudioSpecificConfig(array) {\n        let config = null;\n\n        /* Audio Object Type:\n           0: Null\n           1: AAC Main\n           2: AAC LC\n           3: AAC SSR (Scalable Sample Rate)\n           4: AAC LTP (Long Term Prediction)\n           5: HE-AAC / SBR (Spectral Band Replication)\n           6: AAC Scalable\n        */\n\n        let audioObjectType = 0;\n        let originalAudioObjectType = 0;\n        let audioExtensionObjectType = null;\n        let samplingIndex = 0;\n        let extensionSamplingIndex = null;\n\n        // 5 bits\n        audioObjectType = originalAudioObjectType = array[0] >>> 3;\n        // 4 bits\n        samplingIndex = ((array[0] & 0x07) << 1) | (array[1] >>> 7);\n        if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n            return;\n        }\n\n        let samplingFrequence = this._mpegSamplingRates[samplingIndex];\n\n        // 4 bits\n        let channelConfig = (array[1] & 0x78) >>> 3;\n        if (channelConfig < 0 || channelConfig >= 8) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n            return;\n        }\n\n        if (audioObjectType === 5) {  // HE-AAC?\n            // 4 bits\n            extensionSamplingIndex = ((array[1] & 0x07) << 1) | (array[2] >>> 7);\n            // 5 bits\n            audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n        }\n\n        // workarounds for various browsers\n        let userAgent = self.navigator.userAgent.toLowerCase();\n\n        if (userAgent.indexOf('firefox') !== -1) {\n            // firefox: use SBR (HE-AAC) if freq less than 24kHz\n            if (samplingIndex >= 6) {\n                audioObjectType = 5;\n                config = new Array(4);\n                extensionSamplingIndex = samplingIndex - 3;\n            } else {  // use LC-AAC\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        } else if (userAgent.indexOf('android') !== -1) {\n            // android: always use LC-AAC\n            audioObjectType = 2;\n            config = new Array(2);\n            extensionSamplingIndex = samplingIndex;\n        } else {\n            // for other browsers, e.g. chrome...\n            // Always use HE-AAC to make it easier to switch aac codec profile\n            audioObjectType = 5;\n            extensionSamplingIndex = samplingIndex;\n            config = new Array(4);\n\n            if (samplingIndex >= 6) {\n                extensionSamplingIndex = samplingIndex - 3;\n            } else if (channelConfig === 1) {  // Mono channel\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        }\n\n        config[0]  = audioObjectType << 3;\n        config[0] |= (samplingIndex & 0x0F) >>> 1;\n        config[1]  = (samplingIndex & 0x0F) << 7;\n        config[1] |= (channelConfig & 0x0F) << 3;\n        if (audioObjectType === 5) {\n            config[1] |= ((extensionSamplingIndex & 0x0F) >>> 1);\n            config[2]  = (extensionSamplingIndex & 0x01) << 7;\n            // extended audio object type: force to 2 (LC-AAC)\n            config[2] |= (2 << 2);\n            config[3]  = 0;\n        }\n\n        return {\n            config: config,\n            samplingRate: samplingFrequence,\n            channelCount: channelConfig,\n            codec: 'mp4a.40.' + audioObjectType,\n            originalCodec: 'mp4a.40.' + originalAudioObjectType\n        };\n    }\n\n    /**\n     *\n     * @param {Uint8Array} array\n     * @param requestHeader\n     * @returns {*}\n     * @private\n     */\n    _parseMP3AudioData(array, requestHeader) {\n        if (array.length < 4) {\n            Log.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\n            return;\n        }\n\n        let result = null;\n\n        if (requestHeader) {\n            if (array[0] !== 0xFF) {\n                return;\n            }\n            let ver = (array[1] >>> 3) & 0x03;\n            let layer = (array[1] & 0x06) >> 1;\n\n            let bitrate_index = (array[2] & 0xF0) >>> 4;\n            let sampling_freq_index = (array[2] & 0x0C) >>> 2;\n\n            let channel_mode = (array[3] >>> 6) & 0x03;\n            let channel_count = channel_mode !== 3 ? 2 : 1;\n\n            let sample_rate = 0;\n            let bit_rate = 0;\n            let object_type = 34;  // Layer-3, listed in MPEG-4 Audio Object Types\n\n            let codec = 'mp3';\n\n            switch (ver) {\n                case 0:  // MPEG 2.5\n                    sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\n                    break;\n                case 2:  // MPEG 2\n                    sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\n                    break;\n                case 3:  // MPEG 1\n                    sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\n                    break;\n            }\n\n            switch (layer) {\n                case 1:  // Layer 3\n                    object_type = 34;\n                    if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\n                        bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\n                    }\n                    break;\n                case 2:  // Layer 2\n                    object_type = 33;\n                    if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\n                        bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\n                    }\n                    break;\n                case 3:  // Layer 1\n                    object_type = 32;\n                    if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\n                        bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\n                    }\n                    break;\n            }\n\n            result = {\n                bitRate: bit_rate,\n                samplingRate: sample_rate,\n                channelCount: channel_count,\n                codec: codec,\n                originalCodec: codec\n            };\n        } else {\n            result = array;\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     * @param tagTimestamp\n     * @param tagPosition\n     * @private\n     */\n    _parseVideoData(payload, tagTimestamp, tagPosition) {\n        if (payload.length <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n            return;\n        }\n\n        if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\n            // If hasVideo: false indicated explicitly in MediaDataSource,\n            // Ignore all the video packets\n            return;\n        }\n\n        let spec = payload[0];\n\n        let frameType = (spec & 240) >>> 4;\n        let codecId = spec & 15;\n\n        if (codecId !== 7) {\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, `Flv: Unsupported codec in video frame: ${codecId}`);\n            return;\n        }\n\n        this._parseAVCVideoPacket(payload.slice(1), tagTimestamp, tagPosition, frameType);\n    }\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     * @param tagTimestamp\n     * @param tagPosition\n     * @param frameType\n     * @private\n     */\n    _parseAVCVideoPacket(payload, tagTimestamp, tagPosition, frameType) {\n        if (payload.length < 4) {\n            Log.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n            return;\n        }\n\n        let le = this._littleEndian;\n        let v = new DataView(payload.buffer);\n\n        let packetType = v.getUint8(0);\n        let cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\n        let cts = (cts_unsigned << 8) >> 8;  // convert to 24-bit signed int\n\n        if (packetType === 0) {  // AVCDecoderConfigurationRecord\n            this._parseAVCDecoderConfigurationRecord(payload.slice(4));\n        } else if (packetType === 1) {  // One or more Nalus\n            this._parseAVCVideoData(payload.slice(4), tagTimestamp, tagPosition, frameType, cts);\n        } else if (packetType === 2) {\n            // empty, AVC end of sequence\n        } else {\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid video packet type ${packetType}`);\n            return;\n        }\n    }\n\n    /**\n     *\n     * @param {Uint8Array} payload\n     * @private\n     */\n    _parseAVCDecoderConfigurationRecord(payload) {\n        if (payload.length < 7) {\n            Log.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n            return;\n        }\n\n        let meta = this._videoMetadata;\n        let track = this._videoTrack;\n        let le = this._littleEndian;\n        let v = new DataView(payload.buffer);\n\n        if (!meta) {\n            if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\n                this._hasVideo = true;\n                this._mediaInfo.hasVideo = true;\n            }\n\n            meta = this._videoMetadata = {};\n            meta.type = 'video';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n\n        } else {\n            if (typeof meta.avcc !== 'undefined') {\n                Log.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n            }\n        }\n\n        let version = v.getUint8(0);  // configurationVersion\n        let avcProfile = v.getUint8(1);  // avcProfileIndication\n        let profileCompatibility = v.getUint8(2);  // profile_compatibility\n        let avcLevel = v.getUint8(3);  // AVCLevelIndication\n\n        if (version !== 1 || avcProfile === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n            return;\n        }\n\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1;  // lengthSizeMinusOne\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {  // holy shit!!!\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`);\n            return;\n        }\n\n        let spsCount = v.getUint8(5) & 31;  // numOfSequenceParameterSets\n        if (spsCount === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\n            return;\n        } else if (spsCount > 1) {\n            Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: SPS Count = ${spsCount}`);\n        }\n\n        let offset = 6;\n\n        for (let i = 0; i < spsCount; i++) {\n            let len = v.getUint16(offset, !le);  // sequenceParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // Notice: Nalu without startcode header (00 00 00 01)\n            let sps = new Uint8Array(payload.slice(offset, offset + len));\n            offset += len;\n\n            let config = SPSParser.parseSPS(sps);\n            if (i !== 0) {\n                // ignore other sps's config\n                continue;\n            }\n\n            meta.codecWidth = config.codec_size.width;\n            meta.codecHeight = config.codec_size.height;\n            meta.presentWidth = config.present_size.width;\n            meta.presentHeight = config.present_size.height;\n\n            meta.profile = config.profile_string;\n            meta.level = config.level_string;\n            meta.bitDepth = config.bit_depth;\n            meta.chromaFormat = config.chroma_format;\n            meta.sarRatio = config.sar_ratio;\n            meta.frameRate = config.frame_rate;\n\n            if (config.frame_rate.fixed === false ||\n                config.frame_rate.fps_num === 0 ||\n                config.frame_rate.fps_den === 0) {\n                meta.frameRate = this._referenceFrameRate;\n            }\n\n            let fps_den = meta.frameRate.fps_den;\n            let fps_num = meta.frameRate.fps_num;\n            meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\n\n            let codecArray = sps.subarray(1, 4);\n            let codecString = 'avc1.';\n            for (let j = 0; j < 3; j++) {\n                let h = codecArray[j].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                codecString += h;\n            }\n            meta.codec = codecString;\n\n            let mi = this._mediaInfo;\n            mi.width = meta.codecWidth;\n            mi.height = meta.codecHeight;\n            mi.fps = meta.frameRate.fps;\n            mi.profile = meta.profile;\n            mi.level = meta.level;\n            mi.refFrames = config.ref_frames;\n            mi.chromaFormat = config.chroma_format_string;\n            mi.sarNum = meta.sarRatio.width;\n            mi.sarDen = meta.sarRatio.height;\n            mi.videoCodec = codecString;\n\n            if (mi.hasAudio) {\n                if (mi.audioCodec != null) {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                }\n            } else {\n                mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n            }\n            if (mi.isComplete()) {\n                this._onMediaInfo(mi);\n            }\n        }\n\n        let ppsCount = v.getUint8(offset);  // numOfPictureParameterSets\n        if (ppsCount === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\n            return;\n        } else if (ppsCount > 1) {\n            Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: PPS Count = ${ppsCount}`);\n        }\n\n        offset++;\n\n        for (let i = 0; i < ppsCount; i++) {\n            let len = v.getUint16(offset, !le);  // pictureParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // pps is useless for extracting video information\n            offset += len;\n        }\n\n        meta.avcc = new Uint8Array(payload.length);\n        meta.avcc.set(new Uint8Array(payload), 0);\n        Log.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n        if (this._isInitialMetadataDispatched()) {\n            // flush parsed frames\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        } else {\n            this._videoInitialMetadataDispatched = true;\n        }\n        // notify new metadata\n        this._dispatch = false;\n        this._onTrackMetadata('video', meta);\n    }\n\n    _parseAVCVideoData(payload, tagTimestamp, tagPosition, frameType, cts) {\n        let le = this._littleEndian;\n        let v = new DataView(payload.buffer);\n\n        let units = [], length = 0;\n\n        let dataSize = payload.length;\n\n        let offset = 0;\n        const lengthSize = this._naluLengthSize;\n        let dts = this._timestampBase + tagTimestamp;\n        let keyframe = (frameType === 1);  // from FLV Frame Type constants\n\n        while (offset < dataSize) {\n            if (offset + 4 >= dataSize) {\n                Log.w(this.TAG, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n                break;  // data not enough for next Nalu\n            }\n            // Nalu with length-header (AVC1)\n            let naluSize = v.getUint32(offset, !le);  // Big-Endian read\n            if (lengthSize === 3) {\n                naluSize >>>= 8;\n            }\n            if (naluSize > dataSize - lengthSize) {\n                Log.w(this.TAG, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n                return;\n            }\n\n            let unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n            if (unitType === 5) {  // IDR\n                keyframe = true;\n            }\n\n            let data = new Uint8Array(payload.slice(offset, offset + lengthSize + naluSize));\n            let unit = {type: unitType, data: data};\n            units.push(unit);\n            length += data.byteLength;\n\n            offset += lengthSize + naluSize;\n        }\n\n        if (units.length) {\n            let track = this._videoTrack;\n            let avcSample = {\n                units: units,\n                length: length,\n                isKeyframe: keyframe,\n                dts: dts,\n                cts: cts,\n                pts: (dts + cts)\n            };\n            if (keyframe) {\n                avcSample.fileposition = tagPosition;\n            }\n            track.samples.push(avcSample);\n            track.length += length;\n        }\n    }\n}\n\nexport default RTMPMediaMessageHandler;\n","import {_byteArrayToNumber, _byteArrayToString, _numberToByteArray, _stringToByteArray} from \"../utils/utils\";\n\nclass AMF0Object {\n\tcommand;\n\ttransaction_id;\n\tcommand_object;\n    additionalInfo;\n\n\tdata;\n\n    params;\n\n\tconstructor(params) {\n\t\tif(params) {\n            this.params = params;\n\t\t\tconsole.log(\"cmd: \" + this.params[0]);\n\t\t}\n\t}\n\n    /**\n     *\n     * @param {Uint8Array} data\n     * @returns {*[]}\n     */\n\tparseAMF0(data) {\n\t\tthis.data = Array.from(data);\n\t\tlet obj = [];\n\n\t\twhile (this.data.length > 0) {\n\t\t\tconst var_type = this.data.shift();\n\n\t\t\tswitch(var_type) {\n\t\t\tcase 0x00: // Number\n\t\t\t\tobj.push(_byteArrayToNumber(this.data.slice(0, 8)));\n\t\t\t\tthis.data = this.data.slice(8);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x01: // boolean\n\t\t\t\tif (this.data.shift() === 0) {\n\t\t\t\t\tobj.push(false);\n\t\t\t\t} else {\n\t\t\t\t\tobj.push(true);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x02: // String\n\t\t\t\tlet len = (this.data[0] << 8) | (this.data[1]);\n\t\t\t\tthis.data = this.data.slice(2);\n\n\t\t\t\tobj.push(_byteArrayToString(this.data.slice(0, len)));\n\t\t\t\tthis.data = this.data.slice(len);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x03: // AMF encoded object\n\t\t\t\tobj.push(this._parseAMF0Object());\n\t\t\t\tbreak;\n\n\t\t\tcase 0x05: // NUll\n                obj.push(null);\n\t\t\t\tbreak;\n\n            default:\n                console.warn(\"var_type: \" + var_type + \" not yet implemented\");\n                break;\n\t\t\t}\n\t\t}\n        this.params = obj;\n\t\treturn obj;\n\t}\n\n\t_parseAMF0Object() {\n\t\tlet o2 = {};\n\n\t\t//console.log(\"parseObject: \" + this.data.length);\n\n\t\twhile (this.data.length > 0) {\n\t\t\tlet keylen = (this.data[0] << 8) | (this.data[1]); this.data = this.data.slice(2);\n\n\t\t\t// Object end marker\n\t\t\tif (keylen === 0 && this.data[0] === 9) {\n\t\t\t\t//console.log(\"endmarker found\");\n\t\t\t\tthis.data = this.data.slice(1);\n\t\t\t\treturn o2;\n\t\t\t}\n\n\t\t\tlet keyName = _byteArrayToString(this.data.slice(0, keylen)); this.data = this.data.slice(keylen);\n\n\t\t\t//console.log(\"key found: \" + keyName);\n\n\t\t\tconst var_type = this.data.shift();\n\n\t\t\tswitch(var_type) {\n            case 0x00: // Number\n                o2[keyName] = _byteArrayToNumber(this.data.slice(0, 8));\n                this.data = this.data.slice(8);\n                break;\n\n            case 0x01: // boolean\n                if (this.data.shift() === 0) {\n                    o2[keyName] = false;\n                } else {\n                    o2[keyName] = true;\n                }\n\n                break;\n\n            case 0x02: // String\n                let len = (this.data[0] << 8) | (this.data[1]);\n                this.data = this.data.slice(2);\n\n                o2[keyName] = _byteArrayToString(this.data.slice(0, len));\n                this.data = this.data.slice(len);\n                break;\n\n            case 0x05:\n                o2[keyName] = null;\n                break;\n\n            default:\n                console.warn(\"var_type: \" + var_type + \" not yet implemented\");\n                break;\n\t\t\t}\n\t\t}\n\n\t\treturn o2;\n\t}\n\n    /**\n     *\n     * @returns {Uint8Array}\n     */\n\tgetBytes() {\n\t\tlet bytes = [];\n\n        for(let i = 0; i < this.params.length; i++) {\n            const param = this.params[i];\n\n            //console.log(\"Param\", i, typeof param);\n\n            switch(typeof param){\n            case \"string\":\n                // Command\n                bytes.push(0x02); // String\n                bytes.push(param.length >>> 8);\n                bytes.push(param.length);\n                bytes = bytes.concat(_stringToByteArray(param));\n                break;\n\n            case \"number\":\n                // TransactionID\n                bytes.push(0x00); // Number\n                bytes = bytes.concat(_numberToByteArray(param));\n                break;\n\n            case \"object\":\n                // Command Object\n                bytes.push(0x03); // Object\n\n                for (let key in param) {\n                    //console.log(\"param: \" + key);\n\n                    let value = param[key];\n                    let keylength = key.length;\n\n                    bytes.push(keylength >>> 8);\n                    bytes.push(keylength);\n                    bytes = bytes.concat(_stringToByteArray(key));\n\n                    switch(typeof value) {\n                    case \"object\":\n                        if (value == null) {\n                            bytes.push(0x05); // Null\n                        }\n\n                        break;\n\n                    case \"string\":\n                        const length = value.length;\n                        bytes.push(0x02);\n                        bytes.push(length >>> 8);\n                        bytes.push(length);\n                        bytes = bytes.concat(_stringToByteArray(value))\n                        break;\n\n                    case \"number\":\n                        bytes.push(0x00);\n                        bytes = bytes.concat(_numberToByteArray(value))\n                        break;\n\n                    case \"boolean\":\n                        bytes.push(0x01);\n                        if (value) bytes.push(0x01);\n                        else bytes.push(0x00);\n                        break;\n\n                    default:\n                        console.warn(typeof value, \" not yet implementd\");\n                        break;\n                    }\n                }\n\n                bytes.push(0x00); // End Marker\n                bytes.push(0x00);\n                bytes.push(0x09);\n                break;\n\n            case \"boolean\":\n                bytes.push(0x01);\n                if(param) bytes.push(0x01);\n                else bytes.push(0x00);\n                break;\n\n            default:\n                console.warn(typeof param, \" not yet implementd\");\n                break;\n            }\n        }\n\n\t\treturn new Uint8Array(bytes);\n\t}\n\n    getCommand(){\n        return this.command;\n    }\n\n    getTransactionId(){\n        return this.transaction_id;\n    }\n\n    getCommandObject(){\n        return this.command_object;\n    }\n\n    getAdditionalInfo(){\n        return this.additionalInfo;\n    }\n}\n\nexport default AMF0Object;\n\nconst test = [\n\t0x02, 0x00, 0x07,  0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, // 7 connect\n\t0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \t\t// Tid 1\n\t0x03, \t\t// object start\n\t0x00, 0x03,  0x61, 0x70, 0x70,  // key app 3\n\t0x02, 0x00, 0x08, 0x62, 0x75, 0x6e, 0x6b, 0x65, 0x72, 0x74, 0x76, // string bunkertv\n\t0x00, 0x08, 0x66, 0x6c, 0x61, 0x73, 0x68, 0x56, 0x65, 0x72,  // flashVer\n\t0x02, 0x00, 0x0d,  0x4c, 0x4e, 0x58, 0x20, 0x39, 0x2c, 0x30, 0x2c, 0x31, 0x32, 0x34, 0x2c, 0x32, //LNX\n\t0x00, 0x05, 0x74, 0x63, 0x55, 0x72, 0x6c,  // tcUrl...\n\n\t0x02, 0x00, 0x21,  0x72, 0x74, 0x6d, 0x70, 0x3a, 0x2f, 0x2f, 0x62, 0x75, 0x6e, 0x6b, 0x65,\n\t0x72, 0x74, 0x76, 0x2e, 0x6f, 0x72, 0x67, 0x3a, 0x31, 0x39, 0x33, 0x35, 0x2f, 0x62, 0x75, 0x6e,\n\t0x6b, 0x65, 0x72, 0x74, 0x76,\n\n\t0x00, 0x04, 0x66, 0x70, 0x61, 0x64, \t\t//fpad\n\t0x01, 0x00, \t\t\t\t\t// bool false\n\t0x00, 0x0c, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73,  //capabilities\n\t0x00, 0x40, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x0b, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x73, // audio..\n\t0x00, 0x40, 0xaf, 0xce, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x0b, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x73, //videocodecs\n\t0x00, 0x40, 0x6f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x0d, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, //videoFunction\n\t0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x09];","import RTMPMessage from \"./RTMPMessage\";\nimport Chunk from \"./Chunk\";\nimport UserControlMessage from \"./UserControlMessage\";\nimport NetConnection from \"./NetConnection\";\nimport ChunkParser from \"./ChunkParser\";\nimport RTMPMediaMessageHandler from \"./RTMPMediaMessageHandler\";\nimport AMF0Object from \"./AMF0Object\";\n\nclass RTMPMessageHandler {\n    netconnections = {};\n    chunk_stream_id = 2;\n    trackedCommand = \"\";\n    socket;\n\n    /**\n     *\n     * @param {WebSocket} socket\n     */\n    constructor(socket) {\n        this.socket = socket;\n        this.chunk_parser = new ChunkParser(this);\n        this.media_handler = new RTMPMediaMessageHandler();\n\n        this.media_handler.onError = (type, info)=>{\n            console.log(type, info);\n            postMessage([\"onError\", type, info]);\n        }\n\n        this.media_handler.onMediaInfo = (mediainfo)=>{\n            console.log(mediainfo);\n            postMessage([\"onMediaInfo\", mediainfo]);\n        }\n\n        this.media_handler.onTrackMetadata = (type, metadata)=>{\n            console.log(type, metadata);\n            postMessage([\"onTrackMetadata\", type, metadata]);\n        }\n\n        this.media_handler.onDataAvailable = (videoTrack, audioTrack)=>{\n            console.log(videoTrack, audioTrack);\n            postMessage([\"onDataAvailable\", videoTrack, audioTrack]);\n        }\n\n        this.media_handler.onMetaDataArrived = (metadata)=>{\n            postMessage([\"onMetaDataArrived\", metadata]);\n        }\n\n        this.media_handler.onScriptDataArrived= (data)=>{\n            postMessage([\"onScriptDataArrived\", data]);\n        }\n\n        this.media_handler.onScriptDataArrived= (data)=>{\n            postMessage([\"onMetaDataArrived\", data]);\n        }\n\n        this.media_handler.onScriptDataArrived= (data)=>{\n            postMessage([\"onMetaDataArrived\", data]);\n        }\n\n        this.media_handler.onScriptDataArrived= (data)=>{\n            postMessage([\"onMetaDataArrived\", data]);\n        }\n    }\n\n    /**\n     *\n     * @param {Uint8Array} data\n     */\n    parseChunk(data){\n        console.log(\"[ RTMPMessageHandler ] parseChunk: \" + data.length);\n        this.chunk_parser.parseChunk(data);\n    }\n\n    /**\n     *\n     * @param {RTMPMessage} msg\n     */\n    onMessage(msg){\n        console.log(\"[ RTMPMessageHandler ] onMessage: \" + msg.getMessageType() + \" StreamID:\" + msg.getMessageStreamID());\n\n        switch(msg.getMessageType()){\n        case 1:         // PCM Set Chunk Size\n        case 2:         // PCM Abort Message\n        case 3:         // PCM Acknowledgement\n        case 5:         // PCM Window Acknowledgement Size\n        case 6:         // PCM Set Peer Bandwidth\n            this.netconnections[msg.getMessageStreamID()].parseMessage(msg);\n            break;\n\n        case 4:          // User Control Messages\n            this._handleUserControlMessage(msg);\n            break;\n\n        case 8:         // Audio Message\n            console.log(\"[ RTMPMessageHandler ] AUDIOFRAME: \", msg.getPayload());\n            this.media_handler.handleMediaMessage(msg);\n            break;\n\n        case 9:         // Video Message\n            console.log(\"[ RTMPMessageHandler ] VIDEOFRAME: \", msg.getPayload());\n            this.media_handler.handleMediaMessage(msg);\n            break;\n\n        case 18:        // Data Message AMF0\n            console.log(\"[ RTMPMessageHandler ] DATAFRAME: \", msg.getPayload());\n            this.media_handler.handleMediaMessage(msg);\n            break;\n\n        case 19:        // Shared Object Message AMF0\n            //new SharedObjectMessage(msg.getPayload());\n            break;\n\n        case 20:        // Command Message AMF0\n            const command = new AMF0Object();\n            let cmd = command.parseAMF0(msg.getPayload());\n\n            console.log(\"[ RTMPMessageHandler ] AMF0\", cmd);\n\n            switch(cmd[0]) {\n            case \"_result\":\n                switch(this.trackedCommand){\n                case \"connect\":\n                    if(cmd[3].code == \"NetConnection.Connect.Success\") {\n                        console.log(\"[ RTMPMessageHandler ] got _result: \" + cmd[3].code);\n                        postMessage([cmd[3].code]);\n                        this.createStream();\n                    }\n                    break;\n\n                case \"createStream\":\n                    break;\n\n                case \"play\":\n                    break;\n                }\n\n                break;\n\n            case \"onStatus\":\n                console.log(\"[ RTMPMessageHandler ] onStatus: \" + cmd[3].code);\n                postMessage([cmd[3].code]);\n                break;\n\n            default:\n                console.warn(\"[ RTMPMessageHandler ] CommandMessage \" + cmd[0] + \" not yet implemented\");\n                break;\n            }\n\n            break;\n\n        case 22:        // Aggregate Message\n            break;\n\n        case 15:        // Data Message AMF3\n        case 16:        // Shared Object Message AMF3\n        case 17:        // Command Message AMF3\n            console.error(\"[ RTMPMessageHandler ] AMF3 is not yet implemented\");\n            break;\n\n        default:\n            console.warn(\"[ RTMPMessageHandler ] MessageType: \" + RTMPMessage.MessageTypes[msg.getMessageType()] + \"(\" + msg.getMessageType() + \")\");\n            break;\n\n        }\n    }\n\n    /**\n     *\n     * @param {Object} connectionParams\n     * @param {callback} callback\n     */\n    connect(connectionParams, callback){\n        this.callback = callback;\n        const command = new AMF0Object([\n            \"connect\", 1, connectionParams\n        ]);\n\n        //const message_stream_id = this._getNextMessageStreamID();\n\n        let msg = new RTMPMessage(command.getBytes());\n        msg.setMessageType(0x14);\t\t// AMF0 Command\n        msg.setMessageStreamID(0);\n\n        const chunk = new Chunk(msg);\n        chunk.setChunkStreamID(this._getNextChunkStreamID());\n\n        let buf = chunk.getBytes();\n\n        this.netconnections[0] = new NetConnection(0, this);\n\n        this.trackedCommand = \"connect\";\n        this.socket.send(buf);\n    }\n\n    /**\n     *\n     * @param {Object} options\n     */\n    createStream(options){\n        this.trackedCommand = \"createStream\";\n\n        const command = new AMF0Object([\n            \"createStream\", 1, options\n        ]);\n\n        let msg = new RTMPMessage(command.getBytes());\n        msg.setMessageType(0x14);\t\t// AMF0 Command\n        msg.setMessageStreamID(0);\n\n        const chunk = new Chunk(msg);\n        chunk.setChunkStreamID(3);\n\n        let buf = chunk.getBytes();\n\n        this.netconnections[0] = new NetConnection(0, this);\n\n        this.socket.send(buf);\n    }\n\n    /**\n     *\n     * @param {String} streamName\n     */\n    play(streamName){\n        this.trackedCommand = \"play\";\n\n        const command = new AMF0Object([\n            \"play\", 1, null, streamName\n        ]);\n\n        let msg = new RTMPMessage(command.getBytes());\n        msg.setMessageType(0x14);\t\t// AMF0 Command\n        msg.setMessageStreamID(0);\n\n        const chunk = new Chunk(msg);\n        chunk.setChunkStreamID(3);\n\n        let buf = chunk.getBytes();\n\n        this.netconnections[0] = new NetConnection(0, this);\n\n        this.socket.send(buf);\n    }\n\n    /**\n     *\n     * @param {boolean} enable\n     */\n    pause(enable){\n        this.trackedCommand = \"pause\";\n\n        const command = new AMF0Object([\n            \"pause\", 0, null, enable\n        ]);\n\n        let msg = new RTMPMessage(command.getBytes());\n        msg.setMessageType(0x14);\t\t// AMF0 Command\n        msg.setMessageStreamID(0);\n\n        const chunk = new Chunk(msg);\n        chunk.setChunkStreamID(3);\n\n        let buf = chunk.getBytes();\n\n        this.netconnections[0] = new NetConnection(0, this);\n\n        this.socket.send(buf);\n    }\n\n    /**\n     *\n     * @param {Number} size\n     */\n    setChunkSize(size){\n        this.chunk_parser.setChunkSize(size);\n    }\n\n    _getNextMessageStreamID(){\n        return this.netconnections.length;\n    }\n\n    _getNextChunkStreamID(){\n        return ++this.chunk_stream_id;      // increase chunk stream id\n    }\n\n    /**\n     *\n     * @param {RTMPMessage} msg\n     * @private\n     */\n    _handleUserControlMessage(msg) {\n        let data = msg.getPayload()\n\n        this.event_type = (data[0] <<8) | data[1];\n        data = data.slice(2);\n\n        switch (this.event_type){\n            case 0x00:      // StreamBegin\n            case 0x01:      // Stream EOF\n            case 0x02:      // StreamDry\n            case 0x04:      // StreamIsRecorded\n                this.event_data1 = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\n                break;\n\n\n            case 0x03:      // SetBuffer\n                this.event_data1 = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\n                this.event_data2 = (data[4] << 24) | (data[5] << 16) | (data[6] << 8) | (data[7]);\n                break;\n\n            case 0x06:      // PingRequest\n            case 0x07:      // PingResponse\n                this.event_data1 = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3]);\n                break;\n        }\n\n        // Handle Ping internal\n        if(this.event_type === 0x06) {  // Ping Request\n            postMessage([\"UserControlMessage\", [\"ping\", this.event_data1]]);\n\n            const msg = new UserControlMessage();\n            msg.setType(0x07);          // Ping Response\n            msg.setEventData(this.event_data1);\n\n\n            let m2 = new RTMPMessage(msg.getBytes());\n            m2.setMessageType(0x04)     // UserControlMessage\n\n            const chunk = new Chunk(m2);\n            chunk.setChunkStreamID(2);  // Control Channel\n\n            console.log(\"send Pong\");\n            this.socket.send(chunk.getBytes());\n        }\n    }\n}\n\nexport default RTMPMessageHandler;\n\n","import WSSConnectionManager from \"./WSSConnectionManager\";\nimport RTMPHandshake from \"../rtmp/RTMPHandshake\";\nimport RTMPMessageHandler from \"../rtmp/RTMPMessageHandler\";\n\nconst port = 9001;\nlet host;\nlet message_handler;\n\nconst wss_manager = new WSSConnectionManager();\n\nself.addEventListener('message', function(e) {\n\tlet data = e.data;\n\n\tconsole.log(\"[ WebRTMP Worker ] CMD: \" + data.cmd);\n\n\tswitch(data.cmd) {\n\t\tcase \"createConnection\":    // connect WebSocket\n\t\t\thost = data.host;\n\n\t\t\twss_manager.connect(data.host, port, (success)=>{\n\t\t\t\tif(success){\n\t\t\t\t\tpostMessage([\"WSSConnected\"]);\n\n\t\t\t\t\tconst handshake = new RTMPHandshake(wss_manager.getSocket());\n\n\t\t\t\t\thandshake.onHandshakeDone = (success)=>{\n\t\t\t\t\t\tif(success){\n\t\t\t\t\t\t\tpostMessage([\"RTMPHandshakeDone\"]);\n\n\t\t\t\t\t\t\tmessage_handler = new RTMPMessageHandler(wss_manager.getSocket());\n\n\t\t\t\t\t\t\tconsole.log(\"[ WebRTMP Worker ] connect to RTMPManager\");\n\n\t\t\t\t\t\t\twss_manager.registerMessageHandler((e)=> {\n\t\t\t\t\t\t\t\t// connect to chunkparser\n\t\t\t\t\t\t\t\tmessage_handler.parseChunk(new Uint8Array(e.data));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error(\"[ WebRTMP Worker ] Handshake failed\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\thandshake.do();\n\t\t\t\t}\n\t\t\t});\n\t\t\tbreak;\n\n\t\tcase \"closeConnection\":\n\t\t\twss_manager.close();\n\t\t\tbreak;\n\n\t\tcase \"connect\":             // RTMP Connect Application\n\t\t\tmessage_handler.connect(makeDefaultConnectionParams(data.appName), ()=>{\n\t\t\t\tconsole.log(\"connected\");\n\t\t\t\tpostMessage([\"RTMPConnected\"]);\n\t\t\t});\n\t\t\tbreak;\n\n\t\tcase \"play\":\n\t\t\tmessage_handler.play(data.streamName);\n\t\t\tbreak;\n\n        case \"pause\":\n\t\t\tmessage_handler.pause(data.enable);\n            break;\n\n        case \"disconnect\":\n\t\t\twss_manager.close();\n            break;\n\n\t\tdefault:\n\t\t\tconsole.warn(\"[ WebRTMP Worker ] Unknown CMD: \" + data.cmd);\n\t\t\tbreak;\n\t}\n\n}, false);\n\nfunction makeDefaultConnectionParams(application){\n\treturn {\n\t\t\"app\": application,\n\t\t\"flashVer\": \"WebRTMP 0,0,1\",\n\t\t\"tcUrl\": \"rtmp://\" + host + \":1935/\" + application,\n\t\t\"fpad\": false,\n\t\t\"capabilities\": 15,\n\t\t\"audioCodecs\": 4071,\n\t\t\"videoCodecs\": 252,\n\t\t\"videoFunction\": 1\n\t};\n}\n\npostMessage([\"Started\"]);\n\n"],"names":[],"sourceRoot":""}