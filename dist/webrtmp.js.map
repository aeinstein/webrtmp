{"version":3,"file":"dist/webrtmp.js","mappings":"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","sources":["webpack://webrtmp/webpack/bootstrap","webpack://webrtmp/webpack/runtime/get javascript chunk filename","webpack://webrtmp/webpack/runtime/hasOwnProperty shorthand","webpack://webrtmp/webpack/runtime/publicPath","webpack://webrtmp/webpack/runtime/jsonp chunk loading","webpack://webrtmp/./utils/logger.js","webpack://webrtmp/./utils/event_emitter.js","webpack://webrtmp/./formats/media-segment-info.js","webpack://webrtmp/./utils/exception.js","webpack://webrtmp/./utils/utils.js","webpack://webrtmp/./utils/browser.js","webpack://webrtmp/./webrtmp.js","webpack://webrtmp/./wss/webrtmp.controller.js","webpack://webrtmp/./utils/mse-controller.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + \"webrtmp.worker\" + \".js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/webrtmp/\";","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","/*\n * Copyright (C) 2016 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nclass Log {\n    static OFF = -1;\n    static TRACE = 0;\n    static DEBUG = 1;\n    static INFO = 2;\n    static WARN = 3;\n    static ERROR = 4;\n    static CRITICAL = 5;\n    static WITH_STACKTRACE = true;\n\n    static LEVEL = Log.INFO;\n\n    /**\n     * Array with [ClassName, Loglevel]\n     * @type {[]}\n     */\n    static loglevels = [];\n\n    /**\n     *\n     * @param {Number} level\n     * @param {String} tag\n     * @param txt\n     * @private\n     */\n    static _output = function output(level, tag, ...txt){\n        let tmpLevel = Log.LEVEL;\n\n        if(Log.loglevels[tag]) tmpLevel = Log.loglevels[tag];\n\n        if(tmpLevel === Log.OFF) return;\n        if(tmpLevel > level) return;\n\n        const callstack = Log._getStackTrace();\n\n        // debug aufruf entfernen\n        callstack.shift();\n        callstack.shift();\n\n        let color = \"color: silver\";\n\n        switch(level) {\n            case Log.TRACE:\t// TRACE\n                color = \"background-color: gray\";\n                break;\n\n            case Log.DEBUG:\t// DEBUG\n                break;\n\n            case Log.INFO:\t// INFO\n                color = \"color: green\";\n                break;\n\n            case Log.WARN:\t// WARN\n                color = \"color: orange; background-color: #EAA80035\";\n                break;\n\n            case Log.ERROR:\t// ERROR\n                color = \"color: red; background-color: #FF000020\";\n                break;\n\n            case Log.CRITICAL:\t// CRITICAL\n                color = \"color: red\";\n                break;\n        }\n\n        Log._print(callstack, color, tag, ...txt);\n    };\n\n    /**\n     * Internal for console dump\n     * @param {String[]} callstack\n     * @param {String} color\n     * @param {String} tag\n     * @param txt\n     * @private\n     */\n    static _print(callstack, color, tag, ...txt){\n        if(Log.WITH_STACKTRACE){\n            if(Log.LEVEL === Log.ERROR){\n                console.group(\"%c[\" + tag + \"]\", color, ...txt);\n            } else {\n                console.groupCollapsed(\"%c[\" + tag + \"]\", color, ...txt);\n            }\n\n            for(let i = 0; i < callstack.length; i++) {\n                console.log(\"%c\" + callstack[i], color);\n            }\n\n            console.groupEnd();\n\n        } else {\n            console.log(\"%c[\" + tag + \"]\", color, ...txt)\n        }\n    }\n\n    /**\n     * Get Callstack\n     * @returns {String[]}\n     * @private\n     */\n    static _getStackTrace = function() {\n        let callstack = [];\n\n        try {\n            i.dont.exist+=0; //doesn't exist- that's the point\n\n        } catch(e) {\n            if (e.stack) { //Firefox\n                let lines = e.stack.split('\\n');\n\n                for (let i=0; i < lines.length; i++) {\n                    callstack.push(lines[i]);\n                }\n\n                //Ersten Eintrag entfernen\n                callstack.shift();\n                callstack.shift();\n            }\n        }\n\n        return(callstack);\n    };\n\n    /**\n     * Log Critical\n     * @param {String} tag\n     * @param msg\n     */\n    static c(tag, ...msg) {\n        Log._output(Log.CRITICAL, tag, ...msg);\n    }\n\n    /**\n     * Log Error\n     * @param {String} tag\n     * @param msg\n     */\n    static e(tag, ...msg) {\n        Log._output(Log.ERROR, tag, ...msg);\n    }\n\n    /**\n     * Log Info\n     * @param {String} tag\n     * @param msg\n     */\n    static i(tag, ...msg) {\n        Log._output(Log.INFO, tag, ...msg);\n    }\n\n    /**\n     * Log Warning\n     * @param {String} tag\n     * @param msg\n     */\n    static w(tag, ...msg) {\n        Log._output(Log.WARN, tag, ...msg);\n    }\n\n    /**\n     * Log Debug\n     * @param {String} tag\n     * @param msg\n     */\n    static d(tag, ...msg) {\n        Log._output(Log.DEBUG, tag, ...msg);\n    }\n\n    /**\n     * Log Debug\n     * @param {String} tag\n     * @param msg\n     */\n    static v(tag, ...msg) {\n        Log._output(Log.DEBUG, tag, ...msg);\n    }\n\n    /**\n     * Log Trace\n     * @param {String} tag\n     * @param msg\n     */\n    static t(tag, ...msg) {\n        Log._output(Log.TRACE, tag, ...msg);\n    }\n}\n\nexport default Log;\n","/*\n *\n * Copyright (C) 2023 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport Log from \"../utils/logger\";\n\nclass EventEmitter{\n\tListenerList = [];\n\tTAG = \"EventEmitter\";\n\n\tconstructor() {\n\t}\n\n\t/**\n\t *\n\t * @param {String} event\n\t * @param {Function} listener\n\t */\n\taddEventListener(event, listener){\n\t\tthis.ListenerList.push([event, listener]);\n\t}\n\n\t/**\n\t *\n\t * @param {String} event\n\t * @param {Function} listener\n\t */\n\taddListener(event, listener){\n\t\tthis.ListenerList.push([event, listener]);\n\t}\n\n\n\t/**\n\t *\n\t * @param {String} event\n\t * @param {Function} listener\n\t */\n\tremoveListener(event, listener){\n\t\tfor(let i = 0; i < this.ListenerList.length;i++){\n\t\t\tlet entry = this.ListenerList[i];\n\t\t\tif(entry[0] == event && entry[1] == listener){\n\t\t\t\tthis.ListenerList.splice(i,1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove all listener\n\t */\n\tremoveAllListeners(){\n\t\tthis.ListenerList = [];\n\t}\n\n\t/**\n\t *\n\t * @param {String} event\n\t * @param data\n\t */\n\temit(event, ...data){\n\t\tLog.t(this.TAG, \"emit EVENT: \" + event, ...data);\n\t\tfor(let i = 0; i < this.ListenerList.length;i++){\n\t\t\tlet entry = this.ListenerList[i];\n\t\t\tif(entry[0] === event){\n\t\t\t\tentry[1].call(this, ...data);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default EventEmitter;\n\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Represents an media sample (audio / video)\nexport class SampleInfo {\n\n\tconstructor(dts, pts, duration, originalDts, isSync) {\n\t\tthis.dts = dts;\n\t\tthis.pts = pts;\n\t\tthis.duration = duration;\n\t\tthis.originalDts = originalDts;\n\t\tthis.isSyncPoint = isSync;\n\t\tthis.fileposition = null;\n\t}\n\n}\n\n// Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\nexport class MediaSegmentInfo {\n\n\tconstructor() {\n\t\tthis.beginDts = 0;\n\t\tthis.endDts = 0;\n\t\tthis.beginPts = 0;\n\t\tthis.endPts = 0;\n\t\tthis.originalBeginDts = 0;\n\t\tthis.originalEndDts = 0;\n\t\tthis.syncPoints = [];     // SampleInfo[n], for video IDR frames only\n\t\tthis.firstSample = null;  // SampleInfo\n\t\tthis.lastSample = null;   // SampleInfo\n\t}\n\n\tappendSyncPoint(sampleInfo) {  // also called Random Access Point\n\t\tsampleInfo.isSyncPoint = true;\n\t\tthis.syncPoints.push(sampleInfo);\n\t}\n\n}\n\n// Ordered list for recording video IDR frames, sorted by originalDts\nexport class IDRSampleList {\n\n\tconstructor() {\n\t\tthis._list = [];\n\t}\n\n\tclear() {\n\t\tthis._list = [];\n\t}\n\n\tappendArray(syncPoints) {\n\t\tlet list = this._list;\n\n\t\tif (syncPoints.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n\t\t\tthis.clear();\n\t\t}\n\n\t\tArray.prototype.push.apply(list, syncPoints);\n\t}\n\n\tgetLastSyncPointBeforeDts(dts) {\n\t\tif (this._list.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet list = this._list;\n\t\tlet idx = 0;\n\t\tlet last = list.length - 1;\n\t\tlet mid = 0;\n\t\tlet lbound = 0;\n\t\tlet ubound = last;\n\n\t\tif (dts < list[0].dts) {\n\t\t\tidx = 0;\n\t\t\tlbound = ubound + 1;\n\t\t}\n\n\t\twhile (lbound <= ubound) {\n\t\t\tmid = lbound + Math.floor((ubound - lbound) / 2);\n\t\t\tif (mid === last || (dts >= list[mid].dts && dts < list[mid + 1].dts)) {\n\t\t\t\tidx = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (list[mid].dts < dts) {\n\t\t\t\tlbound = mid + 1;\n\t\t\t} else {\n\t\t\t\tubound = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn this._list[idx];\n\t}\n\n}\n\n// Data structure for recording information of media segments in single track.\nexport class MediaSegmentInfoList {\n\n\tconstructor(type) {\n\t\tthis._type = type;\n\t\tthis._list = [];\n\t\tthis._lastAppendLocation = -1;  // cached last insert location\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget length() {\n\t\treturn this._list.length;\n\t}\n\n\tisEmpty() {\n\t\treturn this._list.length === 0;\n\t}\n\n\tclear() {\n\t\tthis._list = [];\n\t\tthis._lastAppendLocation = -1;\n\t}\n\n\t_searchNearestSegmentBefore(originalBeginDts) {\n\t\tlet list = this._list;\n\t\tif (list.length === 0) {\n\t\t\treturn -2;\n\t\t}\n\t\tlet last = list.length - 1;\n\t\tlet mid = 0;\n\t\tlet lbound = 0;\n\t\tlet ubound = last;\n\n\t\tlet idx = 0;\n\n\t\tif (originalBeginDts < list[0].originalBeginDts) {\n\t\t\tidx = -1;\n\t\t\treturn idx;\n\t\t}\n\n\t\twhile (lbound <= ubound) {\n\t\t\tmid = lbound + Math.floor((ubound - lbound) / 2);\n\t\t\tif (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\n\t\t\t\t(originalBeginDts < list[mid + 1].originalBeginDts))) {\n\t\t\t\tidx = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (list[mid].originalBeginDts < originalBeginDts) {\n\t\t\t\tlbound = mid + 1;\n\t\t\t} else {\n\t\t\t\tubound = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\n\t_searchNearestSegmentAfter(originalBeginDts) {\n\t\treturn this._searchNearestSegmentBefore(originalBeginDts) + 1;\n\t}\n\n\tappend(mediaSegmentInfo) {\n\t\tlet list = this._list;\n\t\tlet msi = mediaSegmentInfo;\n\t\tlet lastAppendIdx = this._lastAppendLocation;\n\t\tlet insertIdx = 0;\n\n\t\tif (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\n\t\t\tmsi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\n\t\t\t((lastAppendIdx === list.length - 1) ||\n\t\t\t\t(lastAppendIdx < list.length - 1 &&\n\t\t\t\t\tmsi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\n\t\t\tinsertIdx = lastAppendIdx + 1;  // use cached location idx\n\t\t} else {\n\t\t\tif (list.length > 0) {\n\t\t\t\tinsertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n\t\t\t}\n\t\t}\n\n\t\tthis._lastAppendLocation = insertIdx;\n\t\tthis._list.splice(insertIdx, 0, msi);\n\t}\n\n\tgetLastSegmentBefore(originalBeginDts) {\n\t\tlet idx = this._searchNearestSegmentBefore(originalBeginDts);\n\t\tif (idx >= 0) {\n\t\t\treturn this._list[idx];\n\t\t} else {  // -1\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetLastSampleBefore(originalBeginDts) {\n\t\tlet segment = this.getLastSegmentBefore(originalBeginDts);\n\t\tif (segment != null) {\n\t\t\treturn segment.lastSample;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetLastSyncPointBefore(originalBeginDts) {\n\t\tlet segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n\t\tlet syncPoints = this._list[segmentIdx].syncPoints;\n\t\twhile (syncPoints.length === 0 && segmentIdx > 0) {\n\t\t\tsegmentIdx--;\n\t\t\tsyncPoints = this._list[segmentIdx].syncPoints;\n\t\t}\n\t\tif (syncPoints.length > 0) {\n\t\t\treturn syncPoints[syncPoints.length - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class RuntimeException {\n    constructor(message) {\n        this._message = message;\n    }\n\n    get name() {\n        return 'RuntimeException';\n    }\n\n    get message() {\n        return this._message;\n    }\n\n    toString() {\n        return this.name + ': ' + this.message;\n    }\n}\n\nexport class IllegalStateException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'IllegalStateException';\n    }\n}\n\nexport class InvalidArgumentException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'InvalidArgumentException';\n    }\n}\n\nexport class NotImplementedException extends RuntimeException {\n    constructor(message) {\n        super(message);\n    }\n\n    get name() {\n        return 'NotImplementedException';\n    }\n}\n","\n/*\n *\n * Copyright (C) 2023 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n *\n * @param {Uint8Array} bufs\n * @returns {Uint8Array}\n */\n\nexport function _concatArrayBuffers(...bufs){\n    const result = new Uint8Array(bufs.reduce((totalSize, buf)=>totalSize+buf.byteLength,0));\n    bufs.reduce((offset, buf)=>{\n        result.set(buf,offset)\n        return offset+buf.byteLength\n    },0)\n\n    return result;\n}\n\n/**\n *\n * @param {String} str\n * @returns {*[]}\n * @private\n */\nexport function _stringToByteArray(str) {\n    const bytes = [];\n\n    for(let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        if(char > 0xFF) {\n            bytes.push(char >>> 8);\n        }\n\n        bytes.push(char & 0xFF);\n    }\n    return bytes;\n}\n\n/**\n *\n * @param {Number} num\n * @returns {*[]}\n * @private\n */\nexport function _numberToByteArray(num) {\n    const buffer = new ArrayBuffer(8);\n    new DataView(buffer).setFloat64(0, num, false);\n    return [].slice.call(new Uint8Array(buffer));\n}\n\n/**\n *\n * @param {byte[]} ba\n * @returns {number}\n * @private\n */\nexport function _byteArrayToNumber(ba){\n    let buf = new ArrayBuffer(ba.length);\n    let view = new DataView(buf);\n\n    ba.forEach(function (b, i) {\n        view.setUint8(i, b);\n    });\n\n    return view.getFloat64(0);\n}\n\n/**\n *\n * @param {byte[]} ba\n * @returns {string}\n * @private\n */\nexport function _byteArrayToString(ba){\n    let ret = \"\";\n\n    for(let i = 0; i < ba.length; i++){\n        ret += String.fromCharCode(ba[i]);\n    }\n\n    return ret;\n}\n\nexport const defaultConfig = {\n    enableWorker: false,\n    enableStashBuffer: true,\n    stashInitialSize: undefined,\n\n    isLive: true,\n\n    lazyLoad: true,\n    lazyLoadMaxDuration: 3 * 60,\n    lazyLoadRecoverDuration: 30,\n    deferLoadAfterSourceOpen: true,\n\n    autoCleanupSourceBuffer: true,\n    autoCleanupMaxBackwardDuration: 3 * 60,\n    autoCleanupMinBackwardDuration: 2 * 60,\n\n    statisticsInfoReportInterval: 600,\n\n    fixAudioTimestampGap: true,\n\n    accurateSeek: false,\n    seekType: 'range',  // [range, param, custom]\n    seekParamStart: 'bstart',\n    seekParamEnd: 'bend',\n    rangeLoadZeroStart: false,\n    customSeekHandler: undefined,\n    reuseRedirectedURL: false,\n    // referrerPolicy: leave as unspecified\n\n    headers: undefined,\n    customLoader: undefined\n};\n\n\nexport const TransmuxingEvents = {\n    IO_ERROR: 'io_error',\n    DEMUX_ERROR: 'demux_error',\n    INIT_SEGMENT: 'init_segment',\n    MEDIA_SEGMENT: 'media_segment',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info',\n    RECOMMEND_SEEKPOINT: 'recommend_seekpoint'\n};\n\nexport const DemuxErrors = {\n    OK: 'OK',\n    FORMAT_ERROR: 'FormatError',\n    FORMAT_UNSUPPORTED: 'FormatUnsupported',\n    CODEC_UNSUPPORTED: 'CodecUnsupported'\n};\n\nexport const MSEEvents = {\n    ERROR: 'error',\n    SOURCE_OPEN: 'source_open',\n    UPDATE_END: 'update_end',\n    BUFFER_FULL: 'buffer_full'\n};\n\nexport const PlayerEvents = {\n    ERROR: 'error',\n    LOADING_COMPLETE: 'loading_complete',\n    RECOVERED_EARLY_EOF: 'recovered_early_eof',\n    MEDIA_INFO: 'media_info',\n    METADATA_ARRIVED: 'metadata_arrived',\n    SCRIPTDATA_ARRIVED: 'scriptdata_arrived',\n    STATISTICS_INFO: 'statistics_info'\n};\n\nexport const ErrorTypes = {\n    NETWORK_ERROR: 'NetworkError',\n    MEDIA_ERROR: 'MediaError',\n    OTHER_ERROR: 'OtherError'\n};\n\nexport const LoaderErrors = {\n    OK: 'OK',\n    EXCEPTION: 'Exception',\n    HTTP_STATUS_CODE_INVALID: 'HttpStatusCodeInvalid',\n    CONNECTING_TIMEOUT: 'ConnectingTimeout',\n    EARLY_EOF: 'EarlyEof',\n    UNRECOVERABLE_EARLY_EOF: 'UnrecoverableEarlyEof'\n};\n\nexport const ErrorDetails = {\n    NETWORK_EXCEPTION: LoaderErrors.EXCEPTION,\n    NETWORK_STATUS_CODE_INVALID: LoaderErrors.HTTP_STATUS_CODE_INVALID,\n    NETWORK_TIMEOUT: LoaderErrors.CONNECTING_TIMEOUT,\n    NETWORK_UNRECOVERABLE_EARLY_EOF: LoaderErrors.UNRECOVERABLE_EARLY_EOF,\n\n    MEDIA_MSE_ERROR: 'MediaMSEError',\n\n    MEDIA_FORMAT_ERROR: DemuxErrors.FORMAT_ERROR,\n    MEDIA_FORMAT_UNSUPPORTED: DemuxErrors.FORMAT_UNSUPPORTED,\n    MEDIA_CODEC_UNSUPPORTED: DemuxErrors.CODEC_UNSUPPORTED\n};\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet Browser = {};\n\nfunction detect() {\n\t// modified from jquery-browser-plugin\n\n\tlet ua = self.navigator.userAgent.toLowerCase();\n\n\tlet match = /(edge)\\/([\\w.]+)/.exec(ua) ||\n\t\t/(opr)[\\/]([\\w.]+)/.exec(ua) ||\n\t\t/(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(iemobile)[\\/]([\\w.]+)/.exec(ua) ||\n\t\t/(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t/(msie) ([\\w.]+)/.exec(ua) ||\n\t\tua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua) ||\n\t\tua.indexOf('compatible') < 0 && /(firefox)[ \\/]([\\w.]+)/.exec(ua) ||\n\t\t[];\n\n\tlet platform_match = /(ipad)/.exec(ua) ||\n\t\t/(ipod)/.exec(ua) ||\n\t\t/(windows phone)/.exec(ua) ||\n\t\t/(iphone)/.exec(ua) ||\n\t\t/(kindle)/.exec(ua) ||\n\t\t/(android)/.exec(ua) ||\n\t\t/(windows)/.exec(ua) ||\n\t\t/(mac)/.exec(ua) ||\n\t\t/(linux)/.exec(ua) ||\n\t\t/(cros)/.exec(ua) ||\n\t\t[];\n\n\tlet matched = {\n\t\tbrowser: match[5] || match[3] || match[1] || '',\n\t\tversion: match[2] || match[4] || '0',\n\t\tmajorVersion: match[4] || match[2] || '0',\n\t\tplatform: platform_match[0] || ''\n\t};\n\n\tlet browser = {};\n\tif (matched.browser) {\n\t\tbrowser[matched.browser] = true;\n\n\t\tlet versionArray = matched.majorVersion.split('.');\n\t\tbrowser.version = {\n\t\t\tmajor: parseInt(matched.majorVersion, 10),\n\t\t\tstring: matched.version\n\t\t};\n\t\tif (versionArray.length > 1) {\n\t\t\tbrowser.version.minor = parseInt(versionArray[1], 10);\n\t\t}\n\t\tif (versionArray.length > 2) {\n\t\t\tbrowser.version.build = parseInt(versionArray[2], 10);\n\t\t}\n\t}\n\n\tif (matched.platform) {\n\t\tbrowser[matched.platform] = true;\n\t}\n\n\tif (browser.chrome || browser.opr || browser.safari) {\n\t\tbrowser.webkit = true;\n\t}\n\n\t// MSIE. IE11 has 'rv' identifer\n\tif (browser.rv || browser.iemobile) {\n\t\tif (browser.rv) {\n\t\t\tdelete browser.rv;\n\t\t}\n\t\tlet msie = 'msie';\n\t\tmatched.browser = msie;\n\t\tbrowser[msie] = true;\n\t}\n\n\t// Microsoft Edge\n\tif (browser.edge) {\n\t\tdelete browser.edge;\n\t\tlet msedge = 'msedge';\n\t\tmatched.browser = msedge;\n\t\tbrowser[msedge] = true;\n\t}\n\n\t// Opera 15+\n\tif (browser.opr) {\n\t\tlet opera = 'opera';\n\t\tmatched.browser = opera;\n\t\tbrowser[opera] = true;\n\t}\n\n\t// Stock android browsers are marked as Safari\n\tif (browser.safari && browser.android) {\n\t\tlet android = 'android';\n\t\tmatched.browser = android;\n\t\tbrowser[android] = true;\n\t}\n\n\tbrowser.name = matched.browser;\n\tbrowser.platform = matched.platform;\n\n\tfor (let key in Browser) {\n\t\tif (Browser.hasOwnProperty(key)) {\n\t\t\tdelete Browser[key];\n\t\t}\n\t}\n\tObject.assign(Browser, browser);\n}\n\ndetect();\n\nexport default Browser;\n","/*\r\n *\r\n * Copyright (C) 2023 itNOX. All Rights Reserved.\r\n *\r\n * @author Michael Balen <mb@itnox.de>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\n\r\nimport Log from \"./utils/logger\";\r\nimport MSEController from \"./utils/mse-controller\";\r\nimport {defaultConfig, ErrorDetails, ErrorTypes, MSEEvents, PlayerEvents, TransmuxingEvents} from \"./utils/utils\";\r\nimport EventEmitter from \"./utils/event_emitter\";\r\nimport WebRTMP_Controller from \"./wss/webrtmp.controller\";\r\nimport Browser from \"./utils/browser\";\r\n\r\nclass WebRTMP{\r\n\tTAG = 'WebRTMP';\r\n\t_mediaElement = null;\r\n\r\n\tconstructor() {\r\n\t\tthis.wss = new WebRTMP_Controller();\r\n\r\n\t\tthis._config = defaultConfig\r\n\r\n\t\tthis.wss.addEventListener(\"RTMPMessageArrived\", (data)=>{\r\n\t\t\tLog.d(this.TAG,\"RTMPMessageArrived\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"ProtocolControlMessage\", (data)=>{\r\n\t\t\tLog.d(this.TAG,\"ProtocolControlMessage\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"UserControlMessage\", (data)=>{\r\n\t\t\tLog.d(this.TAG,\"UserControlMessage\", data);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(\"ConnectionLost\", ()=>{});\r\n\r\n\t\tthis._emitter = new EventEmitter();\r\n\r\n\t\tthis.e = {\r\n\t\t\tonvLoadedMetadata: this._onvLoadedMetadata.bind(this),\r\n\t\t\tonvSeeking: this._onvSeeking.bind(this),\r\n\t\t\tonvCanPlay: this._onvCanPlay.bind(this),\r\n\t\t\tonvStalled: this._onvStalled.bind(this),\r\n\t\t\tonvProgress: this._onvProgress.bind(this)\r\n\t\t};\r\n\t}\r\n\r\n\t_checkAndResumeStuckPlayback(stalled) {\r\n\t\tlet media = this._mediaElement;\r\n\t\tif (stalled || !this._receivedCanPlay || media.readyState < 2) {  // HAVE_CURRENT_DATA\r\n\t\t\tlet buffered = media.buffered;\r\n\t\t\tif (buffered.length > 0 && media.currentTime < buffered.start(0)) {\r\n\t\t\t\tLog.w(this.TAG, `Playback seems stuck at ${media.currentTime}, seek to ${buffered.start(0)}`);\r\n\t\t\t\tthis._requestSetTime = true;\r\n\t\t\t\tthis._mediaElement.currentTime = buffered.start(0);\r\n\t\t\t\tthis._mediaElement.removeEventListener('progress', this.e.onvProgress);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Playback didn't stuck, remove progress event listener\r\n\t\t\tthis._mediaElement.removeEventListener('progress', this.e.onvProgress);\r\n\t\t}\r\n\t}\r\n\r\n\t_onvLoadedMetadata(e) {\r\n\t\tif (this._pendingSeekTime != null) {\r\n\t\t\tthis._mediaElement.currentTime = this._pendingSeekTime;\r\n\t\t\tthis._pendingSeekTime = null;\r\n\t\t}\r\n\t}\r\n\r\n\t_onvCanPlay(e) {\r\n\t\tthis._receivedCanPlay = true;\r\n\t\tthis._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\r\n\t}\r\n\r\n\t_onvStalled(e) {\r\n\t\tthis._checkAndResumeStuckPlayback(true);\r\n\t}\r\n\r\n\t_onvProgress(e) {\r\n\t\tthis._checkAndResumeStuckPlayback();\r\n\t}\r\n\r\n\t_onvSeeking(){\r\n\t\tlet target = this._mediaElement.currentTime;\r\n\t\tlet buffered = this._mediaElement.buffered;\r\n\r\n\t\tif (this._requestSetTime) {\r\n\t\t\tthis._requestSetTime = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (target < 1.0 && buffered.length > 0) {\r\n\t\t\t// seek to video begin, set currentTime directly if beginPTS buffered\r\n\t\t\tlet videoBeginTime = buffered.start(0);\r\n\t\t\tif ((videoBeginTime < 1.0 && target < videoBeginTime) || Browser.safari) {\r\n\t\t\t\tthis._requestSetTime = true;\r\n\t\t\t\t// also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\r\n\t\t\t\tthis._mediaElement.currentTime = Browser.safari ? 0.1 : videoBeginTime;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this._isTimepointBuffered(target)) {\r\n\t\t\tif (this._alwaysSeekKeyframe) {\r\n\t\t\t\tlet idr = this._msectl.getNearestKeyframe(Math.floor(target * 1000));\r\n\t\t\t\tif (idr != null) {\r\n\t\t\t\t\tthis._requestSetTime = true;\r\n\t\t\t\t\tthis._mediaElement.currentTime = idr.dts / 1000;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this._progressChecker != null) {\r\n\t\t\t\tthis._checkProgressAndResume();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._seekpointRecord = {\r\n\t\t\tseekPoint: target,\r\n\t\t\trecordTime: this._now()\r\n\t\t};\r\n\t\twindow.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\r\n\t}\r\n\r\n\t_isTimepointBuffered(seconds) {\r\n\t\tlet buffered = this._mediaElement.buffered;\r\n\r\n\t\tfor (let i = 0; i < buffered.length; i++) {\r\n\t\t\tlet from = buffered.start(i);\r\n\t\t\tlet to = buffered.end(i);\r\n\t\t\tif (seconds >= from && seconds < to) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t_checkProgressAndResume() {\r\n\t\tlet currentTime = this._mediaElement.currentTime;\r\n\t\tlet buffered = this._mediaElement.buffered;\r\n\r\n\t\tlet needResume = false;\r\n\r\n\t\tfor (let i = 0; i < buffered.length; i++) {\r\n\t\t\tlet from = buffered.start(i);\r\n\t\t\tlet to = buffered.end(i);\r\n\t\t\tif (currentTime >= from && currentTime < to) {\r\n\t\t\t\tif (currentTime >= to - this._config.lazyLoadRecoverDuration) {\r\n\t\t\t\t\tneedResume = true;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (needResume) {\r\n\t\t\twindow.clearInterval(this._progressChecker);\r\n\t\t\tthis._progressChecker = null;\r\n\t\t\tif (needResume) {\r\n\t\t\t\tLog.v(this.TAG, 'Continue loading from paused position');\r\n\t\t\t\t//this._transmuxer.resume();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t_checkAndApplyUnbufferedSeekpoint() {\r\n\t\tif (this._seekpointRecord) {\r\n\t\t\tif (this._seekpointRecord.recordTime <= this._now() - 100) {\r\n\t\t\t\tlet target = this._mediaElement.currentTime;\r\n\t\t\t\tthis._seekpointRecord = null;\r\n\t\t\t\tif (!this._isTimepointBuffered(target)) {\r\n\t\t\t\t\tif (this._progressChecker != null) {\r\n\t\t\t\t\t\twindow.clearTimeout(this._progressChecker);\r\n\t\t\t\t\t\tthis._progressChecker = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// .currentTime is consists with .buffered timestamp\r\n\t\t\t\t\t// Chrome/Edge use DTS, while FireFox/Safari use PTS\r\n\t\t\t\t\tthis._msectl.seek(target);\r\n\t\t\t\t\tthis._transmuxer.seek(Math.floor(target * 1000));\r\n\t\t\t\t\t// set currentTime if accurateSeek, or wait for recommend_seekpoint callback\r\n\t\t\t\t\tif (this._config.accurateSeek) {\r\n\t\t\t\t\t\tthis._requestSetTime = true;\r\n\t\t\t\t\t\tthis._mediaElement.currentTime = target;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twindow.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t_onmseBufferFull() {\r\n\t\tLog.w(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\r\n\t\tif (this._progressChecker == null) {\r\n\t\t\t//this._suspendTransmuxer();\r\n\t\t}\r\n\t}\r\n\r\n\t_onmseUpdateEnd() {\r\n\t\tif (!this._config.lazyLoad || this._config.isLive) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet buffered = this._mediaElement.buffered;\r\n\t\tlet currentTime = this._mediaElement.currentTime;\r\n\t\tlet currentRangeStart = 0;\r\n\t\tlet currentRangeEnd = 0;\r\n\r\n\t\tfor (let i = 0; i < buffered.length; i++) {\r\n\t\t\tlet start = buffered.start(i);\r\n\t\t\tlet end = buffered.end(i);\r\n\t\t\tif (start <= currentTime && currentTime < end) {\r\n\t\t\t\tcurrentRangeStart = start;\r\n\t\t\t\tcurrentRangeEnd = end;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\r\n\t\t\tLog.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\r\n\t\t\tthis._suspendTransmuxer();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tdestroy() {\r\n\t\tif (this._progressChecker != null) {\r\n\t\t\twindow.clearInterval(this._progressChecker);\r\n\t\t\tthis._progressChecker = null;\r\n\t\t}\r\n\t\tif (this._transmuxer) {\r\n\t\t\tthis.unload();\r\n\t\t}\r\n\t\tif (this._mediaElement) {\r\n\t\t\tthis.detachMediaElement();\r\n\t\t}\r\n\t\tthis.e = null;\r\n\t\tthis._mediaDataSource = null;\r\n\r\n\t\tthis._emitter.removeAllListeners();\r\n\t\tthis._emitter = null;\r\n\t}\r\n\r\n\tdisconnect(){\r\n\t\tthis.wss.disconnect();\r\n\t}\r\n\r\n\tplay(streamName){\r\n\t\treturn new Promise((resolve, reject)=>{\r\n\t\t\t/*\r\n\t\t\tthis.wss.addEventListener(\"RTMPHandshakeDone\", (success)=>{\r\n\t\t\t\tLog.d(this.TAG,\"RTMPHandshakeDone\");\r\n\t\t\t\tif(success) resolve();\r\n\t\t\t\telse reject();\r\n\t\t\t});*/\r\n\r\n\t\t\tthis.wss.play(streamName);\r\n\t\t\tthis._mediaElement.play();\r\n\t\t\tresolve();\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {String|null} host\r\n\t * @param {Number|null} port\r\n\t * @returns {Promise<unknown>}\r\n\t */\r\n\topen(host, port){\r\n\t\treturn new Promise((resolve, reject)=>{\r\n\t\t\tthis.wss.addEventListener(\"RTMPHandshakeDone\", (success)=>{\r\n\t\t\t\tLog.d(this.TAG,\"RTMPHandshakeDone\");\r\n\t\t\t\tif(success) resolve();\r\n\t\t\t\telse reject();\r\n\t\t\t});\r\n\r\n\t\t\tthis.wss.addEventListener(\"WSSConnectFailed\", ()=>{\r\n\t\t\t\tLog.d(this.TAG,\"WSSConnectFailed\");\r\n\t\t\t\treject();\r\n\t\t\t});\r\n\r\n\t\t\tthis.wss.open(host, port);\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {String} appName\r\n\t * @returns {Promise<unknown>}\r\n\t */\r\n\tconnect(appName){\r\n\t\treturn new Promise((resolve, reject)=>{\r\n\t\t\tthis.wss.addEventListener(\"RTMPStreamCreated\", ()=>{\r\n\t\t\t\tLog.d(this.TAG,\"RTMPStreamCreated\");\r\n\t\t\t\tresolve();\r\n\t\t\t});\r\n\r\n\t\t\tthis.wss.connect(appName);\r\n\t\t})\r\n\r\n\t}\r\n\r\n\tpause(enable){\r\n\t\tthis.wss.pause(enable);\r\n\t}\r\n\r\n\tdetachMediaElement() {\r\n\t\tif (this._mediaElement) {\r\n\t\t\tthis._msectl.detachMediaElement();\r\n\t\t\tthis._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\r\n\t\t\tthis._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\r\n\t\t\tthis._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\r\n\t\t\tthis._mediaElement.removeEventListener('stalled', this.e.onvStalled);\r\n\t\t\tthis._mediaElement.removeEventListener('progress', this.e.onvProgress);\r\n\t\t\tthis._mediaElement = null;\r\n\t\t}\r\n\r\n\t\tif (this._msectl) {\r\n\t\t\tthis._msectl.destroy();\r\n\t\t\tthis._msectl = null;\r\n\t\t}\r\n\t}\r\n\r\n\tattachMediaElement(mediaElement) {\r\n\t\tthis._mediaElement = mediaElement;\r\n\t\tmediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\r\n\t\tmediaElement.addEventListener('seeking', this.e.onvSeeking);\r\n\t\tmediaElement.addEventListener('canplay', this.e.onvCanPlay);\r\n\t\tmediaElement.addEventListener('stalled', this.e.onvStalled);\r\n\t\tmediaElement.addEventListener('progress', this.e.onvProgress);\r\n\r\n\t\tthis._msectl = new MSEController(defaultConfig);\r\n\r\n\t\tthis._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\r\n\t\tthis._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\r\n\r\n\t\tthis._msectl.on(MSEEvents.ERROR, (info) => {\r\n\t\t\tthis._emitter.emit(PlayerEvents.ERROR,\r\n\t\t\t\tErrorTypes.MEDIA_ERROR,\r\n\t\t\t\tErrorDetails.MEDIA_MSE_ERROR,\r\n\t\t\t\tinfo\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(TransmuxingEvents.INIT_SEGMENT, (data)=>{\r\n\t\t\tLog.i(this.TAG, TransmuxingEvents.INIT_SEGMENT, data[0], data[1]);\r\n\t\t\tthis._msectl.appendInitSegment(data[1]);\r\n\t\t});\r\n\r\n\t\tthis.wss.addEventListener(TransmuxingEvents.MEDIA_SEGMENT, (data)=>{\r\n\t\t\tLog.i(this.TAG, TransmuxingEvents.MEDIA_SEGMENT, data[0], data[1]);\r\n\t\t\tthis._msectl.appendMediaSegment(data[1]);\r\n\t\t});\r\n\r\n\t\tthis._msectl.attachMediaElement(mediaElement);\r\n\r\n\t\tif (this._pendingSeekTime != null) {\r\n\t\t\ttry {\r\n\t\t\t\tmediaElement.currentTime = this._pendingSeekTime;\r\n\t\t\t\tthis._pendingSeekTime = null;\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// IE11 may throw InvalidStateError if readyState === 0\r\n\t\t\t\t// We can defer set currentTime operation after loadedmetadata\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t}\r\n}\r\n\r\nexport default WebRTMP;\r\n\r\nwindow[\"Log\"] = Log;\r\nwindow[\"webrtmp\"] = new WebRTMP();\r\n\r\n","/*\n *\n * Copyright (C) 2023 itNOX. All Rights Reserved.\n *\n * @author Michael Balen <mb@itnox.de>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport EventEmitter from \"../utils/event_emitter\";\nimport Log from \"../utils/logger\";\n\nclass WebRTMP_Controller {\n\tTAG = \"WebRTMP_Controller\";\n\thost = document.location.host;\n\tport = 9001;\n\tWSSReconnect = false;\n\tisConnected = false;\n\n\tloglevels = {\n\t\t\"RTMPMessage\": Log.ERROR,\n\t\t\"RTMPMessageHandler\": Log.WARN,\n\t\t\"RTMPMediaMessageHandler\": Log.ERROR,\n\t\t\"ChunkParser\": Log.WARN,\n\t\t\"RTMPHandshake\": Log.ERROR,\n\t\t\"Chunk\": Log.OFF,\n\t\t\"MP4Remuxer\": Log.ERROR,\n\t\t\"Transmuxer\": Log.WARN,\n\t\t\"EventEmitter\": Log.DEBUG,\n\t\t\"MSEController\": Log.INFO,\n\t\t\"WebRTMP\": Log.WARN,\n\t\t\"WebRTMP_Controller\": Log.WARN,\n\t\t\"WebRTMP Worker\": Log.WARN,\n\t\t\"AMF\": Log.WARN\n\t}\n\n\tWebRTMPWorker = new Worker(new URL('connection.worker.js', import.meta.url), {\n\t\tname: \"webrtmp.worker\",\n\t\ttype: \"module\"\n\t\t/* webpackEntryOptions: { filename: \"[name].js\" } */\n\t});\n\n\tconstructor() {\n\t\tLog.loglevels = this.loglevels;\n\n\t\tthis._emitter = new EventEmitter();\n\n\t\tthis.WebRTMPWorker.addEventListener(\"message\", (evt)=>{\n\t\t\tthis.WorkerListener(evt);\n\t\t});\n\t}\n\n\t/**\n\t *\n\t * @param {String|null} host\n\t * @param {Number|null} port\n\t * @returns {boolean}\n\t */\n\topen(host, port){\n\t\tif(this.isConnected) return false;\n\n\t\tif(host) this.host = host;\n\t\tif(port) this.port = port;\n\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"open\", host: this.host, port: this.port});\n\t}\n\n\t/**\n\t * Websocket disconnect\n\t */\n\tdisconnect() {\n\t\tthis.WSSReconnect = true;\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"disconnect\"});\n\t}\n\n\t/**\n\t * RTMP connect application\n\t * @param {String} appName\n\t */\n\tconnect(appName){\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"connect\", appName: appName});\n\t}\n\n\t/**\n\t * RTMP play streamname\n\t * @param {String} streamName\n\t */\n\tplay(streamName){\n\t\tthis.WebRTMPWorker.postMessage({cmd: \"play\", streamName: streamName});\n\t}\n\n    pause(enable){\n        this.WebRTMPWorker.postMessage({cmd: \"pause\", enable: enable});\n    }\n\n\n\t/**\n\t * Eventlistenre hinzufgenm\n\t * @param type\n\t * @param listener\n\t */\n\taddEventListener(type, listener){\n\t\tthis._emitter.addEventListener(type, listener);\n\t}\n\n\n\n\t/**\n\t * Verarbeitet MQTT Events\n\t * @param evt Event\n\t */\n\tWorkerListener(evt){\n\t\t// Message.data wieder zum Event machen\n\t\tconst data = evt.data;\n\n\t\tswitch(data[0]){\n\t\t\tcase \"ConnectionLost\":\n\t\t\t\tthis._emitter.emit(\"ConnectionLost\");\n\t\t\t\tLog.d(this.TAG, \"Event ConnectionLost\");\n\n\t\t\t\tthis.isConnected = false;\n\n\t\t\t\tif(this.WSSReconnect) {\n\t\t\t\t\tLog.w(this.TAG,\"[ WorkerListener ] Reconnect timed\");\n\n\t\t\t\t\twindow.setTimeout(()=>{\n\t\t\t\t\t\tLog.w(this.TAG, \"timed Reconnect\");\n\t\t\t\t\t\tthis.open(this.host, this.port);\n\t\t\t\t\t}, 1000)\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"Connected\":\n\t\t\t\tLog.d(this.TAG, \"Event Connected\");\n\t\t\t\tthis._emitter.emit(\"Connected\");\n\t\t\t\tthis.isConnected = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"Started\":\n\t\t\t\tthis.WebRTMPWorker.postMessage({\n\t\t\t\t\tcmd: \"loglevels\",\n\t\t\t\t\tloglevels: this.loglevels\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tLog.i(this.TAG, data[0], data.slice(1));\n\t\t\t\tthis._emitter.emit(data[0], data.slice(1));\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport default WebRTMP_Controller;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from \"./logger\";\nimport EventEmitter from \"./event_emitter\";\nimport {IDRSampleList} from \"../formats/media-segment-info\";\nimport {IllegalStateException} from \"./exception\";\nimport {MSEEvents} from \"./utils\";\nimport Browser from \"./browser\";\n\nclass MSEController {\n\tTAG = 'MSEController';\n\n\tconstructor(config) {\n\t\tthis._config = config;\n\t\tthis._emitter = new EventEmitter();\n\n\t\tif (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n\t\t\t// For live stream, do auto cleanup by default\n\t\t\tthis._config.autoCleanupSourceBuffer = true;\n\t\t}\n\n\t\tthis.e = {\n\t\t\tonSourceOpen: this._onSourceOpen.bind(this),\n\t\t\tonSourceEnded: this._onSourceEnded.bind(this),\n\t\t\tonSourceClose: this._onSourceClose.bind(this),\n\t\t\tonSourceBufferError: this._onSourceBufferError.bind(this),\n\t\t\tonSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n\t\t};\n\n\t\tthis._mediaSource = null;\n\t\tthis._mediaSourceObjectURL = null;\n\t\tthis._mediaElement = null;\n\n\t\tthis._isBufferFull = false;\n\t\tthis._hasPendingEos = false;\n\n\t\tthis._requireSetMediaDuration = false;\n\t\tthis._pendingMediaDuration = 0;\n\n\t\tthis._pendingSourceBufferInit = [];\n\t\tthis._mimeTypes = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._sourceBuffers = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._lastInitSegments = {\n\t\t\tvideo: null,\n\t\t\taudio: null\n\t\t};\n\t\tthis._pendingSegments = {\n\t\t\tvideo: [],\n\t\t\taudio: []\n\t\t};\n\t\tthis._pendingRemoveRanges = {\n\t\t\tvideo: [],\n\t\t\taudio: []\n\t\t};\n\t\tthis._idrList = new IDRSampleList();\n\t}\n\n\tdestroy() {\n\t\tif (this._mediaElement || this._mediaSource) {\n\t\t\tthis.detachMediaElement();\n\t\t}\n\t\tthis.e = null;\n\t\tthis._emitter.removeAllListeners();\n\t\tthis._emitter = null;\n\t}\n\n\ton(event, listener) {\n\t\tthis._emitter.addListener(event, listener);\n\t}\n\n\toff(event, listener) {\n\t\tthis._emitter.removeListener(event, listener);\n\t}\n\n\tattachMediaElement(mediaElement) {\n\t\tif (this._mediaSource) {\n\t\t\tthrow new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n\t\t}\n\t\tlet ms = this._mediaSource = new window.MediaSource();\n\t\tms.addEventListener('sourceopen', this.e.onSourceOpen);\n\t\tms.addEventListener('sourceended', this.e.onSourceEnded);\n\t\tms.addEventListener('sourceclose', this.e.onSourceClose);\n\n\t\tthis._mediaElement = mediaElement;\n\t\tthis._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n\t\tmediaElement.src = this._mediaSourceObjectURL;\n\t}\n\n\tdetachMediaElement() {\n\t\tif (this._mediaSource) {\n\t\t\tlet ms = this._mediaSource;\n\t\t\tfor (let type in this._sourceBuffers) {\n\t\t\t\t// pending segments should be discard\n\t\t\t\tlet ps = this._pendingSegments[type];\n\t\t\t\tps.splice(0, ps.length);\n\t\t\t\tthis._pendingSegments[type] = null;\n\t\t\t\tthis._pendingRemoveRanges[type] = null;\n\t\t\t\tthis._lastInitSegments[type] = null;\n\n\t\t\t\t// remove all sourcebuffers\n\t\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\t\tif (sb) {\n\t\t\t\t\tif (ms.readyState !== 'closed') {\n\t\t\t\t\t\t// ms edge can throw an error: Unexpected call to method or property access\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tms.removeSourceBuffer(sb);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsb.removeEventListener('error', this.e.onSourceBufferError);\n\t\t\t\t\t\tsb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n\t\t\t\t\t}\n\t\t\t\t\tthis._mimeTypes[type] = null;\n\t\t\t\t\tthis._sourceBuffers[type] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ms.readyState === 'open') {\n\t\t\t\ttry {\n\t\t\t\t\tms.endOfStream();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tms.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t\tms.removeEventListener('sourceended', this.e.onSourceEnded);\n\t\t\tms.removeEventListener('sourceclose', this.e.onSourceClose);\n\t\t\tthis._pendingSourceBufferInit = [];\n\t\t\tthis._isBufferFull = false;\n\t\t\tthis._idrList.clear();\n\t\t\tthis._mediaSource = null;\n\t\t}\n\n\t\tif (this._mediaElement) {\n\t\t\tthis._mediaElement.src = '';\n\t\t\tthis._mediaElement.removeAttribute('src');\n\t\t\tthis._mediaElement = null;\n\t\t}\n\t\tif (this._mediaSourceObjectURL) {\n\t\t\twindow.URL.revokeObjectURL(this._mediaSourceObjectURL);\n\t\t\tthis._mediaSourceObjectURL = null;\n\t\t}\n\t}\n\n\tappendInitSegment(initSegment, deferred) {\n\t\tLog.i(this.TAG, \"appendInitSegment\", initSegment);\n\t\tif (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n\t\t\t// sourcebuffer creation requires mediaSource.readyState === 'open'\n\t\t\t// so we defer the sourcebuffer creation, until sourceopen event triggered\n\t\t\tthis._pendingSourceBufferInit.push(initSegment);\n\t\t\t// make sure that this InitSegment is in the front of pending segments queue\n\t\t\tthis._pendingSegments[initSegment.type].push(initSegment);\n\t\t\treturn;\n\t\t}\n\n\t\tlet is = initSegment;\n\t\tlet mimeType = `${is.container}`;\n\t\tif (is.codec && is.codec.length > 0) {\n\t\t\tmimeType += `;codecs=${is.codec}`;\n\t\t}\n\n\t\tlet firstInitSegment = false;\n\n\t\tLog.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n\t\tthis._lastInitSegments[is.type] = is;\n\n\t\tif (mimeType !== this._mimeTypes[is.type]) {\n\t\t\tif (!this._mimeTypes[is.type]) {  // empty, first chance create sourcebuffer\n\t\t\t\tfirstInitSegment = true;\n\t\t\t\ttry {\n\t\t\t\t\tlet sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n\t\t\t\t\tsb.addEventListener('error', this.e.onSourceBufferError);\n\t\t\t\t\tsb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\tthis._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLog.v(this.TAG, `Notice: ${is.type} mimeType changed, origin: ${this._mimeTypes[is.type]}, target: ${mimeType}`);\n\t\t\t}\n\t\t\tthis._mimeTypes[is.type] = mimeType;\n\t\t}\n\n\t\tif (!deferred) {\n\t\t\t// deferred means this InitSegment has been pushed to pendingSegments queue\n\t\t\tthis._pendingSegments[is.type].push(is);\n\t\t}\n\t\tif (!firstInitSegment) {  // append immediately only if init segment in subsequence\n\t\t\tif (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n\t\t\t\tthis._doAppendSegments();\n\t\t\t}\n\t\t}\n\t\tif (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n\t\t\t// 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n\t\t\t// Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n\t\t\tthis._requireSetMediaDuration = true;\n\t\t\tthis._pendingMediaDuration = is.mediaDuration / 1000;  // in seconds\n\t\t\tthis._updateMediaSourceDuration();\n\t\t}\n\t}\n\n\tappendMediaSegment(mediaSegment) {\n\t\tLog.d(this.TAG, \"appendMediaSegment\", mediaSegment);\n\t\tlet ms = mediaSegment;\n\t\tthis._pendingSegments[ms.type].push(ms);\n\n\t\tif (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n\t\t\tthis._doCleanupSourceBuffer();\n\t\t}\n\n\t\tlet sb = this._sourceBuffers[ms.type];\n\t\tif (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n\t\t\tthis._doAppendSegments();\n\t\t}\n\t}\n\n\tseek(seconds) {\n\t\t// remove all appended buffers\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tif (!this._sourceBuffers[type]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// abort current buffer append algorithm\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (this._mediaSource.readyState === 'open') {\n\t\t\t\ttry {\n\t\t\t\t\t// If range removal algorithm is running, InvalidStateError will be throwed\n\t\t\t\t\t// Ignore it.\n\t\t\t\t\tsb.abort();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// IDRList should be clear\n\t\t\tthis._idrList.clear();\n\n\t\t\t// pending segments should be discard\n\t\t\tlet ps = this._pendingSegments[type];\n\t\t\tps.splice(0, ps.length);\n\n\t\t\tif (this._mediaSource.readyState === 'closed') {\n\t\t\t\t// Parent MediaSource object has been detached from HTMLMediaElement\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// record ranges to be remove from SourceBuffer\n\t\t\tfor (let i = 0; i < sb.buffered.length; i++) {\n\t\t\t\tlet start = sb.buffered.start(i);\n\t\t\t\tlet end = sb.buffered.end(i);\n\t\t\t\tthis._pendingRemoveRanges[type].push({start, end});\n\t\t\t}\n\n\t\t\t// if sb is not updating, let's remove ranges now!\n\t\t\tif (!sb.updating) {\n\t\t\t\tthis._doRemoveRanges();\n\t\t\t}\n\n\t\t\t// Safari 10 may get InvalidStateError in the later appendBuffer() after SourceBuffer.remove() call\n\t\t\t// Internal parser's state may be invalid at this time. Re-append last InitSegment to workaround.\n\t\t\t// Related issue: https://bugs.webkit.org/show_bug.cgi?id=159230\n\t\t\tif (Browser.safari) {\n\t\t\t\tlet lastInitSegment = this._lastInitSegments[type];\n\t\t\t\tif (lastInitSegment) {\n\t\t\t\t\tthis._pendingSegments[type].push(lastInitSegment);\n\t\t\t\t\tif (!sb.updating) {\n\t\t\t\t\t\tthis._doAppendSegments();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tendOfStream() {\n\t\tlet ms = this._mediaSource;\n\t\tlet sb = this._sourceBuffers;\n\t\tif (!ms || ms.readyState !== 'open') {\n\t\t\tif (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n\t\t\t\t// If MediaSource hasn't turned into open state, and there're pending segments\n\t\t\t\t// Mark pending endOfStream, defer call until all pending segments appended complete\n\t\t\t\tthis._hasPendingEos = true;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n\t\t\t// If any sourcebuffer is updating, defer endOfStream operation\n\t\t\t// See _onSourceBufferUpdateEnd()\n\t\t\tthis._hasPendingEos = true;\n\t\t} else {\n\t\t\tthis._hasPendingEos = false;\n\t\t\t// Notify media data loading complete\n\t\t\t// This is helpful for correcting total duration to match last media segment\n\t\t\t// Otherwise MediaElement's ended event may not be triggered\n\t\t\tms.endOfStream();\n\t\t}\n\t}\n\n\tgetNearestKeyframe(dts) {\n\t\treturn this._idrList.getLastSyncPointBeforeDts(dts);\n\t}\n\n\t_needCleanupSourceBuffer() {\n\t\tif (!this._config.autoCleanupSourceBuffer) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet currentTime = this._mediaElement.currentTime;\n\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (sb) {\n\t\t\t\tlet buffered = sb.buffered;\n\t\t\t\tif (buffered.length >= 1) {\n\t\t\t\t\tif (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_doCleanupSourceBuffer() {\n\t\tlet currentTime = this._mediaElement.currentTime;\n\n\t\tfor (let type in this._sourceBuffers) {\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tif (sb) {\n\t\t\t\tlet buffered = sb.buffered;\n\t\t\t\tlet doRemove = false;\n\n\t\t\t\tfor (let i = 0; i < buffered.length; i++) {\n\t\t\t\t\tlet start = buffered.start(i);\n\t\t\t\t\tlet end = buffered.end(i);\n\n\t\t\t\t\tif (start <= currentTime && currentTime < end + 3) {  // padding 3 seconds\n\t\t\t\t\t\tif (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n\t\t\t\t\t\t\tdoRemove = true;\n\t\t\t\t\t\t\tlet removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n\t\t\t\t\t\t\tthis._pendingRemoveRanges[type].push({start: start, end: removeEnd});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (end < currentTime) {\n\t\t\t\t\t\tdoRemove = true;\n\t\t\t\t\t\tthis._pendingRemoveRanges[type].push({start: start, end: end});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (doRemove && !sb.updating) {\n\t\t\t\t\tthis._doRemoveRanges();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateMediaSourceDuration() {\n\t\tlet sb = this._sourceBuffers;\n\t\tif (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n\t\t\treturn;\n\t\t}\n\t\tif ((sb.video && sb.video.updating) || (sb.audio && sb.audio.updating)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet current = this._mediaSource.duration;\n\t\tlet target = this._pendingMediaDuration;\n\n\t\tif (target > 0 && (isNaN(current) || target > current)) {\n\t\t\tLog.v(this.TAG, `Update MediaSource duration from ${current} to ${target}`);\n\t\t\tthis._mediaSource.duration = target;\n\t\t}\n\n\t\tthis._requireSetMediaDuration = false;\n\t\tthis._pendingMediaDuration = 0;\n\t}\n\n\t_doRemoveRanges() {\n\t\tfor (let type in this._pendingRemoveRanges) {\n\t\t\tif (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet sb = this._sourceBuffers[type];\n\t\t\tlet ranges = this._pendingRemoveRanges[type];\n\t\t\twhile (ranges.length && !sb.updating) {\n\t\t\t\tlet range = ranges.shift();\n\t\t\t\tsb.remove(range.start, range.end);\n\t\t\t}\n\t\t}\n\t}\n\n\t_doAppendSegments() {\n\t\tlet pendingSegments = this._pendingSegments;\n\n\t\tfor (let type in pendingSegments) {\n\t\t\tif (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pendingSegments[type].length > 0) {\n\t\t\t\tlet segment = pendingSegments[type].shift();\n\n\t\t\t\tif (segment.timestampOffset) {\n\t\t\t\t\t// For MPEG audio stream in MSE, if unbuffered-seeking occurred\n\t\t\t\t\t// We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n\t\t\t\t\tlet currentOffset = this._sourceBuffers[type].timestampOffset;\n\t\t\t\t\tlet targetOffset = segment.timestampOffset / 1000;  // in seconds\n\n\t\t\t\t\tlet delta = Math.abs(currentOffset - targetOffset);\n\t\t\t\t\tif (delta > 0.1) {  // If time delta > 100ms\n\t\t\t\t\t\tLog.v(this.TAG, `Update MPEG audio timestampOffset from ${currentOffset} to ${targetOffset}`);\n\t\t\t\t\t\tthis._sourceBuffers[type].timestampOffset = targetOffset;\n\t\t\t\t\t}\n\t\t\t\t\tdelete segment.timestampOffset;\n\t\t\t\t}\n\n\t\t\t\tif (!segment.data || segment.data.byteLength === 0) {\n\t\t\t\t\t// Ignore empty buffer\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tthis._sourceBuffers[type].appendBuffer(segment.data);\n\t\t\t\t\tthis._isBufferFull = false;\n\t\t\t\t\tif (type === 'video' && segment.hasOwnProperty('info')) {\n\t\t\t\t\t\tthis._idrList.appendArray(segment.info.syncPoints);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._pendingSegments[type].unshift(segment);\n\t\t\t\t\tif (error.code === 22) {  // QuotaExceededError\n\t\t\t\t\t\t/* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n\t\t\t\t\t\t * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n\t\t\t\t\t\t * SourceBuffer eviction policy may be changed in future version of FireFox.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Related issues:\n\t\t\t\t\t\t * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n\t\t\t\t\t\t * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n\t\t\t\t\t\t */\n\n\t\t\t\t\t\t// report buffer full, abort network IO\n\t\t\t\t\t\tif (!this._isBufferFull) {\n\t\t\t\t\t\t\tthis._emitter.emit(MSEEvents.BUFFER_FULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._isBufferFull = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.e(this.TAG, error.message);\n\t\t\t\t\t\tthis._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSourceOpen() {\n\t\tLog.v(this.TAG, 'MediaSource onSourceOpen');\n\t\tthis._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t// deferred sourcebuffer creation / initialization\n\t\tif (this._pendingSourceBufferInit.length > 0) {\n\t\t\tlet pendings = this._pendingSourceBufferInit;\n\t\t\twhile (pendings.length) {\n\t\t\t\tlet segment = pendings.shift();\n\t\t\t\tthis.appendInitSegment(segment, true);\n\t\t\t}\n\t\t}\n\t\t// there may be some pending media segments, append them\n\t\tif (this._hasPendingSegments()) {\n\t\t\tthis._doAppendSegments();\n\t\t}\n\t\tthis._emitter.emit(MSEEvents.SOURCE_OPEN);\n\t}\n\n\t_onSourceEnded() {\n\t\t// fired on endOfStream\n\t\tLog.v(this.TAG, 'MediaSource onSourceEnded');\n\t}\n\n\t_onSourceClose() {\n\t\t// fired on detaching from media element\n\t\tLog.v(this.TAG, 'MediaSource onSourceClose');\n\t\tif (this._mediaSource && this.e != null) {\n\t\t\tthis._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\t\t\tthis._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n\t\t\tthis._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n\t\t}\n\t}\n\n\t_hasPendingSegments() {\n\t\tlet ps = this._pendingSegments;\n\t\treturn ps.video.length > 0 || ps.audio.length > 0;\n\t}\n\n\t_hasPendingRemoveRanges() {\n\t\tlet prr = this._pendingRemoveRanges;\n\t\treturn prr.video.length > 0 || prr.audio.length > 0;\n\t}\n\n\t_onSourceBufferUpdateEnd() {\n\t\tif (this._requireSetMediaDuration) {\n\t\t\tthis._updateMediaSourceDuration();\n\t\t} else if (this._hasPendingRemoveRanges()) {\n\t\t\tthis._doRemoveRanges();\n\t\t} else if (this._hasPendingSegments()) {\n\t\t\tthis._doAppendSegments();\n\t\t} else if (this._hasPendingEos) {\n\t\t\tthis.endOfStream();\n\t\t}\n\t\tthis._emitter.emit(MSEEvents.UPDATE_END);\n\t}\n\n\t_onSourceBufferError(e) {\n\t\tLog.e(this.TAG, `SourceBuffer Error: ${e}`);\n\t\t// this error might not always be fatal, just ignore it\n\t}\n\n}\n\nexport default MSEController;\n"],"names":["__webpack_require__","chunkId","obj","prop","Object","prototype","hasOwnProperty","call","b","document","baseURI","self","location","href","Log","static","INFO","level","tag","txt","tmpLevel","LEVEL","loglevels","OFF","callstack","_getStackTrace","shift","color","TRACE","DEBUG","WARN","ERROR","CRITICAL","_print","WITH_STACKTRACE","console","group","groupCollapsed","i","length","log","groupEnd","dont","exist","e","stack","lines","split","push","msg","_output","ListenerList","TAG","constructor","addEventListener","event","listener","this","addListener","removeListener","entry","splice","removeAllListeners","emit","data","IDRSampleList","_list","clear","appendArray","syncPoints","list","originalDts","Array","apply","getLastSyncPointBeforeDts","dts","idx","last","mid","lbound","ubound","Math","floor","RuntimeException","message","_message","name","toString","IllegalStateException","super","defaultConfig","enableWorker","enableStashBuffer","stashInitialSize","undefined","isLive","lazyLoad","lazyLoadMaxDuration","lazyLoadRecoverDuration","deferLoadAfterSourceOpen","autoCleanupSourceBuffer","autoCleanupMaxBackwardDuration","autoCleanupMinBackwardDuration","statisticsInfoReportInterval","fixAudioTimestampGap","accurateSeek","seekType","seekParamStart","seekParamEnd","rangeLoadZeroStart","customSeekHandler","reuseRedirectedURL","headers","customLoader","TransmuxingEvents","MSEEvents","Browser","ua","navigator","userAgent","toLowerCase","match","exec","indexOf","platform_match","matched","browser","version","majorVersion","platform","versionArray","major","parseInt","string","minor","build","chrome","opr","safari","webkit","rv","iemobile","msie","edge","msedge","opera","android","key","assign","detect","window","_mediaElement","wss","host","port","WSSReconnect","isConnected","WebRTMPWorker","Worker","URL","type","_emitter","evt","WorkerListener","open","postMessage","cmd","disconnect","connect","appName","play","streamName","pause","enable","setTimeout","slice","_config","onvLoadedMetadata","_onvLoadedMetadata","bind","onvSeeking","_onvSeeking","onvCanPlay","_onvCanPlay","onvStalled","_onvStalled","onvProgress","_onvProgress","_checkAndResumeStuckPlayback","stalled","media","_receivedCanPlay","readyState","buffered","currentTime","start","_requestSetTime","removeEventListener","_pendingSeekTime","target","videoBeginTime","_isTimepointBuffered","_alwaysSeekKeyframe","idr","_msectl","getNearestKeyframe","_progressChecker","_checkProgressAndResume","_seekpointRecord","seekPoint","recordTime","_now","_checkAndApplyUnbufferedSeekpoint","seconds","from","to","end","needResume","clearInterval","clearTimeout","seek","_transmuxer","_onmseBufferFull","_onmseUpdateEnd","currentRangeStart","currentRangeEnd","_suspendTransmuxer","destroy","unload","detachMediaElement","_mediaDataSource","Promise","resolve","reject","success","attachMediaElement","mediaElement","config","onSourceOpen","_onSourceOpen","onSourceEnded","_onSourceEnded","onSourceClose","_onSourceClose","onSourceBufferError","_onSourceBufferError","onSourceBufferUpdateEnd","_onSourceBufferUpdateEnd","_mediaSource","_mediaSourceObjectURL","_isBufferFull","_hasPendingEos","_requireSetMediaDuration","_pendingMediaDuration","_pendingSourceBufferInit","_mimeTypes","video","audio","_sourceBuffers","_lastInitSegments","_pendingSegments","_pendingRemoveRanges","_idrList","on","off","ms","MediaSource","createObjectURL","src","ps","sb","removeSourceBuffer","error","endOfStream","removeAttribute","revokeObjectURL","appendInitSegment","initSegment","deferred","is","mimeType","container","codec","firstInitSegment","addSourceBuffer","code","updating","_doAppendSegments","mediaDuration","_updateMediaSourceDuration","appendMediaSegment","mediaSegment","_needCleanupSourceBuffer","_doCleanupSourceBuffer","_hasPendingRemoveRanges","abort","_doRemoveRanges","lastInitSegment","_hasPendingSegments","doRemove","removeEnd","current","duration","isNaN","ranges","range","remove","pendingSegments","segment","timestampOffset","currentOffset","targetOffset","abs","byteLength","appendBuffer","info","unshift","pendings","prr"],"sourceRoot":""}